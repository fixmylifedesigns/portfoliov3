"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/LoaderUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeText: () => (/* binding */ decodeText)\n/* harmony export */ });\nfunction decodeText(array) {\n    if (typeof TextDecoder !== \"undefined\") {\n        return new TextDecoder().decode(array);\n    }\n    let s = \"\";\n    for(let i = 0, il = array.length; i < il; i++){\n        s += String.fromCharCode(array[i]);\n    }\n    try {\n        return decodeURIComponent(escape(s));\n    } catch (e) {\n        return s;\n    }\n}\n //# sourceMappingURL=LoaderUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsV0FBV0MsS0FBSztJQUN2QixJQUFJLE9BQU9DLGdCQUFnQixhQUFhO1FBQ3RDLE9BQU8sSUFBSUEsY0FBY0MsTUFBTSxDQUFDRjtJQUNsQztJQUNBLElBQUlHLElBQUk7SUFDUixJQUFLLElBQUlDLElBQUksR0FBR0MsS0FBS0wsTUFBTU0sTUFBTSxFQUFFRixJQUFJQyxJQUFJRCxJQUFLO1FBQzlDRCxLQUFLSSxPQUFPQyxZQUFZLENBQUNSLEtBQUssQ0FBQ0ksRUFBRTtJQUNuQztJQUNBLElBQUk7UUFDRixPQUFPSyxtQkFBbUJDLE9BQU9QO0lBQ25DLEVBQUUsT0FBT1EsR0FBRztRQUNWLE9BQU9SO0lBQ1Q7QUFDRjtBQUdFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qcz9lNWNhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRlY29kZVRleHQoYXJyYXkpIHtcbiAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXkpO1xuICB9XG4gIGxldCBzID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZXhwb3J0IHtcbiAgZGVjb2RlVGV4dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlclV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImRlY29kZVRleHQiLCJhcnJheSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwicyIsImkiLCJpbCIsImxlbmd0aCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = /* @__PURE__ */ (()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")))();\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsTUFBTUMsVUFBMEIsYUFBSCxHQUFJLEtBQU1DLFNBQVNGLDJDQUFRQSxDQUFDRyxPQUFPLENBQUMsUUFBUSxJQUFHO0FBRzFFLENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanM/ZjE3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgdmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSkpKCk7XG5leHBvcnQge1xuICB2ZXJzaW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJFVklTSU9OIiwidmVyc2lvbiIsInBhcnNlSW50IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = ()=>{\n    if (generated) return generated;\n    const wasm_base = \"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\";\n    const wasm_simd = \"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\";\n    const detector = new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        3,\n        2,\n        0,\n        0,\n        5,\n        3,\n        1,\n        0,\n        1,\n        12,\n        1,\n        0,\n        10,\n        22,\n        2,\n        12,\n        0,\n        65,\n        0,\n        65,\n        0,\n        65,\n        0,\n        252,\n        10,\n        0,\n        0,\n        11,\n        7,\n        0,\n        65,\n        0,\n        253,\n        15,\n        26,\n        11\n    ]);\n    const wasmpack = new Uint8Array([\n        32,\n        0,\n        65,\n        253,\n        3,\n        1,\n        2,\n        34,\n        4,\n        106,\n        6,\n        5,\n        11,\n        8,\n        7,\n        20,\n        13,\n        33,\n        12,\n        16,\n        128,\n        9,\n        116,\n        64,\n        19,\n        113,\n        127,\n        15,\n        10,\n        21,\n        22,\n        14,\n        255,\n        66,\n        24,\n        54,\n        136,\n        107,\n        18,\n        23,\n        192,\n        26,\n        114,\n        118,\n        132,\n        17,\n        77,\n        101,\n        130,\n        144,\n        27,\n        87,\n        131,\n        44,\n        45,\n        74,\n        156,\n        154,\n        70,\n        167\n    ]);\n    if (typeof WebAssembly !== \"object\") {\n        return {\n            supported: false\n        };\n    }\n    let wasm = wasm_base;\n    if (WebAssembly.validate(detector)) {\n        wasm = wasm_simd;\n    }\n    let instance;\n    const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result)=>{\n        instance = result.instance;\n        instance.exports.__wasm_call_ctors();\n    });\n    function unpack(data) {\n        const result = new Uint8Array(data.length);\n        for(let i = 0; i < data.length; ++i){\n            const ch = data.charCodeAt(i);\n            result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n        }\n        let write = 0;\n        for(let i = 0; i < data.length; ++i){\n            result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n        }\n        return result.buffer.slice(0, write);\n    }\n    function decode(fun, target, count, size, source, filter) {\n        const sbrk = instance.exports.sbrk;\n        const count4 = count + 3 & ~3;\n        const tp = sbrk(count4 * size);\n        const sp = sbrk(source.length);\n        const heap = new Uint8Array(instance.exports.memory.buffer);\n        heap.set(source, sp);\n        const res = fun(tp, count, size, sp, source.length);\n        if (res === 0 && filter) {\n            filter(tp, count4, size);\n        }\n        target.set(heap.subarray(tp, tp + count * size));\n        sbrk(tp - sbrk(0));\n        if (res !== 0) {\n            throw new Error(`Malformed buffer data: ${res}`);\n        }\n    }\n    const filters = {\n        // legacy index-based enums for glTF\n        0: \"\",\n        1: \"meshopt_decodeFilterOct\",\n        2: \"meshopt_decodeFilterQuat\",\n        3: \"meshopt_decodeFilterExp\",\n        // string-based enums for glTF\n        NONE: \"\",\n        OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n        QUATERNION: \"meshopt_decodeFilterQuat\",\n        EXPONENTIAL: \"meshopt_decodeFilterExp\"\n    };\n    const decoders = {\n        // legacy index-based enums for glTF\n        0: \"meshopt_decodeVertexBuffer\",\n        1: \"meshopt_decodeIndexBuffer\",\n        2: \"meshopt_decodeIndexSequence\",\n        // string-based enums for glTF\n        ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n        TRIANGLES: \"meshopt_decodeIndexBuffer\",\n        INDICES: \"meshopt_decodeIndexSequence\"\n    };\n    generated = {\n        ready: promise,\n        supported: true,\n        decodeVertexBuffer (target, count, size, source, filter) {\n            decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);\n        },\n        decodeIndexBuffer (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n        },\n        decodeIndexSequence (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n        },\n        decodeGltfBuffer (target, count, size, source, mode, filter) {\n            decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);\n        }\n    };\n    return generated;\n};\n //# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBO0FBQ0osTUFBTUMsaUJBQWlCO0lBQ3JCLElBQUlELFdBQ0YsT0FBT0E7SUFDVCxNQUFNRSxZQUFZO0lBQ2xCLE1BQU1DLFlBQVk7SUFDbEIsTUFBTUMsV0FBVyxJQUFJQyxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTUMsV0FBVyxJQUFJRCxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsSUFBSSxPQUFPRSxnQkFBZ0IsVUFBVTtRQUNuQyxPQUFPO1lBQ0xDLFdBQVc7UUFDYjtJQUNGO0lBQ0EsSUFBSUMsT0FBT1A7SUFDWCxJQUFJSyxZQUFZRyxRQUFR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QUFrQjNCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU07WUFDM0NMLE9BQU9oQixTQUFTTSxPQUFPLENBQUN3Qyx5QkFBeUIsRUFBRTVCLFFBQVFDLE9BQU9DLE1BQU1DO1FBQzFFO1FBQ0EwQixxQkFBb0I3QixNQUFNLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1lBQzdDTCxPQUFPaEIsU0FBU00sT0FBTyxDQUFDMEMsMkJBQTJCLEVBQUU5QixRQUFRQyxPQUFPQyxNQUFNQztRQUM1RTtRQUNBNEIsa0JBQWlCL0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFNkIsSUFBSSxFQUFFNUIsTUFBTTtZQUN4RE4sT0FDRWhCLFNBQVNNLE9BQU8sQ0FBQ2dDLFFBQVEsQ0FBQ1ksS0FBSyxDQUFDLEVBQ2hDaEMsUUFDQUMsT0FDQUMsTUFDQUMsUUFDQXJCLFNBQVNNLE9BQU8sQ0FBQzJCLE9BQU8sQ0FBQ1gsT0FBTyxDQUFDO1FBRXJDO0lBQ0Y7SUFDQSxPQUFPakM7QUFDVDtBQUdFLENBQ0YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanM/YTdmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZ2VuZXJhdGVkO1xuY29uc3QgTWVzaG9wdERlY29kZXIgPSAoKSA9PiB7XG4gIGlmIChnZW5lcmF0ZWQpXG4gICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgY29uc3Qgd2FzbV9iYXNlID0gXCJCOWg5ejl0RkJCQkY4Zkw5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmE5Z0VhYWFGYUVNY0JGRkZHR0dFSUlJTEY5d0ZGRkxFRkJGS05GYUZDeC9JRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJGOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCR3k5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCRW45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQklpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCS0k5ejlpcWxCT2MreDh5Y0dCTS9xUUZUYThqVVVVVUJDVS9FQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHVGtVVVVCUk5DVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSVkFFQ0ZKUklDQlJjR1hFWEFjQUY5UFFGQVZBRkFjbEFjQVZKQUY5SnlSTUdYR1hBRzlGUUJBTUNiSkhLQzl3WlJTQUtDSXJDRUpDR3JSUUFOQ1VHSlJmQ0JSYkFJUlRFWEdYQU9BVGxBUTlQUUJDQlJJU0VNQVRBUUpSSUdYQVM5RlFCQ0JSdENCUkVFWEdYQU9BSWxDaTlQUUJDQlJJU0xNQU5DVS9DQkpBRUpSS0dYR1hHWEdYR1hBVEFFQ0tySjJCQkF0Q0tackNFWmZJQkZHRUJNQUtoQjgzRUJBS0NOSmhCODNFQlNFTUFLQUkyQklBSTJCQkhtQ0tySFlBWUNFNkhZeTg2QkJBS0NGSkFJQ0lKQVlKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDR0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ0VKQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NJSkFZQW1KSFkyQkJBSTJCRkhtQ0tySFBBUENFNkhQeTg2QkJBS0NMSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDS0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ09KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NOSkFZQW1KSFkyQkJBSTJCR0htQ0tySFBBUENFNkhQeTg2QkJBS0NWSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDY0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ01KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NTSkFZQW1KSG0yQkJBSTJCRUhJQ0tySFlBWUNFNkhZeTg2QkJBS0NRSkFtQVlKSG0yQkJBSUNJckNFWkhZQVlDRTZIWXk4NkJCQUtDZkpBbUFZSkhtMkJCQUlDR3JDRVpIWUFZQ0U2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ0VaSElBSUNFNkhJeTg2QkJBS0FJSlJJU0dNQUtBSTJCTkFJMkJCSG1DSXJIWUFZQ2I2SFl5ODZCQkFLQ0ZKQUlDTkpBWUpIWTJCQkFtQ2JaSG1BbUNiNkhteTg2QkJBS0NHSkFZQW1KSG0yQkJBSTJCRkhZQ0lySFBBUENiNkhQeTg2QkJBS0NFSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDSUpBbUFZSkhtMkJCQUkyQkdIWUNJckhQQVBDYjZIUHk4NkJCQUtDTEpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ0tKQW1BWUpIbTJCQkFJMkJFSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ09KQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NOSkFtQVlKSG0yQkJBSTJCSUhZQ0lySFBBUENiNkhQeTg2QkJBS0NWSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDY0pBbUFZSkhtMkJCQUkyQkxIWUNJckhQQVBDYjZIUHk4NkJCQUtDTUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ1NKQW1BWUpIbTJCQkFJMkJLSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1FKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSTJCT0hJQ0lySFlBWUNiNkhZeTg2QkJBS0NiSkFtQVlKSEsyQkJBSUNiWkhJQUlDYjZISXk4NkJCQUtBSUpSSVNGTUFLQUk4cEJCODNCQkFLQ05KQUlDTko4cEJCODNCQkFJQ1RKUklNQXRDR0pSdEFFQ1RKSEVBUzlKUUJNTUdYQUlRQkNCUklTRU1HWEFNOUZRQkFOQWJKMkJCUnRDQlJLQWZSRUVYQUVBTkNVL0NCSkFLSjJCQkhUQ0ZyQ0JBVENGWmw5ekF0Skh0ODZCQkFFQUdKUkVBS0NGSkhLQU05SFFCTU1BZkNGSlJmQUlSVEFiQ0ZKSGJBRzlIUUJNTUFCQWNBRzlzSkFOQ1VHSkFNQUc5c1RrVVVVQnBBTkFOQ1VHSkFNQ2FKQUc5c0pBR1RrVVVVQnBNQU1DQkFJeUFjSlJjQUlRQk1DOStSS1NGTUNCQzk5QU9BSWxBR0NBQUdDQTlMeTZ5UktNQUxDVS9FQko4a1VVVVVCQUtNK09tRlRhOGpVVVVVQkNvRmxITDhrVVVVVUJDOStSS0dYQUZDRTl1SE9DdEpBSTlMUUJDYVJLQUUyQkJITkMvd0ZaQy9nRjlIUUJBTkNiWkhWQ0Y5TFFCQUxDb0JKQ2dGQ1VGVCtKVVVVQnBBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNK2xMS0ZhRjk5R2FHOTlGYUc5OUdYR1hBR0NJOUhRQkFGOUZRRkVYR1hHWDlEQkJCOC85REJCQisvQUJDR0pIRzFCQit5QUIxQkJIRSt5SEkrTCtUQUJDRkpITDFCQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REJCLytoQU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg2QkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg2QkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg2QkJBQkNJSlJCQUZDYUpIRlFCU0dNTUFGOUZRQkVYR1hHWDlEQkJCOC85REJCQisvQUJDSUpIRzh1RkIreUFCOHVGQkhFK3lISStMK1RBQkNHSkhMOHVGQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REIvK2c2QU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg3RkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg3RkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg3RkJBQkNOSlJCQUZDYUpIRlFCTU1NL1NFSUVhRTk5RWFGOTlHWEFGOUZRQkNCUkVBQlJJRVhHWEdYOUQvekk4MTgvQUlDS0o4dUZCSExDRXEreStWSEtBSTh1RkIreStVSE85REIvK2c2K1U5REJCQjgvOURCQkIrL0FPOURCQkJCOWd5K1NITitMOURCQkI5UDlkOUZRQkFOK29SVlNGTUNVVVVVOTRSVk1BSUNJSjh1RkJSY0FJQ0dKOHVGQlJNQUJBTENGSkNFWkFFcUNGV0pBVjg3RkJHWEdYQUtBTSt5K1VITjlEQi8rZzYrVTlEQkJCOC85REJCQisvQU45REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JNU0ZNQ1VVVVU5NFJNTUFCQUxDR0pDRVpBRXFDRldKQU04N0ZCR1hHWEFLQWMreStVSEs5REIvK2c2K1U5REJCQjgvOURCQkIrL0FLOURCQkJCOWd5K1NIUytMOURCQkI5UDlkOUZRQkFTK29SY1NGTUNVVVVVOTRSY01BQkFMQ2FKQ0VaQUVxQ0ZXSkFjODdGQkdYR1g5REJCVTgvQU9BTytVK1RBTkFOK1UrVEFLQUsrVStUSE85REJCQkJBTzlEQkJCQjlneStSOURCLytnNitVOURCQkI4LytTSE8rTDlEQkJCOVA5ZDlGUUJBTytvUmNTRk1DVVVVVTk0UmNNQUJBTENFWkFFcUNGV0pBYzg3RkJBSUNOSlJJQUVDSUpSRUFGQ2FKSEZRQk1NTTlKQkdYQUdDR3JBRjlzSEY5RlFCRVhBQkFCOG9HQkhHQ05XQ045MSt5QUdDaTkxQ25XQ1VVVS84RUorKytVODRHQkFCQ0lKUkJBRkNhSkhGUUJNTU05VEZFYUNCQ0I4b0dVa1VVQkhGQUJDRUpDOThaSkhCakdVa1VVQkdYR1hBQjgvQkNUV0hHdVFCQ2FSRUFCQUdsQ2dnRUpDVHJYQkNhNlFGTUFGUkVNQUVNL2xGRkZhR1hHWEFGQUJxQ0VaOUZRQkFCUkVTRk1HWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBRjhvR0JqR0JBRUNJSkFGQ0lKOG9HQmpHQkFFQ05KQUZDTko4b0dCakdCQUVDU0pBRkNTSjhvR0JqR0JBRUNUSlJFQUZDVEpSRkFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBRjhvR0JqR0JBRkNJSlJGQUVDSUpSRUFHQzk4SkhHQ0U5TFFCTU1HWEFHOUZRQkVYQUVBRjJCQjg2QkJBRUNGSlJFQUZDRkpSRkFHQ2FKSEdRQk1NQUJNb0ZGR2FHWEdYQUJDRVo5RlFCQUJSRVNGTUFGQ2dGWkMrQndzTjlzUklHWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBSWpHQkFFQ1NKQUlqR0JBRUNOSkFJakdCQUVDSUpBSWpHQkFFQ1RKUkVBR0M5d0pIR0NiOUxRQk1NQUdDSTlKUUJFWEFFQUlqR0JBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGODZCQkFFQ0ZKUkVBR0NhSkhHUUJNTUFCTU1NRkJDVU5NSVQ5a0JCXCI7XG4gIGNvbnN0IHdhc21fc2ltZCA9IFwiQjloOXo5dEZCQkJGaUk5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmFFTWNCQkZCRkZHR0dFSUxGOXdGRkZMRUZCRktORmFGQ3gvYUZNTy9MRlZLOXR2OXQ5dnE5NUdCdDlmOWY5MzloOXo5dDlmOWo5aDlzOXM5ZjlqVzl2cTl6QkJwOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OVd2cVd2OTRoOTE5bTltdnFCRzhaOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0aDkxOW05bXZxQkl5OXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0OVR2Wjkxdjl1OWp2QkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UDlqV0JLaTl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVI5MTloV0JPbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOUY5NDl3Qk5JOXo5aXFsQlZjK045SWNJQlRFTTkrRkxhOGpVVVVVQkNUbFJCQ0JSRkVYQ0JSR0NCUkVFWEFCQ05KQUdKQUVDVWFBRkFHckNGWkhJeTg2QkJBRUFJSlJFQUdDRkpIR0NOOUhRQk1BRkN4K1lVVUJKQUU4NkJCQUZDRVdDeGtVVUJKQUI4cEVOODNFQkFGQ0ZKSEZDVUc5SFFCTU1rOGxMYmFFOTdGOStGYUw5NzhqVVVVVUJDVS9LQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHLzhjQkJDVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSTkFFQ0ZKUktDQlJWR1hFWEFWQUY5UFFGQU5BRkFWbEFWQU5KQUY5SnlSY0dYR1hBRzlGUUJBY0NiSkhJQzl3WkhNQ0U5c1JTQU1DRldSUUFJQ0lyQ0VKQ0dyUmZDQlJiRVhBS1JUQ0JSdEdYRVhHWEFPQVRsQWY5UFFCQ0JSS1NMTUFMQ1UvQ0JKQXRBTTlzSlJtQVRBZkpSS0NCUkVHWEFNQ29COUpRQkFPQUtsQy9nQjlKUUJDQlJJRVhBbUFJSlJFR1hHWEdYR1hHWEFUQUlDS3JKMkJCSFlDRVpmSUJGR0VCTUFFQ0JEdERNSUJTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlCQUtDVEpSS01HWEdYR1hHWEdYQVlDR3JDRVpmSUJGR0VCTUFFQ0JEdERNSVRTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlUQUtDVEpSS01HWEdYR1hHWEdYQVlDSXJDRVpmSUJGR0VCTUFFQ0JEdERNSUFTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlBQUtDVEpSS01HWEdYR1hHWEdYQVlDS3JmSUJGR0VCTUFFQ0JEdERNSTh3U0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NJSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJBWUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSFlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSTh3QUtDTkpBZURlQkpBWUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUk4d0FLQ1RKUktNQUlDb0JKUkVBSUNVRkpBTTlMUUZBRVJJQU9BS2xDL2ZCOUxRQk1NR1hBRUFNOVBRQkFFQ0VyUklFWEdYQU9BS2xDaTlQUUJDQlJLU09NQW1BRUpSWUdYR1hHWEdYR1hBVEFFQ0tySjJCQkFJQ0tackNFWmZJQkZHRUJNQVlDQkR0RE1JQlNFTUFZQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BWUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BWUFLREJCQkRNSUJBS0NUSlJLTUFJQ0dKUklBRUNUSkhFQU05SlFCTU1HWEFLOUZRQkFLUlRBdENGSkh0Q0k2UUdTRk1NQ0JSS1NFTUdYQU05RlFCQUxDVUdKQWJKUkVBTEFiSkRCR0JSZUNCUllFWEFFQUxDVS9DQkpBWUpISURCSUJIZENGRDl0QWRDRkRiSFBEOU9EOWhEOVJIZEFJQU1KREJJQkg4WkNGRDl0QThaQVBEOU9EOWhEOVJIOFpEUUJURnRHbUVZSVBMZEtlT25IcEFJQVFKREJJQkh5Q0ZEOXRBeUFQRDlPRDloRDlSSHlBSUFTSkRCSUJIOGNDRkQ5dEE4Y0FQRDlPRDloRDlSSDhjRFFCVEZ0R21FWUlQTGRLZU9uSDhkRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUFlRDl1SGVEeUJqR0JBRUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBcEE4ZERRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4ZkhkQXlBOGNEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4Zkg4WkRRQkZUdEdFbVlJTFBkS09lbkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFkQThaRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSlJFQVlDVEpIWUFNOUpRQk1NQWJDSUpIYkFHOUpRQk1NQUJBVkFHOXNKQUxDVUdKQWNBRzlzLzhjQkJBTEFMQ1VHSkFjQ2FKQUc5c0pBRy84Y0JCTUFjQ0JBS3lBVkpSVkFLUUJNQzkrUktTRk1DQkM5OUFPQUtsQUdDQUFHQ0E5THk2eVJLTUFMQ1UvS0JKOGtVVVVVQkFLTU5CVCtCVVVVQk0rS21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUYvOE1CQUxDODRKaGE4M0VCQUxDOHdKaGE4M0VCQUxDOG9KaGE4M0VCQUxDQUpoYTgzRUJBTENpSmhhODNFQkFMQ1RKaGE4M0VCQUxoYTgzRU5BTGhhODNFQkFFQUlKQzl3SlJjQUVDRkpITkFPSlJNR1hBRjlGUUJDUUNiQVZDRjZ5UlNBQlJFQ0JSVkNCUlFDQlJmQ0JSSUNCUktFWEdYQU1BY3VRQkM5K1JLU0VNR1hHWEFOMkJCSE9DL3ZGOUxRQkFMQ29CSkFPQ0lyQ2E5ekFLSkNiWkNFV0pIYjhvR0lSVEFiOG9HQlJ0R1hBT0NiWkhiQVM5UFFCQUxBT0NhOXpBSUpDYlpDR1dKOG9HQkFWQWJ5Uk9BYjlGUmJHWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQU84N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBT2pHQkFFQ0lKQVRqR0JNQVZBYkpSVkFMQ29CSkFLQ0VXSkhtQU9qR0JBbUFUakdJQUxBSUNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSFRBdGpHQkFUQU9qR0lBSUFiSlJJQUtDRkpSS1NHTUdYR1hBYkNiNlFCQVFBYkpBYkM5ODl6SkNGSlJRU0ZNQU0xQkJIYkNnRlpST0dYR1hBYkNhOU1RQkFNQ0ZKUk1TRk1BTTFCRkhiQ2dCWkNPV0FPQ2dCWnFST0dYQWJDYTlNUUJBTUNHSlJNU0ZNQU0xQkdIYkNnQlpDZldBT3FST0dYQWJDYTlNUUJBTUNFSlJNU0ZNQU0xQkVIYkNnQlpDZFdBT3FST0dYQWJDYTlNUUJBTUNJSlJNU0ZNQU0yQklDOGNXQU9xUk9BTUNMSlJNTUFPQ0ZyQ0JBT0NGWmw5ekFRSlJRTUdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBUTg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFRakdCQUVDSUpBVGpHQk1BTENvQkpBS0NFV0pIT0FRakdCQU9BVGpHSUFMQUlDR1dKQVFqR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhPQXRqR0JBT0FRakdJQUlDRkpSSUFLQ0ZKUktTRk1HWEFPQ0RGOUxRQkFMQUlBY0FPQ2JaSjJCQkhiQ0lySFRsQ2JaQ0dXSjhvR0JBVkNGSkh0QVR5Uk9BTEFJQWJsQ2JaQ0dXSjhvR0JBdEFUOUZIbUpIdEFiQ2JaSFR5UmJBVDlGUlRHWEdYQUdDRzlIUUJBQkFWODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFWakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxBSUNHV0pBVmpHQkFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFWakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQW1KQ2JaSElDR1dKQWJqR0JBTENvQkpBS0NHSkNiWkhLQ0VXSkhPQVZqR0JBT0FiakdJQUtDRkpSS0FJQVRKUklBdEFUSlJWU0ZNQVZDQkFNMkJCSFl5SFRBT0MvK0Y2SFBKUk9BWUNiWlJ0R1hHWEFZQ0lySG1RQkFPQ0ZKUmJTRk1BT1JiQUxBSUFtbENiWkNHV0o4b0dCUk9NR1hHWEF0UUJBYkNGSlJWU0ZNQWJSVkFMQUlBWWxDYlpDR1dKOG9HQlJiTUdYR1hBUDlGUUJBTUNGSlJZU0ZNQU0xQkZIWUNnRlpSVEdYR1hBWUNhOU1RQkFNQ0dKUllTRk1BTTFCR0hZQ2dCWkNPV0FUQ2dCWnFSVEdYQVlDYTlNUUJBTUNFSlJZU0ZNQU0xQkVIWUNnQlpDZldBVHFSVEdYQVlDYTlNUUJBTUNJSlJZU0ZNQU0xQklIWUNnQlpDZFdBVHFSVEdYQVlDYTlNUUJBTUNMSlJZU0ZNQU1DS0pSWUFNMkJMQzhjV0FUcVJUTUFUQ0ZyQ0JBVENGWmw5ekFRSkhRUlRNR1hHWEFtQ2I2UUJBWVJQU0ZNQVkxQkJITUNnRlpST0dYR1hBTUNhOU1RQkFZQ0ZKUlBTRk1BWTFCRkhNQ2dCWkNPV0FPQ2dCWnFST0dYQU1DYTlNUUJBWUNHSlJQU0ZNQVkxQkdITUNnQlpDZldBT3FST0dYQU1DYTlNUUJBWUNFSlJQU0ZNQVkxQkVITUNnQlpDZFdBT3FST0dYQU1DYTlNUUJBWUNJSlJQU0ZNQVlDTEpSUEFZMkJJQzhjV0FPcVJPTUFPQ0ZyQ0JBT0NGWmw5ekFRSkhRUk9NR1hHWEF0Q2I2UUJBUFJNU0ZNQVAxQkJITUNnRlpSYkdYR1hBTUNhOU1RQkFQQ0ZKUk1TRk1BUDFCRkhNQ2dCWkNPV0FiQ2dCWnFSYkdYQU1DYTlNUUJBUENHSlJNU0ZNQVAxQkdITUNnQlpDZldBYnFSYkdYQU1DYTlNUUJBUENFSlJNU0ZNQVAxQkVITUNnQlpDZFdBYnFSYkdYQU1DYTlNUUJBUENJSlJNU0ZNQVBDTEpSTUFQMkJJQzhjV0FicVJiTUFiQ0ZyQ0JBYkNGWmw5ekFRSkhRUmJNR1hHWEFHQ0c5SFFCQUJBVDg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVGpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFUakdJQUxBSUNHV0pBVGpHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDR0pDYlpDRVdKSE9BVGpHQkFPQWJqR0lBTEFJQW05RkFtQ2I2cUpISUNiWkNHV0pBYmpHQkFJQXQ5RkF0Q2I2cUpSSUFLQ0VKUktNQU5DRkpSTkFCQ0tKUkJBRUNTSlJFQUtDYlpSS0FJQ2JaUklBZkNFSkhmQUY5SlFCTU1DQkM5OUFNQWM2eVJLTUFMQ29GSjhrVVVVVUJBS00vdElGR2E4alVVVVVCQ1RsUkxDOStSS0dYQUZDTEpBSTlMUUJDYVJLQUUyQkJDLytGWkMvUUY5SFFCQUxoQjgzRU5BRUNGSlJLQUVBSUpDOThKUkVHWEFGOUZRQkdYQUdDRzZRQkVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFMQ05KQUlDRlpDR1dxSEdBSUNHckNCQUlDRnJDRlpsOXpBRzhvR0JKSElqR0JBQkFJakdCQUJDSUpSQkFGQ2FKSEZRQlNHTU1FWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BQkFJQ0dyQ0JBSUNGckNGWmw5ekFMQ05KQUlDRlpDR1dxSEk4b0dCSkhHODdGQkFJQUdqR0JBQkNHSlJCQUZDYUpIRlFCTU1DQkM5OUFLQUU2eVJLTUFLTS9kTEVLOTdGYUY5N0dYR1hBR0NJOUhRQkFGOUZRRkNCUkdFWEFCQUJEQkJCSEVDaUQrckZDaUQrc0ZELzZGSElBRUNORCtyRkNpRCtzRkQvNkZBSUQvZ0ZBRUNURCtyRkNpRCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhLQ0JEdEQrMkZIT0FJQ1VVVVU5NER0SE5EOU9EOVJEL2tGSEk5REJCLytoRFlBSUFJRC9tRkFLQUtEL21GQUxBT0FMQU5EOU9EOVJEL2tGSElBSUQvbUZEL2tGRC9rRkQvakZEL25GSExEL21GOURCQlg5TERZSE9EL2tGQ2dGRHREOU9BRUNVVVU5NER0RDlPRDlRQUlBTEQvbUZBT0Qva0ZDTkQrckZDVS8rRUR0RDlPRDlRQUtBTEQvbUZBT0Qva0ZDVEQrckZDVVUvOE9EdEQ5T0Q5UURNQkJBQkNUSlJCQUdDSUpIR0FGOUpRQlNHTU1BRjlGUUJDQlJHRVhBQkNUSkhWQVZEQkJCSEVDQkR0SE9DVVU5OEQ4Y0ZDVVU5OEQ4Y0VITkQ5T0FCREJCQkhLQUVEUUlMS09TUWZiUGRlbjhjOGQ4ZThmQ2dnRkR0RDlPRC82RkFLQUVEUUJGR0VOVmNNVHRtWWk4WnB5SEVDVEQrc0ZELzZGSElEL2dGQUVDVEQrckZDVEQrc0ZELzZGSExEL2dGRC9rRkQvbEZIRTlEQi8rZzZEWUFMQUVBT0QrMkZIT0FMQ1VVVVU5NER0SGNEOU9EOVJEL2tGSExBTEQvbUZBRUFFRC9tRkFJQU9BSUFjRDlPRDlSRC9rRkhFQUVEL21GRC9rRkQva0ZEL2pGRC9uRkhJRC9tRjlEQkJYOUxEWUhPRC9rRkNURCtyRkFMQUlEL21GQU9EL2tGQ2dnRUR0RDlPRDlRSExBRUFJRC9tRkFPRC9rRkNhRGJDQkRuR0NCRG5FQ0JEbktDQkRuT0NCRG5jQ0JEbk1DQkRuZkNCRG5iRDlPSEVEUU5WaThaY01weVNROGM4ZGZiOGU4ZkQ5UURNQkJBQkFLQU5EOU9BTEFFRFFCRlR0R0VtWUlMUGRLT2VuRDlRRE1CQkFCQ0FKUkJBR0NJSkhHQUY5SlFCTU1NL2hFSUdhRjk3RmFMOTc4alVVVVVCQ1RsUkVHWEFGOUZRQkNCUklFWEFFQUJEQkJCSExBQkNUSkhLREJCQkhPRFFJTEtPU1FmYlBkZW44YzhkOGU4ZkhOQ1REK3NGSFZDSUQrckZETUlCQUI5REJCVTgvRFk5RC96STgxOC9EWUFWQ0VEdEQ5UUQvNkZEL25GSFZBTEFPRFFCRkdFTlZjTVR0bVlpOFpweUhMQ1REK3JGQ1REK3NGRC82RkQvbUZIT0FPRC9tRkFWQUxDVEQrc0ZELzZGRC9tRkhjQWNEL21GQVZBTkNURCtyRkNURCtzRkQvNkZEL21GSE5BTkQvbUZEL2tGRC9rRkQvbEZDQkR0RCs0RkQvakY5REIvK2c2RFlIVkQvbUY5REJCWDlMRFlITEQva0ZDZ2dFRHRITUQ5T0FjQVZEL21GQUxEL2tGQ1REK3JGRDlRSGNBTkFWRC9tRkFMRC9rRkNURCtyRkFPQVZEL21GQUxEL2tGQU1EOU9EOVFIVkRRQkZUdEdFbVlJTFBkS09lbkhMRDhkQkFFREJJQkR5Qit0K0o4M0VCQUJDTkpBTEQ4ZEZBRURCSUJEeUYrdCtKODNFQkFLQWNBVkRRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFZEOGRCQUVEQklCRHlHK3QrSjgzRUJBQkNpSkFWRDhkRkFFREJJQkR5RSt0K0o4M0VCQUJDQUpSQkFJQ0lKSElBRjlKUUJNTU05akZGOTdHWEFHQ0dyQUY5c0hHOUZRQkNCUkZFWEFCQUJEQkJCSEVDTkQrckZDTkQrc0ZELzZGQUVDaUQrc0ZDbkQrckZDVVVVLzhFRHREK3VGRC9tRkRNQkJBQkNUSlJCQUZDSUpIRkFHOUpRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU1NTUZCQ1VOTUlUOXRCQlwiO1xuICBjb25zdCBkZXRlY3RvciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLFxuICAgIDk3LFxuICAgIDExNSxcbiAgICAxMDksXG4gICAgMSxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxLFxuICAgIDQsXG4gICAgMSxcbiAgICA5NixcbiAgICAwLFxuICAgIDAsXG4gICAgMyxcbiAgICAzLFxuICAgIDIsXG4gICAgMCxcbiAgICAwLFxuICAgIDUsXG4gICAgMyxcbiAgICAxLFxuICAgIDAsXG4gICAgMSxcbiAgICAxMixcbiAgICAxLFxuICAgIDAsXG4gICAgMTAsXG4gICAgMjIsXG4gICAgMixcbiAgICAxMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDI1MixcbiAgICAxMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMTEsXG4gICAgNyxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUzLFxuICAgIDE1LFxuICAgIDI2LFxuICAgIDExXG4gIF0pO1xuICBjb25zdCB3YXNtcGFjayA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAzMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDI1MyxcbiAgICAzLFxuICAgIDEsXG4gICAgMixcbiAgICAzNCxcbiAgICA0LFxuICAgIDEwNixcbiAgICA2LFxuICAgIDUsXG4gICAgMTEsXG4gICAgOCxcbiAgICA3LFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDMzLFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDEyOCxcbiAgICA5LFxuICAgIDExNixcbiAgICA2NCxcbiAgICAxOSxcbiAgICAxMTMsXG4gICAgMTI3LFxuICAgIDE1LFxuICAgIDEwLFxuICAgIDIxLFxuICAgIDIyLFxuICAgIDE0LFxuICAgIDI1NSxcbiAgICA2NixcbiAgICAyNCxcbiAgICA1NCxcbiAgICAxMzYsXG4gICAgMTA3LFxuICAgIDE4LFxuICAgIDIzLFxuICAgIDE5MixcbiAgICAyNixcbiAgICAxMTQsXG4gICAgMTE4LFxuICAgIDEzMixcbiAgICAxNyxcbiAgICA3NyxcbiAgICAxMDEsXG4gICAgMTMwLFxuICAgIDE0NCxcbiAgICAyNyxcbiAgICA4NyxcbiAgICAxMzEsXG4gICAgNDQsXG4gICAgNDUsXG4gICAgNzQsXG4gICAgMTU2LFxuICAgIDE1NCxcbiAgICA3MCxcbiAgICAxNjdcbiAgXSk7XG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VwcG9ydGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgbGV0IHdhc20gPSB3YXNtX2Jhc2U7XG4gIGlmIChXZWJBc3NlbWJseS52YWxpZGF0ZShkZXRlY3RvcikpIHtcbiAgICB3YXNtID0gd2FzbV9zaW1kO1xuICB9XG4gIGxldCBpbnN0YW5jZTtcbiAgY29uc3QgcHJvbWlzZSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHVucGFjayh3YXNtKSwge30pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIGluc3RhbmNlID0gcmVzdWx0Lmluc3RhbmNlO1xuICAgIGluc3RhbmNlLmV4cG9ydHMuX193YXNtX2NhbGxfY3RvcnMoKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVucGFjayhkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2ggPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICByZXN1bHRbaV0gPSBjaCA+IDk2ID8gY2ggLSA3MSA6IGNoID4gNjQgPyBjaCAtIDY1IDogY2ggPiA0NyA/IGNoICsgNCA6IGNoID4gNDYgPyA2MyA6IDYyO1xuICAgIH1cbiAgICBsZXQgd3JpdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0W3dyaXRlKytdID0gcmVzdWx0W2ldIDwgNjAgPyB3YXNtcGFja1tyZXN1bHRbaV1dIDogKHJlc3VsdFtpXSAtIDYwKSAqIDY0ICsgcmVzdWx0WysraV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuYnVmZmVyLnNsaWNlKDAsIHdyaXRlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoZnVuLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgIGNvbnN0IHNicmsgPSBpbnN0YW5jZS5leHBvcnRzLnNicms7XG4gICAgY29uc3QgY291bnQ0ID0gY291bnQgKyAzICYgfjM7XG4gICAgY29uc3QgdHAgPSBzYnJrKGNvdW50NCAqIHNpemUpO1xuICAgIGNvbnN0IHNwID0gc2Jyayhzb3VyY2UubGVuZ3RoKTtcbiAgICBjb25zdCBoZWFwID0gbmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICBoZWFwLnNldChzb3VyY2UsIHNwKTtcbiAgICBjb25zdCByZXMgPSBmdW4odHAsIGNvdW50LCBzaXplLCBzcCwgc291cmNlLmxlbmd0aCk7XG4gICAgaWYgKHJlcyA9PT0gMCAmJiBmaWx0ZXIpIHtcbiAgICAgIGZpbHRlcih0cCwgY291bnQ0LCBzaXplKTtcbiAgICB9XG4gICAgdGFyZ2V0LnNldChoZWFwLnN1YmFycmF5KHRwLCB0cCArIGNvdW50ICogc2l6ZSkpO1xuICAgIHNicmsodHAgLSBzYnJrKDApKTtcbiAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBidWZmZXIgZGF0YTogJHtyZXN9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbHRlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgMjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICAzOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgTk9ORTogXCJcIixcbiAgICBPQ1RBSEVEUkFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgUVVBVEVSTklPTjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICBFWFBPTkVOVElBTDogXCJtZXNob3B0X2RlY29kZUZpbHRlckV4cFwiXG4gIH07XG4gIGNvbnN0IGRlY29kZXJzID0ge1xuICAgIC8vIGxlZ2FjeSBpbmRleC1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIDA6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXJcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZVwiLFxuICAgIC8vIHN0cmluZy1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIEFUVFJJQlVURVM6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICBUUklBTkdMRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIElORElDRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCJcbiAgfTtcbiAgZ2VuZXJhdGVkID0ge1xuICAgIHJlYWR5OiBwcm9taXNlLFxuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBkZWNvZGVWZXJ0ZXhCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBmaWx0ZXIpIHtcbiAgICAgIGRlY29kZShcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlcixcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpIHtcbiAgICAgIGRlY29kZShpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleFNlcXVlbmNlKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgZGVjb2RlR2x0ZkJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIG1vZGUsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2RlY29kZXJzW21vZGVdXSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZ2VuZXJhdGVkO1xufTtcbmV4cG9ydCB7XG4gIE1lc2hvcHREZWNvZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaG9wdERlY29kZXIuanMubWFwXG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVkIiwiTWVzaG9wdERlY29kZXIiLCJ3YXNtX2Jhc2UiLCJ3YXNtX3NpbWQiLCJkZXRlY3RvciIsIlVpbnQ4QXJyYXkiLCJ3YXNtcGFjayIsIldlYkFzc2VtYmx5Iiwic3VwcG9ydGVkIiwid2FzbSIsInZhbGlkYXRlIiwiaW5zdGFuY2UiLCJwcm9taXNlIiwiaW5zdGFudGlhdGUiLCJ1bnBhY2siLCJ0aGVuIiwicmVzdWx0IiwiZXhwb3J0cyIsIl9fd2FzbV9jYWxsX2N0b3JzIiwiZGF0YSIsImxlbmd0aCIsImkiLCJjaCIsImNoYXJDb2RlQXQiLCJ3cml0ZSIsImJ1ZmZlciIsInNsaWNlIiwiZGVjb2RlIiwiZnVuIiwidGFyZ2V0IiwiY291bnQiLCJzaXplIiwic291cmNlIiwiZmlsdGVyIiwic2JyayIsImNvdW50NCIsInRwIiwic3AiLCJoZWFwIiwibWVtb3J5Iiwic2V0IiwicmVzIiwic3ViYXJyYXkiLCJFcnJvciIsImZpbHRlcnMiLCJOT05FIiwiT0NUQUhFRFJBTCIsIlFVQVRFUk5JT04iLCJFWFBPTkVOVElBTCIsImRlY29kZXJzIiwiQVRUUklCVVRFUyIsIlRSSUFOR0xFUyIsIklORElDRVMiLCJyZWFkeSIsImRlY29kZVZlcnRleEJ1ZmZlciIsIm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyIiwiZGVjb2RlSW5kZXhCdWZmZXIiLCJtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyIiwiZGVjb2RlSW5kZXhTZXF1ZW5jZSIsIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZSIsImRlY29kZUdsdGZCdWZmZXIiLCJtb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            const taskConfig = {\n                attributeIDs: this.defaultAttributeIDs,\n                attributeTypes: this.defaultAttributeTypes,\n                useUniqueIDs: false\n            };\n            this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n        }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs\n        };\n        this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        for(const attribute in taskConfig.attributeTypes){\n            const type = taskConfig.attributeTypes[attribute];\n            if (type.BYTES_PER_ELEMENT !== void 0) {\n                taskConfig.attributeTypes[attribute] = type.name;\n            }\n        }\n        const taskKey = JSON.stringify(taskConfig);\n        if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer);\n            if (cachedTask.key === taskKey) {\n                return cachedTask.promise;\n            } else if (buffer.byteLength === 0) {\n                throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n            }\n        }\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve,\n                    reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig,\n                    buffer\n                }, [\n                    buffer\n                ]);\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) {\n                this._releaseTask(worker, taskID);\n            }\n        });\n        _taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        if (geometryData.index) {\n            geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n        }\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const attribute = geometryData.attributes[i];\n            const name = attribute.name;\n            const array = attribute.array;\n            const itemSize = attribute.itemSize;\n            geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n        }\n        return geometry;\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, void 0, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) {\n            librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        } else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) {\n                this.decoderConfig.wasmBinary = libraries[1];\n            }\n            const fn = DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker2 = new Worker(this.workerSourceURL);\n                worker2._callbacks = {};\n                worker2._taskCosts = {};\n                worker2._taskLoad = 0;\n                worker2.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker2.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker2._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker2._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker2);\n            } else {\n                this.workerPool.sort(function(a, b) {\n                    return a._taskLoad > b._taskLoad ? -1 : 1;\n                });\n            }\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i){\n            this.workerPool[i].terminate();\n        }\n        this.workerPool.length = 0;\n        return this;\n    }\n}\nfunction DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        resolve({\n                            draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig);\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    const decoderBuffer = new draco.DecoderBuffer();\n                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoderBuffer);\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n        } else {\n            throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        }\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n            throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        }\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n        }\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        }\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n //# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUUsTUFBTUksYUFBYSxhQUFhLEdBQUcsSUFBSUM7QUFDdkMsTUFBTUMsb0JBQW9CTix5Q0FBTUE7SUFDOUJPLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUN6QkMsVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztZQUMzQkosVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO0lBQ0Y7SUFDQUUsZUFBZUMsSUFBSSxFQUFFO1FBQ25CLElBQUksQ0FBQ2YsV0FBVyxHQUFHZTtRQUNuQixPQUFPLElBQUk7SUFDYjtJQUNBQyxpQkFBaUJDLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUNoQixhQUFhLEdBQUdnQjtRQUNyQixPQUFPLElBQUk7SUFDYjtJQUNBQyxlQUFlZCxXQUFXLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBQ0FlLEtBQUtDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxNQUFNQyxTQUFTLElBQUloQyw2Q0FBVUEsQ0FBQyxJQUFJLENBQUNPLE9BQU87UUFDMUN5QixPQUFPQyxPQUFPLENBQUMsSUFBSSxDQUFDVixJQUFJO1FBQ3hCUyxPQUFPRSxlQUFlLENBQUM7UUFDdkJGLE9BQU9HLGdCQUFnQixDQUFDLElBQUksQ0FBQ0MsYUFBYTtRQUMxQ0osT0FBT0ssa0JBQWtCLENBQUMsSUFBSSxDQUFDQyxlQUFlO1FBQzlDTixPQUFPTCxJQUFJLENBQ1RDLEtBQ0EsQ0FBQ1c7WUFDQyxNQUFNQyxhQUFhO2dCQUNqQkMsY0FBYyxJQUFJLENBQUN6QixtQkFBbUI7Z0JBQ3RDMEIsZ0JBQWdCLElBQUksQ0FBQ3JCLHFCQUFxQjtnQkFDMUNzQixjQUFjO1lBQ2hCO1lBQ0EsSUFBSSxDQUFDQyxjQUFjLENBQUNMLFFBQVFDLFlBQVlLLElBQUksQ0FBQ2hCLFFBQVFpQixLQUFLLENBQUNmO1FBQzdELEdBQ0FELFlBQ0FDO0lBRUo7SUFDQSxvRkFBb0YsR0FDcEZnQixnQkFBZ0JSLE1BQU0sRUFBRVMsUUFBUSxFQUFFUCxZQUFZLEVBQUVDLGNBQWMsRUFBRTtRQUM5RCxNQUFNRixhQUFhO1lBQ2pCQyxjQUFjQSxnQkFBZ0IsSUFBSSxDQUFDekIsbUJBQW1CO1lBQ3REMEIsZ0JBQWdCQSxrQkFBa0IsSUFBSSxDQUFDckIscUJBQXFCO1lBQzVEc0IsY0FBYyxDQUFDLENBQUNGO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDRyxjQUFjLENBQUNMLFFBQVFDLFlBQVlLLElBQUksQ0FBQ0c7SUFDL0M7SUFDQUosZUFBZUwsTUFBTSxFQUFFQyxVQUFVLEVBQUU7UUFDakMsSUFBSyxNQUFNUyxhQUFhVCxXQUFXRSxjQUFjLENBQUU7WUFDakQsTUFBTVEsT0FBT1YsV0FBV0UsY0FBYyxDQUFDTyxVQUFVO1lBQ2pELElBQUlDLEtBQUtDLGlCQUFpQixLQUFLLEtBQUssR0FBRztnQkFDckNYLFdBQVdFLGNBQWMsQ0FBQ08sVUFBVSxHQUFHQyxLQUFLRSxJQUFJO1lBQ2xEO1FBQ0Y7UUFDQSxNQUFNQyxVQUFVQyxLQUFLQyxTQUFTLENBQUNmO1FBQy9CLElBQUlyQyxXQUFXcUQsR0FBRyxDQUFDakIsU0FBUztZQUMxQixNQUFNa0IsYUFBYXRELFdBQVd1RCxHQUFHLENBQUNuQjtZQUNsQyxJQUFJa0IsV0FBV0UsR0FBRyxLQUFLTixTQUFTO2dCQUM5QixPQUFPSSxXQUFXRyxPQUFPO1lBQzNCLE9BQU8sSUFBSXJCLE9BQU9zQixVQUFVLEtBQUssR0FBRztnQkFDbEMsTUFBTSxJQUFJQyxNQUNSO1lBRUo7UUFDRjtRQUNBLElBQUlDO1FBQ0osTUFBTUMsU0FBUyxJQUFJLENBQUNsRCxnQkFBZ0I7UUFDcEMsTUFBTW1ELFdBQVcxQixPQUFPc0IsVUFBVTtRQUNsQyxNQUFNSyxrQkFBa0IsSUFBSSxDQUFDQyxVQUFVLENBQUNILFFBQVFDLFVBQVVwQixJQUFJLENBQUMsQ0FBQ3VCO1lBQzlETCxTQUFTSztZQUNULE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztnQkFDM0JSLE9BQU9TLFVBQVUsQ0FBQ1IsT0FBTyxHQUFHO29CQUFFTTtvQkFBU0M7Z0JBQU87Z0JBQzlDUixPQUFPVSxXQUFXLENBQUM7b0JBQUV2QixNQUFNO29CQUFVd0IsSUFBSVY7b0JBQVF4QjtvQkFBWUQ7Z0JBQU8sR0FBRztvQkFBQ0E7aUJBQU87WUFDakY7UUFDRixHQUFHTSxJQUFJLENBQUMsQ0FBQzhCLFVBQVksSUFBSSxDQUFDQyxlQUFlLENBQUNELFFBQVFFLFFBQVE7UUFDMURYLGdCQUFnQnBCLEtBQUssQ0FBQyxJQUFNLE1BQU1ELElBQUksQ0FBQztZQUNyQyxJQUFJa0IsVUFBVUMsUUFBUTtnQkFDcEIsSUFBSSxDQUFDYyxZQUFZLENBQUNmLFFBQVFDO1lBQzVCO1FBQ0Y7UUFDQTdELFdBQVc0RSxHQUFHLENBQUN4QyxRQUFRO1lBQ3JCb0IsS0FBS047WUFDTE8sU0FBU007UUFDWDtRQUNBLE9BQU9BO0lBQ1Q7SUFDQVUsZ0JBQWdCSSxZQUFZLEVBQUU7UUFDNUIsTUFBTUgsV0FBVyxJQUFJNUUsaURBQWNBO1FBQ25DLElBQUkrRSxhQUFhQyxLQUFLLEVBQUU7WUFDdEJKLFNBQVNLLFFBQVEsQ0FBQyxJQUFJaEYsa0RBQWVBLENBQUM4RSxhQUFhQyxLQUFLLENBQUNFLEtBQUssRUFBRTtRQUNsRTtRQUNBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixhQUFhSyxVQUFVLENBQUNDLE1BQU0sRUFBRUYsSUFBSztZQUN2RCxNQUFNbkMsWUFBWStCLGFBQWFLLFVBQVUsQ0FBQ0QsRUFBRTtZQUM1QyxNQUFNaEMsT0FBT0gsVUFBVUcsSUFBSTtZQUMzQixNQUFNK0IsUUFBUWxDLFVBQVVrQyxLQUFLO1lBQzdCLE1BQU1JLFdBQVd0QyxVQUFVc0MsUUFBUTtZQUNuQ1YsU0FBU1csWUFBWSxDQUFDcEMsTUFBTSxJQUFJbEQsa0RBQWVBLENBQUNpRixPQUFPSTtRQUN6RDtRQUNBLE9BQU9WO0lBQ1Q7SUFDQVksYUFBYTdELEdBQUcsRUFBRThELFlBQVksRUFBRTtRQUM5QixNQUFNMUQsU0FBUyxJQUFJaEMsNkNBQVVBLENBQUMsSUFBSSxDQUFDTyxPQUFPO1FBQzFDeUIsT0FBT0MsT0FBTyxDQUFDLElBQUksQ0FBQ3pCLFdBQVc7UUFDL0J3QixPQUFPRSxlQUFlLENBQUN3RDtRQUN2QjFELE9BQU9LLGtCQUFrQixDQUFDLElBQUksQ0FBQ0MsZUFBZTtRQUM5QyxPQUFPLElBQUkrQixRQUFRLENBQUNDLFNBQVNDO1lBQzNCdkMsT0FBT0wsSUFBSSxDQUFDQyxLQUFLMEMsU0FBUyxLQUFLLEdBQUdDO1FBQ3BDO0lBQ0Y7SUFDQW9CLFVBQVU7UUFDUixJQUFJLENBQUNDLFlBQVk7UUFDakIsT0FBTyxJQUFJO0lBQ2I7SUFDQUEsZUFBZTtRQUNiLElBQUksSUFBSSxDQUFDakYsY0FBYyxFQUNyQixPQUFPLElBQUksQ0FBQ0EsY0FBYztRQUM1QixNQUFNa0YsUUFBUSxPQUFPQyxnQkFBZ0IsWUFBWSxJQUFJLENBQUNyRixhQUFhLENBQUN5QyxJQUFJLEtBQUs7UUFDN0UsTUFBTTZDLG1CQUFtQixFQUFFO1FBQzNCLElBQUlGLE9BQU87WUFDVEUsaUJBQWlCQyxJQUFJLENBQUMsSUFBSSxDQUFDUCxZQUFZLENBQUMsb0JBQW9CO1FBQzlELE9BQU87WUFDTE0saUJBQWlCQyxJQUFJLENBQUMsSUFBSSxDQUFDUCxZQUFZLENBQUMseUJBQXlCO1lBQ2pFTSxpQkFBaUJDLElBQUksQ0FBQyxJQUFJLENBQUNQLFlBQVksQ0FBQyxzQkFBc0I7UUFDaEU7UUFDQSxJQUFJLENBQUM5RSxjQUFjLEdBQUcwRCxRQUFRNEIsR0FBRyxDQUFDRixrQkFBa0JsRCxJQUFJLENBQUMsQ0FBQ3FEO1lBQ3hELE1BQU1DLFlBQVlELFNBQVMsQ0FBQyxFQUFFO1lBQzlCLElBQUksQ0FBQ0wsT0FBTztnQkFDVixJQUFJLENBQUNwRixhQUFhLENBQUMyRixVQUFVLEdBQUdGLFNBQVMsQ0FBQyxFQUFFO1lBQzlDO1lBQ0EsTUFBTUcsS0FBS0MsWUFBWUMsUUFBUTtZQUMvQixNQUFNQyxPQUFPO2dCQUNYO2dCQUNBTDtnQkFDQTtnQkFDQTtnQkFDQUUsR0FBR0ksU0FBUyxDQUFDSixHQUFHSyxPQUFPLENBQUMsT0FBTyxHQUFHTCxHQUFHTSxXQUFXLENBQUM7YUFDbEQsQ0FBQ0MsSUFBSSxDQUFDO1lBQ1AsSUFBSSxDQUFDN0YsZUFBZSxHQUFHOEYsSUFBSUMsZUFBZSxDQUFDLElBQUlDLEtBQUs7Z0JBQUNQO2FBQUs7UUFDNUQ7UUFDQSxPQUFPLElBQUksQ0FBQzdGLGNBQWM7SUFDNUI7SUFDQXdELFdBQVdILE1BQU0sRUFBRUMsUUFBUSxFQUFFO1FBQzNCLE9BQU8sSUFBSSxDQUFDMkIsWUFBWSxHQUFHL0MsSUFBSSxDQUFDO1lBQzlCLElBQUksSUFBSSxDQUFDaEMsVUFBVSxDQUFDeUUsTUFBTSxHQUFHLElBQUksQ0FBQzFFLFdBQVcsRUFBRTtnQkFDN0MsTUFBTW9HLFVBQVUsSUFBSUMsT0FBTyxJQUFJLENBQUNsRyxlQUFlO2dCQUMvQ2lHLFFBQVF4QyxVQUFVLEdBQUcsQ0FBQztnQkFDdEJ3QyxRQUFRRSxVQUFVLEdBQUcsQ0FBQztnQkFDdEJGLFFBQVFHLFNBQVMsR0FBRztnQkFDcEJILFFBQVF2QyxXQUFXLENBQUM7b0JBQUV2QixNQUFNO29CQUFRekMsZUFBZSxJQUFJLENBQUNBLGFBQWE7Z0JBQUM7Z0JBQ3RFdUcsUUFBUUksU0FBUyxHQUFHLFNBQVNDLENBQUM7b0JBQzVCLE1BQU0xQyxVQUFVMEMsRUFBRUMsSUFBSTtvQkFDdEIsT0FBUTNDLFFBQVF6QixJQUFJO3dCQUNsQixLQUFLOzRCQUNIOEQsUUFBUXhDLFVBQVUsQ0FBQ0csUUFBUUQsRUFBRSxDQUFDLENBQUNKLE9BQU8sQ0FBQ0s7NEJBQ3ZDO3dCQUNGLEtBQUs7NEJBQ0hxQyxRQUFReEMsVUFBVSxDQUFDRyxRQUFRRCxFQUFFLENBQUMsQ0FBQ0gsTUFBTSxDQUFDSTs0QkFDdEM7d0JBQ0Y7NEJBQ0U0QyxRQUFRQyxLQUFLLENBQUMsNkNBQTZDN0MsUUFBUXpCLElBQUksR0FBRztvQkFDOUU7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDckMsVUFBVSxDQUFDbUYsSUFBSSxDQUFDZ0I7WUFDdkIsT0FBTztnQkFDTCxJQUFJLENBQUNuRyxVQUFVLENBQUM0RyxJQUFJLENBQUMsU0FBU0MsQ0FBQyxFQUFFQyxDQUFDO29CQUNoQyxPQUFPRCxFQUFFUCxTQUFTLEdBQUdRLEVBQUVSLFNBQVMsR0FBRyxDQUFDLElBQUk7Z0JBQzFDO1lBQ0Y7WUFDQSxNQUFNcEQsU0FBUyxJQUFJLENBQUNsRCxVQUFVLENBQUMsSUFBSSxDQUFDQSxVQUFVLENBQUN5RSxNQUFNLEdBQUcsRUFBRTtZQUMxRHZCLE9BQU9tRCxVQUFVLENBQUNsRCxPQUFPLEdBQUdDO1lBQzVCRixPQUFPb0QsU0FBUyxJQUFJbEQ7WUFDcEIsT0FBT0Y7UUFDVDtJQUNGO0lBQ0FlLGFBQWFmLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQzNCRCxPQUFPb0QsU0FBUyxJQUFJcEQsT0FBT21ELFVBQVUsQ0FBQ2xELE9BQU87UUFDN0MsT0FBT0QsT0FBT1MsVUFBVSxDQUFDUixPQUFPO1FBQ2hDLE9BQU9ELE9BQU9tRCxVQUFVLENBQUNsRCxPQUFPO0lBQ2xDO0lBQ0E0RCxRQUFRO1FBQ05MLFFBQVFNLEdBQUcsQ0FDVCxlQUNBLElBQUksQ0FBQ2hILFVBQVUsQ0FBQ2lILEdBQUcsQ0FBQyxDQUFDL0QsU0FBV0EsT0FBT29ELFNBQVM7SUFFcEQ7SUFDQVksVUFBVTtRQUNSLElBQUssSUFBSTNDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2RSxVQUFVLENBQUN5RSxNQUFNLEVBQUUsRUFBRUYsRUFBRztZQUMvQyxJQUFJLENBQUN2RSxVQUFVLENBQUN1RSxFQUFFLENBQUM0QyxTQUFTO1FBQzlCO1FBQ0EsSUFBSSxDQUFDbkgsVUFBVSxDQUFDeUUsTUFBTSxHQUFHO1FBQ3pCLE9BQU8sSUFBSTtJQUNiO0FBQ0Y7QUFDQSxTQUFTZ0I7SUFDUCxJQUFJN0Y7SUFDSixJQUFJRTtJQUNKeUcsWUFBWSxTQUFTQyxDQUFDO1FBQ3BCLE1BQU0xQyxVQUFVMEMsRUFBRUMsSUFBSTtRQUN0QixPQUFRM0MsUUFBUXpCLElBQUk7WUFDbEIsS0FBSztnQkFDSHpDLGdCQUFnQmtFLFFBQVFsRSxhQUFhO2dCQUNyQ0UsaUJBQWlCLElBQUkwRCxRQUFRLFNBQVNDLE9BQU87b0JBQzNDN0QsY0FBY3dILGNBQWMsR0FBRyxTQUFTQyxLQUFLO3dCQUMzQzVELFFBQVE7NEJBQUU0RDt3QkFBTTtvQkFDbEI7b0JBQ0FDLG1CQUFtQjFIO2dCQUNyQjtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsTUFBTThCLFNBQVNvQyxRQUFRcEMsTUFBTTtnQkFDN0IsTUFBTUMsYUFBYW1DLFFBQVFuQyxVQUFVO2dCQUNyQzdCLGVBQWVrQyxJQUFJLENBQUMsQ0FBQ3VGO29CQUNuQixNQUFNRixRQUFRRSxPQUFPRixLQUFLO29CQUMxQixNQUFNRyxVQUFVLElBQUlILE1BQU1JLE9BQU87b0JBQ2pDLE1BQU1DLGdCQUFnQixJQUFJTCxNQUFNTSxhQUFhO29CQUM3Q0QsY0FBY0UsSUFBSSxDQUFDLElBQUlDLFVBQVVuRyxTQUFTQSxPQUFPc0IsVUFBVTtvQkFDM0QsSUFBSTt3QkFDRixNQUFNZ0IsV0FBV2pDLGVBQWVzRixPQUFPRyxTQUFTRSxlQUFlL0Y7d0JBQy9ELE1BQU1tRyxVQUFVOUQsU0FBU1EsVUFBVSxDQUFDeUMsR0FBRyxDQUFDLENBQUNjLE9BQVNBLEtBQUt6RCxLQUFLLENBQUM1QyxNQUFNO3dCQUNuRSxJQUFJc0MsU0FBU0ksS0FBSyxFQUNoQjBELFFBQVEzQyxJQUFJLENBQUNuQixTQUFTSSxLQUFLLENBQUNFLEtBQUssQ0FBQzVDLE1BQU07d0JBQzFDc0csS0FBS3BFLFdBQVcsQ0FBQzs0QkFBRXZCLE1BQU07NEJBQVV3QixJQUFJQyxRQUFRRCxFQUFFOzRCQUFFRzt3QkFBUyxHQUFHOEQ7b0JBQ2pFLEVBQUUsT0FBT25CLE9BQU87d0JBQ2RELFFBQVFDLEtBQUssQ0FBQ0E7d0JBQ2RxQixLQUFLcEUsV0FBVyxDQUFDOzRCQUFFdkIsTUFBTTs0QkFBU3dCLElBQUlDLFFBQVFELEVBQUU7NEJBQUU4QyxPQUFPQSxNQUFNN0MsT0FBTzt3QkFBQztvQkFDekUsU0FBVTt3QkFDUnVELE1BQU1ZLE9BQU8sQ0FBQ1A7d0JBQ2RMLE1BQU1ZLE9BQU8sQ0FBQ1Q7b0JBQ2hCO2dCQUNGO2dCQUNBO1FBQ0o7SUFDRjtJQUNBLFNBQVN6RixlQUFlc0YsS0FBSyxFQUFFRyxPQUFPLEVBQUVFLGFBQWEsRUFBRS9GLFVBQVU7UUFDL0QsTUFBTUMsZUFBZUQsV0FBV0MsWUFBWTtRQUM1QyxNQUFNQyxpQkFBaUJGLFdBQVdFLGNBQWM7UUFDaEQsSUFBSXFHO1FBQ0osSUFBSUM7UUFDSixNQUFNQyxlQUFlWixRQUFRYSxzQkFBc0IsQ0FBQ1g7UUFDcEQsSUFBSVUsaUJBQWlCZixNQUFNaUIsZUFBZSxFQUFFO1lBQzFDSixnQkFBZ0IsSUFBSWIsTUFBTWtCLElBQUk7WUFDOUJKLGlCQUFpQlgsUUFBUWdCLGtCQUFrQixDQUFDZCxlQUFlUTtRQUM3RCxPQUFPLElBQUlFLGlCQUFpQmYsTUFBTW9CLFdBQVcsRUFBRTtZQUM3Q1AsZ0JBQWdCLElBQUliLE1BQU1xQixVQUFVO1lBQ3BDUCxpQkFBaUJYLFFBQVFtQix3QkFBd0IsQ0FBQ2pCLGVBQWVRO1FBQ25FLE9BQU87WUFDTCxNQUFNLElBQUlqRixNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxDQUFDa0YsZUFBZVMsRUFBRSxNQUFNVixjQUFjVyxHQUFHLEtBQUssR0FBRztZQUNuRCxNQUFNLElBQUk1RixNQUFNLHlDQUF5Q2tGLGVBQWVXLFNBQVM7UUFDbkY7UUFDQSxNQUFNOUUsV0FBVztZQUFFSSxPQUFPO1lBQU1JLFlBQVksRUFBRTtRQUFDO1FBQy9DLElBQUssTUFBTXVFLGlCQUFpQm5ILGFBQWM7WUFDeEMsTUFBTW9ILGdCQUFnQmhCLElBQUksQ0FBQ25HLGNBQWMsQ0FBQ2tILGNBQWMsQ0FBQztZQUN6RCxJQUFJM0c7WUFDSixJQUFJNkc7WUFDSixJQUFJdEgsV0FBV0csWUFBWSxFQUFFO2dCQUMzQm1ILGNBQWNySCxZQUFZLENBQUNtSCxjQUFjO2dCQUN6QzNHLFlBQVlvRixRQUFRMEIsc0JBQXNCLENBQUNoQixlQUFlZTtZQUM1RCxPQUFPO2dCQUNMQSxjQUFjekIsUUFBUTJCLGNBQWMsQ0FBQ2pCLGVBQWViLEtBQUssQ0FBQ3pGLFlBQVksQ0FBQ21ILGNBQWMsQ0FBQztnQkFDdEYsSUFBSUUsZ0JBQWdCLENBQUMsR0FDbkI7Z0JBQ0Y3RyxZQUFZb0YsUUFBUTRCLFlBQVksQ0FBQ2xCLGVBQWVlO1lBQ2xEO1lBQ0FqRixTQUFTUSxVQUFVLENBQUNXLElBQUksQ0FBQ2tFLGdCQUFnQmhDLE9BQU9HLFNBQVNVLGVBQWVhLGVBQWVDLGVBQWU1RztRQUN4RztRQUNBLElBQUlnRyxpQkFBaUJmLE1BQU1pQixlQUFlLEVBQUU7WUFDMUN0RSxTQUFTSSxLQUFLLEdBQUdrRixZQUFZakMsT0FBT0csU0FBU1U7UUFDL0M7UUFDQWIsTUFBTVksT0FBTyxDQUFDQztRQUNkLE9BQU9sRTtJQUNUO0lBQ0EsU0FBU3NGLFlBQVlqQyxLQUFLLEVBQUVHLE9BQU8sRUFBRVUsYUFBYTtRQUNoRCxNQUFNcUIsV0FBV3JCLGNBQWNzQixTQUFTO1FBQ3hDLE1BQU1DLGFBQWFGLFdBQVc7UUFDOUIsTUFBTXZHLGFBQWF5RyxhQUFhO1FBQ2hDLE1BQU1aLE1BQU14QixNQUFNcUMsT0FBTyxDQUFDMUc7UUFDMUJ3RSxRQUFRbUMsdUJBQXVCLENBQUN6QixlQUFlbEYsWUFBWTZGO1FBQzNELE1BQU16RSxRQUFRLElBQUl3RixZQUFZdkMsTUFBTXdDLE9BQU8sQ0FBQ25JLE1BQU0sRUFBRW1ILEtBQUtZLFlBQVlLLEtBQUs7UUFDMUV6QyxNQUFNMEMsS0FBSyxDQUFDbEI7UUFDWixPQUFPO1lBQUV2RSxPQUFPRjtZQUFPTSxVQUFVO1FBQUU7SUFDckM7SUFDQSxTQUFTMkUsZ0JBQWdCaEMsS0FBSyxFQUFFRyxPQUFPLEVBQUVVLGFBQWEsRUFBRWEsYUFBYSxFQUFFQyxhQUFhLEVBQUU1RyxTQUFTO1FBQzdGLE1BQU00SCxnQkFBZ0I1SCxVQUFVNkgsY0FBYztRQUM5QyxNQUFNQyxZQUFZaEMsY0FBY2lDLFVBQVU7UUFDMUMsTUFBTUMsWUFBWUYsWUFBWUY7UUFDOUIsTUFBTWhILGFBQWFvSCxZQUFZcEIsY0FBYzFHLGlCQUFpQjtRQUM5RCxNQUFNK0gsV0FBV0MsaUJBQWlCakQsT0FBTzJCO1FBQ3pDLE1BQU1ILE1BQU14QixNQUFNcUMsT0FBTyxDQUFDMUc7UUFDMUJ3RSxRQUFRK0MsaUNBQWlDLENBQUNyQyxlQUFlOUYsV0FBV2lJLFVBQVVySCxZQUFZNkY7UUFDMUYsTUFBTXZFLFFBQVEsSUFBSTBFLGNBQWMzQixNQUFNd0MsT0FBTyxDQUFDbkksTUFBTSxFQUFFbUgsS0FBS3VCLFdBQVdOLEtBQUs7UUFDM0V6QyxNQUFNMEMsS0FBSyxDQUFDbEI7UUFDWixPQUFPO1lBQ0x0RyxNQUFNd0c7WUFDTnpFO1lBQ0FJLFVBQVVzRjtRQUNaO0lBQ0Y7SUFDQSxTQUFTTSxpQkFBaUJqRCxLQUFLLEVBQUUyQixhQUFhO1FBQzVDLE9BQVFBO1lBQ04sS0FBS3dCO2dCQUNILE9BQU9uRCxNQUFNb0QsVUFBVTtZQUN6QixLQUFLNUM7Z0JBQ0gsT0FBT1IsTUFBTXFELE9BQU87WUFDdEIsS0FBS0M7Z0JBQ0gsT0FBT3RELE1BQU11RCxRQUFRO1lBQ3ZCLEtBQUtDO2dCQUNILE9BQU94RCxNQUFNeUQsUUFBUTtZQUN2QixLQUFLQztnQkFDSCxPQUFPMUQsTUFBTTJELFFBQVE7WUFDdkIsS0FBS0M7Z0JBQ0gsT0FBTzVELE1BQU02RCxTQUFTO1lBQ3hCLEtBQUt0QjtnQkFDSCxPQUFPdkMsTUFBTThELFNBQVM7UUFDMUI7SUFDRjtBQUNGO0FBR0UsQ0FDRix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8td2Vic2l0ZS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9EUkFDT0xvYWRlci5qcz83NGY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvYWRlciwgRmlsZUxvYWRlciwgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgX3Rhc2tDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY2xhc3MgRFJBQ09Mb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IFwiXCI7XG4gICAgdGhpcy5kZWNvZGVyQ29uZmlnID0ge307XG4gICAgdGhpcy5kZWNvZGVyQmluYXJ5ID0gbnVsbDtcbiAgICB0aGlzLmRlY29kZXJQZW5kaW5nID0gbnVsbDtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gNDtcbiAgICB0aGlzLndvcmtlclBvb2wgPSBbXTtcbiAgICB0aGlzLndvcmtlck5leHRUYXNrSUQgPSAxO1xuICAgIHRoaXMud29ya2VyU291cmNlVVJMID0gXCJcIjtcbiAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMgPSB7XG4gICAgICBwb3NpdGlvbjogXCJQT1NJVElPTlwiLFxuICAgICAgbm9ybWFsOiBcIk5PUk1BTFwiLFxuICAgICAgY29sb3I6IFwiQ09MT1JcIixcbiAgICAgIHV2OiBcIlRFWF9DT09SRFwiXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgbm9ybWFsOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgY29sb3I6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICB1djogXCJGbG9hdDMyQXJyYXlcIlxuICAgIH07XG4gIH1cbiAgc2V0RGVjb2RlclBhdGgocGF0aCkge1xuICAgIHRoaXMuZGVjb2RlclBhdGggPSBwYXRoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldERlY29kZXJDb25maWcoY29uZmlnKSB7XG4gICAgdGhpcy5kZWNvZGVyQ29uZmlnID0gY29uZmlnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFdvcmtlckxpbWl0KHdvcmtlckxpbWl0KSB7XG4gICAgdGhpcy53b3JrZXJMaW1pdCA9IHdvcmtlckxpbWl0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICAoYnVmZmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICAgICAgYXR0cmlidXRlSURzOiB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICAgICAgYXR0cmlidXRlVHlwZXM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzLFxuICAgICAgICAgIHVzZVVuaXF1ZUlEczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpLnRoZW4ob25Mb2FkKS5jYXRjaChvbkVycm9yKTtcbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25FcnJvclxuICAgICk7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIEtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyBEUkFDT0xvYWRlciB2ZXJzaW9ucy4gKi9cbiAgZGVjb2RlRHJhY29GaWxlKGJ1ZmZlciwgY2FsbGJhY2ssIGF0dHJpYnV0ZUlEcywgYXR0cmlidXRlVHlwZXMpIHtcbiAgICBjb25zdCB0YXNrQ29uZmlnID0ge1xuICAgICAgYXR0cmlidXRlSURzOiBhdHRyaWJ1dGVJRHMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzLFxuICAgICAgYXR0cmlidXRlVHlwZXM6IGF0dHJpYnV0ZVR5cGVzIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzLFxuICAgICAgdXNlVW5pcXVlSURzOiAhIWF0dHJpYnV0ZUlEc1xuICAgIH07XG4gICAgdGhpcy5kZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpLnRoZW4oY2FsbGJhY2spO1xuICB9XG4gIGRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykge1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZV07XG4gICAgICBpZiAodHlwZS5CWVRFU19QRVJfRUxFTUVOVCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXSA9IHR5cGUubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFza0tleSA9IEpTT04uc3RyaW5naWZ5KHRhc2tDb25maWcpO1xuICAgIGlmIChfdGFza0NhY2hlLmhhcyhidWZmZXIpKSB7XG4gICAgICBjb25zdCBjYWNoZWRUYXNrID0gX3Rhc2tDYWNoZS5nZXQoYnVmZmVyKTtcbiAgICAgIGlmIChjYWNoZWRUYXNrLmtleSA9PT0gdGFza0tleSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkVGFzay5wcm9taXNlO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5EUkFDT0xvYWRlcjogVW5hYmxlIHRvIHJlLWRlY29kZSBhIGJ1ZmZlciB3aXRoIGRpZmZlcmVudCBzZXR0aW5ncy4gQnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gdHJhbnNmZXJyZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdvcmtlcjtcbiAgICBjb25zdCB0YXNrSUQgPSB0aGlzLndvcmtlck5leHRUYXNrSUQrKztcbiAgICBjb25zdCB0YXNrQ29zdCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGdlb21ldHJ5UGVuZGluZyA9IHRoaXMuX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KS50aGVuKChfd29ya2VyKSA9PiB7XG4gICAgICB3b3JrZXIgPSBfd29ya2VyO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd29ya2VyLl9jYWxsYmFja3NbdGFza0lEXSA9IHsgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZGVjb2RlXCIsIGlkOiB0YXNrSUQsIHRhc2tDb25maWcsIGJ1ZmZlciB9LCBbYnVmZmVyXSk7XG4gICAgICB9KTtcbiAgICB9KS50aGVuKChtZXNzYWdlKSA9PiB0aGlzLl9jcmVhdGVHZW9tZXRyeShtZXNzYWdlLmdlb21ldHJ5KSk7XG4gICAgZ2VvbWV0cnlQZW5kaW5nLmNhdGNoKCgpID0+IHRydWUpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHdvcmtlciAmJiB0YXNrSUQpIHtcbiAgICAgICAgdGhpcy5fcmVsZWFzZVRhc2sod29ya2VyLCB0YXNrSUQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90YXNrQ2FjaGUuc2V0KGJ1ZmZlciwge1xuICAgICAga2V5OiB0YXNrS2V5LFxuICAgICAgcHJvbWlzZTogZ2VvbWV0cnlQZW5kaW5nXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5UGVuZGluZztcbiAgfVxuICBfY3JlYXRlR2VvbWV0cnkoZ2VvbWV0cnlEYXRhKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnlEYXRhLmluZGV4KSB7XG4gICAgICBnZW9tZXRyeS5zZXRJbmRleChuZXcgQnVmZmVyQXR0cmlidXRlKGdlb21ldHJ5RGF0YS5pbmRleC5hcnJheSwgMSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeURhdGEuYXR0cmlidXRlc1tpXTtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgIGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIF9sb2FkTGlicmFyeSh1cmwsIHJlc3BvbnNlVHlwZSkge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5kZWNvZGVyUGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShyZXNwb25zZVR5cGUpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsb2FkZXIubG9hZCh1cmwsIHJlc29sdmUsIHZvaWQgMCwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBwcmVsb2FkKCkge1xuICAgIHRoaXMuX2luaXREZWNvZGVyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2luaXREZWNvZGVyKCkge1xuICAgIGlmICh0aGlzLmRlY29kZXJQZW5kaW5nKVxuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gICAgY29uc3QgdXNlSlMgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIgfHwgdGhpcy5kZWNvZGVyQ29uZmlnLnR5cGUgPT09IFwianNcIjtcbiAgICBjb25zdCBsaWJyYXJpZXNQZW5kaW5nID0gW107XG4gICAgaWYgKHVzZUpTKSB7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX3dhc21fd3JhcHBlci5qc1wiLCBcInRleHRcIikpO1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fZGVjb2Rlci53YXNtXCIsIFwiYXJyYXlidWZmZXJcIikpO1xuICAgIH1cbiAgICB0aGlzLmRlY29kZXJQZW5kaW5nID0gUHJvbWlzZS5hbGwobGlicmFyaWVzUGVuZGluZykudGhlbigobGlicmFyaWVzKSA9PiB7XG4gICAgICBjb25zdCBqc0NvbnRlbnQgPSBsaWJyYXJpZXNbMF07XG4gICAgICBpZiAoIXVzZUpTKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlckNvbmZpZy53YXNtQmluYXJ5ID0gbGlicmFyaWVzWzFdO1xuICAgICAgfVxuICAgICAgY29uc3QgZm4gPSBEUkFDT1dvcmtlci50b1N0cmluZygpO1xuICAgICAgY29uc3QgYm9keSA9IFtcbiAgICAgICAgXCIvKiBkcmFjbyBkZWNvZGVyICovXCIsXG4gICAgICAgIGpzQ29udGVudCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCIvKiB3b3JrZXIgKi9cIixcbiAgICAgICAgZm4uc3Vic3RyaW5nKGZuLmluZGV4T2YoXCJ7XCIpICsgMSwgZm4ubGFzdEluZGV4T2YoXCJ9XCIpKVxuICAgICAgXS5qb2luKFwiXFxuXCIpO1xuICAgICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO1xuICB9XG4gIF9nZXRXb3JrZXIodGFza0lELCB0YXNrQ29zdCkge1xuICAgIHJldHVybiB0aGlzLl9pbml0RGVjb2RlcigpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud29ya2VyUG9vbC5sZW5ndGggPCB0aGlzLndvcmtlckxpbWl0KSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcjIgPSBuZXcgV29ya2VyKHRoaXMud29ya2VyU291cmNlVVJMKTtcbiAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tDb3N0cyA9IHt9O1xuICAgICAgICB3b3JrZXIyLl90YXNrTG9hZCA9IDA7XG4gICAgICAgIHdvcmtlcjIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImluaXRcIiwgZGVjb2RlckNvbmZpZzogdGhpcy5kZWNvZGVyQ29uZmlnIH0pO1xuICAgICAgICB3b3JrZXIyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVjb2RlXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3NbbWVzc2FnZS5pZF0ucmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIG1lc3NhZ2UsIFwiJyArIG1lc3NhZ2UudHlwZSArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53b3JrZXJQb29sLnB1c2god29ya2VyMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmtlclBvb2wuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuX3Rhc2tMb2FkID4gYi5fdGFza0xvYWQgPyAtMSA6IDE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJQb29sW3RoaXMud29ya2VyUG9vbC5sZW5ndGggLSAxXTtcbiAgICAgIHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF0gPSB0YXNrQ29zdDtcbiAgICAgIHdvcmtlci5fdGFza0xvYWQgKz0gdGFza0Nvc3Q7XG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0pO1xuICB9XG4gIF9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCkge1xuICAgIHdvcmtlci5fdGFza0xvYWQgLT0gd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXTtcbiAgICBkZWxldGUgd29ya2VyLl9jYWxsYmFja3NbdGFza0lEXTtcbiAgICBkZWxldGUgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXTtcbiAgfVxuICBkZWJ1ZygpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiVGFzayBsb2FkOiBcIixcbiAgICAgIHRoaXMud29ya2VyUG9vbC5tYXAoKHdvcmtlcikgPT4gd29ya2VyLl90YXNrTG9hZClcbiAgICApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndvcmtlclBvb2wubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMud29ya2VyUG9vbFtpXS50ZXJtaW5hdGUoKTtcbiAgICB9XG4gICAgdGhpcy53b3JrZXJQb29sLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIERSQUNPV29ya2VyKCkge1xuICBsZXQgZGVjb2RlckNvbmZpZztcbiAgbGV0IGRlY29kZXJQZW5kaW5nO1xuICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSBcImluaXRcIjpcbiAgICAgICAgZGVjb2RlckNvbmZpZyA9IG1lc3NhZ2UuZGVjb2RlckNvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgZGVjb2RlckNvbmZpZy5vbk1vZHVsZUxvYWRlZCA9IGZ1bmN0aW9uKGRyYWNvKSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgZHJhY28gfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBEcmFjb0RlY29kZXJNb2R1bGUoZGVjb2RlckNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbWVzc2FnZS5idWZmZXI7XG4gICAgICAgIGNvbnN0IHRhc2tDb25maWcgPSBtZXNzYWdlLnRhc2tDb25maWc7XG4gICAgICAgIGRlY29kZXJQZW5kaW5nLnRoZW4oKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRyYWNvID0gbW9kdWxlLmRyYWNvO1xuICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgZHJhY28uRGVjb2RlcigpO1xuICAgICAgICAgIGNvbnN0IGRlY29kZXJCdWZmZXIgPSBuZXcgZHJhY28uRGVjb2RlckJ1ZmZlcigpO1xuICAgICAgICAgIGRlY29kZXJCdWZmZXIuSW5pdChuZXcgSW50OEFycmF5KGJ1ZmZlciksIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBkZWNvZGVHZW9tZXRyeShkcmFjbywgZGVjb2RlciwgZGVjb2RlckJ1ZmZlciwgdGFza0NvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IGF0dHIuYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS5pbmRleClcbiAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKGdlb21ldHJ5LmluZGV4LmFycmF5LmJ1ZmZlcik7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IG1lc3NhZ2UuaWQsIGdlb21ldHJ5IH0sIGJ1ZmZlcnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImVycm9yXCIsIGlkOiBtZXNzYWdlLmlkLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyQnVmZmVyKTtcbiAgICAgICAgICAgIGRyYWNvLmRlc3Ryb3koZGVjb2Rlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkZWNvZGVHZW9tZXRyeShkcmFjbywgZGVjb2RlciwgZGVjb2RlckJ1ZmZlciwgdGFza0NvbmZpZykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZUlEcyA9IHRhc2tDb25maWcuYXR0cmlidXRlSURzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGVzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcztcbiAgICBsZXQgZHJhY29HZW9tZXRyeTtcbiAgICBsZXQgZGVjb2RpbmdTdGF0dXM7XG4gICAgY29uc3QgZ2VvbWV0cnlUeXBlID0gZGVjb2Rlci5HZXRFbmNvZGVkR2VvbWV0cnlUeXBlKGRlY29kZXJCdWZmZXIpO1xuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZHJhY29HZW9tZXRyeSA9IG5ldyBkcmFjby5NZXNoKCk7XG4gICAgICBkZWNvZGluZ1N0YXR1cyA9IGRlY29kZXIuRGVjb2RlQnVmZmVyVG9NZXNoKGRlY29kZXJCdWZmZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5QT0lOVF9DTE9VRCkge1xuICAgICAgZHJhY29HZW9tZXRyeSA9IG5ldyBkcmFjby5Qb2ludENsb3VkKCk7XG4gICAgICBkZWNvZGluZ1N0YXR1cyA9IGRlY29kZXIuRGVjb2RlQnVmZmVyVG9Qb2ludENsb3VkKGRlY29kZXJCdWZmZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBnZW9tZXRyeSB0eXBlLlwiKTtcbiAgICB9XG4gICAgaWYgKCFkZWNvZGluZ1N0YXR1cy5vaygpIHx8IGRyYWNvR2VvbWV0cnkucHRyID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5EUkFDT0xvYWRlcjogRGVjb2RpbmcgZmFpbGVkOiBcIiArIGRlY29kaW5nU3RhdHVzLmVycm9yX21zZygpKTtcbiAgICB9XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB7IGluZGV4OiBudWxsLCBhdHRyaWJ1dGVzOiBbXSB9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVJRHMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGUgPSBzZWxmW2F0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgIGxldCBhdHRyaWJ1dGU7XG4gICAgICBsZXQgYXR0cmlidXRlSUQ7XG4gICAgICBpZiAodGFza0NvbmZpZy51c2VVbmlxdWVJRHMpIHtcbiAgICAgICAgYXR0cmlidXRlSUQgPSBhdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGF0dHJpYnV0ZSA9IGRlY29kZXIuR2V0QXR0cmlidXRlQnlVbmlxdWVJZChkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVJRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGRlY29kZXIuR2V0QXR0cmlidXRlSWQoZHJhY29HZW9tZXRyeSwgZHJhY29bYXR0cmlidXRlSURzW2F0dHJpYnV0ZU5hbWVdXSk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVJRCA9PT0gLTEpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF0dHJpYnV0ZSA9IGRlY29kZXIuR2V0QXR0cmlidXRlKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucHVzaChkZWNvZGVBdHRyaWJ1dGUoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZSkpO1xuICAgIH1cbiAgICBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5UUklBTkdVTEFSX01FU0gpIHtcbiAgICAgIGdlb21ldHJ5LmluZGV4ID0gZGVjb2RlSW5kZXgoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgIH1cbiAgICBkcmFjby5kZXN0cm95KGRyYWNvR2VvbWV0cnkpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSkge1xuICAgIGNvbnN0IG51bUZhY2VzID0gZHJhY29HZW9tZXRyeS5udW1fZmFjZXMoKTtcbiAgICBjb25zdCBudW1JbmRpY2VzID0gbnVtRmFjZXMgKiAzO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBudW1JbmRpY2VzICogNDtcbiAgICBjb25zdCBwdHIgPSBkcmFjby5fbWFsbG9jKGJ5dGVMZW5ndGgpO1xuICAgIGRlY29kZXIuR2V0VHJpYW5nbGVzVUludDMyQXJyYXkoZHJhY29HZW9tZXRyeSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBpbmRleCA9IG5ldyBVaW50MzJBcnJheShkcmFjby5IRUFQRjMyLmJ1ZmZlciwgcHRyLCBudW1JbmRpY2VzKS5zbGljZSgpO1xuICAgIGRyYWNvLl9mcmVlKHB0cik7XG4gICAgcmV0dXJuIHsgYXJyYXk6IGluZGV4LCBpdGVtU2l6ZTogMSB9O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSB7XG4gICAgY29uc3QgbnVtQ29tcG9uZW50cyA9IGF0dHJpYnV0ZS5udW1fY29tcG9uZW50cygpO1xuICAgIGNvbnN0IG51bVBvaW50cyA9IGRyYWNvR2VvbWV0cnkubnVtX3BvaW50cygpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IG51bVBvaW50cyAqIG51bUNvbXBvbmVudHM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bVZhbHVlcyAqIGF0dHJpYnV0ZVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZXREcmFjb0RhdGFUeXBlKGRyYWNvLCBhdHRyaWJ1dGVUeXBlKTtcbiAgICBjb25zdCBwdHIgPSBkcmFjby5fbWFsbG9jKGJ5dGVMZW5ndGgpO1xuICAgIGRlY29kZXIuR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZSwgZGF0YVR5cGUsIGJ5dGVMZW5ndGgsIHB0cik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgYXR0cmlidXRlVHlwZShkcmFjby5IRUFQRjMyLmJ1ZmZlciwgcHRyLCBudW1WYWx1ZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogYXR0cmlidXRlTmFtZSxcbiAgICAgIGFycmF5LFxuICAgICAgaXRlbVNpemU6IG51bUNvbXBvbmVudHNcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpIHtcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfRkxPQVQzMjtcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UODtcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDE2O1xuICAgICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMzI7XG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UODtcbiAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMTY7XG4gICAgICBjYXNlIFVpbnQzMkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDMyO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IHtcbiAgRFJBQ09Mb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EUkFDT0xvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJMb2FkZXIiLCJGaWxlTG9hZGVyIiwiQnVmZmVyR2VvbWV0cnkiLCJCdWZmZXJBdHRyaWJ1dGUiLCJfdGFza0NhY2hlIiwiV2Vha01hcCIsIkRSQUNPTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwiZGVjb2RlclBhdGgiLCJkZWNvZGVyQ29uZmlnIiwiZGVjb2RlckJpbmFyeSIsImRlY29kZXJQZW5kaW5nIiwid29ya2VyTGltaXQiLCJ3b3JrZXJQb29sIiwid29ya2VyTmV4dFRhc2tJRCIsIndvcmtlclNvdXJjZVVSTCIsImRlZmF1bHRBdHRyaWJ1dGVJRHMiLCJwb3NpdGlvbiIsIm5vcm1hbCIsImNvbG9yIiwidXYiLCJkZWZhdWx0QXR0cmlidXRlVHlwZXMiLCJzZXREZWNvZGVyUGF0aCIsInBhdGgiLCJzZXREZWNvZGVyQ29uZmlnIiwiY29uZmlnIiwic2V0V29ya2VyTGltaXQiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJsb2FkZXIiLCJzZXRQYXRoIiwic2V0UmVzcG9uc2VUeXBlIiwic2V0UmVxdWVzdEhlYWRlciIsInJlcXVlc3RIZWFkZXIiLCJzZXRXaXRoQ3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJidWZmZXIiLCJ0YXNrQ29uZmlnIiwiYXR0cmlidXRlSURzIiwiYXR0cmlidXRlVHlwZXMiLCJ1c2VVbmlxdWVJRHMiLCJkZWNvZGVHZW9tZXRyeSIsInRoZW4iLCJjYXRjaCIsImRlY29kZURyYWNvRmlsZSIsImNhbGxiYWNrIiwiYXR0cmlidXRlIiwidHlwZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwibmFtZSIsInRhc2tLZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiaGFzIiwiY2FjaGVkVGFzayIsImdldCIsImtleSIsInByb21pc2UiLCJieXRlTGVuZ3RoIiwiRXJyb3IiLCJ3b3JrZXIiLCJ0YXNrSUQiLCJ0YXNrQ29zdCIsImdlb21ldHJ5UGVuZGluZyIsIl9nZXRXb3JrZXIiLCJfd29ya2VyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJfY2FsbGJhY2tzIiwicG9zdE1lc3NhZ2UiLCJpZCIsIm1lc3NhZ2UiLCJfY3JlYXRlR2VvbWV0cnkiLCJnZW9tZXRyeSIsIl9yZWxlYXNlVGFzayIsInNldCIsImdlb21ldHJ5RGF0YSIsImluZGV4Iiwic2V0SW5kZXgiLCJhcnJheSIsImkiLCJhdHRyaWJ1dGVzIiwibGVuZ3RoIiwiaXRlbVNpemUiLCJzZXRBdHRyaWJ1dGUiLCJfbG9hZExpYnJhcnkiLCJyZXNwb25zZVR5cGUiLCJwcmVsb2FkIiwiX2luaXREZWNvZGVyIiwidXNlSlMiLCJXZWJBc3NlbWJseSIsImxpYnJhcmllc1BlbmRpbmciLCJwdXNoIiwiYWxsIiwibGlicmFyaWVzIiwianNDb250ZW50Iiwid2FzbUJpbmFyeSIsImZuIiwiRFJBQ09Xb3JrZXIiLCJ0b1N0cmluZyIsImJvZHkiLCJzdWJzdHJpbmciLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJqb2luIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiQmxvYiIsIndvcmtlcjIiLCJXb3JrZXIiLCJfdGFza0Nvc3RzIiwiX3Rhc2tMb2FkIiwib25tZXNzYWdlIiwiZSIsImRhdGEiLCJjb25zb2xlIiwiZXJyb3IiLCJzb3J0IiwiYSIsImIiLCJkZWJ1ZyIsImxvZyIsIm1hcCIsImRpc3Bvc2UiLCJ0ZXJtaW5hdGUiLCJvbk1vZHVsZUxvYWRlZCIsImRyYWNvIiwiRHJhY29EZWNvZGVyTW9kdWxlIiwibW9kdWxlIiwiZGVjb2RlciIsIkRlY29kZXIiLCJkZWNvZGVyQnVmZmVyIiwiRGVjb2RlckJ1ZmZlciIsIkluaXQiLCJJbnQ4QXJyYXkiLCJidWZmZXJzIiwiYXR0ciIsInNlbGYiLCJkZXN0cm95IiwiZHJhY29HZW9tZXRyeSIsImRlY29kaW5nU3RhdHVzIiwiZ2VvbWV0cnlUeXBlIiwiR2V0RW5jb2RlZEdlb21ldHJ5VHlwZSIsIlRSSUFOR1VMQVJfTUVTSCIsIk1lc2giLCJEZWNvZGVCdWZmZXJUb01lc2giLCJQT0lOVF9DTE9VRCIsIlBvaW50Q2xvdWQiLCJEZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQiLCJvayIsInB0ciIsImVycm9yX21zZyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVUeXBlIiwiYXR0cmlidXRlSUQiLCJHZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkIiwiR2V0QXR0cmlidXRlSWQiLCJHZXRBdHRyaWJ1dGUiLCJkZWNvZGVBdHRyaWJ1dGUiLCJkZWNvZGVJbmRleCIsIm51bUZhY2VzIiwibnVtX2ZhY2VzIiwibnVtSW5kaWNlcyIsIl9tYWxsb2MiLCJHZXRUcmlhbmdsZXNVSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiSEVBUEYzMiIsInNsaWNlIiwiX2ZyZWUiLCJudW1Db21wb25lbnRzIiwibnVtX2NvbXBvbmVudHMiLCJudW1Qb2ludHMiLCJudW1fcG9pbnRzIiwibnVtVmFsdWVzIiwiZGF0YVR5cGUiLCJnZXREcmFjb0RhdGFUeXBlIiwiR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzIiwiRmxvYXQzMkFycmF5IiwiRFRfRkxPQVQzMiIsIkRUX0lOVDgiLCJJbnQxNkFycmF5IiwiRFRfSU5UMTYiLCJJbnQzMkFycmF5IiwiRFRfSU5UMzIiLCJVaW50OEFycmF5IiwiRFRfVUlOVDgiLCJVaW50MTZBcnJheSIsIkRUX1VJTlQxNiIsIkRUX1VJTlQzMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n/* harmony import */ var _polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/LoaderUtils.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\");\n\n\n\n\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.dracoLoader = null;\n        this.ktx2Loader = null;\n        this.meshoptDecoder = null;\n        this.pluginCallbacks = [];\n        this.register(function(parser) {\n            return new GLTFMaterialsClearcoatExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsDispersionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureBasisUExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureWebPExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureAVIFExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSheenExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsTransmissionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsVolumeExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIorExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsEmissiveStrengthExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSpecularExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIridescenceExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsAnisotropyExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsBumpExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFLightsExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshoptCompression(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshGpuInstancing(parser);\n        });\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        let resourcePath;\n        if (this.resourcePath !== \"\") {\n            resourcePath = this.resourcePath;\n        } else if (this.path !== \"\") {\n            const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);\n        } else {\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n        }\n        this.manager.itemStart(url);\n        const _onError = function(e) {\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(e);\n            }\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        };\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, function(data) {\n            try {\n                scope.parse(data, resourcePath, function(gltf) {\n                    onLoad(gltf);\n                    scope.manager.itemEnd(url);\n                }, _onError);\n            } catch (e) {\n                _onError(e);\n            }\n        }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n        this.dracoLoader = dracoLoader;\n        return this;\n    }\n    setDDSLoader() {\n        throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n        this.ktx2Loader = ktx2Loader;\n        return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n        this.meshoptDecoder = meshoptDecoder;\n        return this;\n    }\n    register(callback) {\n        if (this.pluginCallbacks.indexOf(callback) === -1) {\n            this.pluginCallbacks.push(callback);\n        }\n        return this;\n    }\n    unregister(callback) {\n        if (this.pluginCallbacks.indexOf(callback) !== -1) {\n            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n        }\n        return this;\n    }\n    parse(data, path, onLoad, onError) {\n        let json;\n        const extensions = {};\n        const plugins = {};\n        if (typeof data === \"string\") {\n            json = JSON.parse(data);\n        } else if (data instanceof ArrayBuffer) {\n            const magic = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4)));\n            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                try {\n                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                } catch (error) {\n                    if (onError) onError(error);\n                    return;\n                }\n                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n            } else {\n                json = JSON.parse((0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data)));\n            }\n        } else {\n            json = data;\n        }\n        if (json.asset === void 0 || json.asset.version[0] < 2) {\n            if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n            return;\n        }\n        const parser = new GLTFParser(json, {\n            path: path || this.resourcePath || \"\",\n            crossOrigin: this.crossOrigin,\n            requestHeader: this.requestHeader,\n            manager: this.manager,\n            ktx2Loader: this.ktx2Loader,\n            meshoptDecoder: this.meshoptDecoder\n        });\n        parser.fileLoader.setRequestHeader(this.requestHeader);\n        for(let i = 0; i < this.pluginCallbacks.length; i++){\n            const plugin = this.pluginCallbacks[i](parser);\n            if (!plugin.name) console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n            plugins[plugin.name] = plugin;\n            extensions[plugin.name] = true;\n        }\n        if (json.extensionsUsed) {\n            for(let i = 0; i < json.extensionsUsed.length; ++i){\n                const extensionName = json.extensionsUsed[i];\n                const extensionsRequired = json.extensionsRequired || [];\n                switch(extensionName){\n                    case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                        break;\n                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                        break;\n                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                        extensions[extensionName] = new GLTFTextureTransformExtension();\n                        break;\n                    case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                        extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                        break;\n                    default:\n                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n                            console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                        }\n                }\n            }\n        }\n        parser.setExtensions(extensions);\n        parser.setPlugins(plugins);\n        parser.parse(onLoad, onError);\n    }\n    parseAsync(data, path) {\n        const scope = this;\n        return new Promise(function(resolve, reject) {\n            scope.parse(data, path, resolve, reject);\n        });\n    }\n}\nfunction GLTFRegistry() {\n    let objects = {};\n    return {\n        get: function(key) {\n            return objects[key];\n        },\n        add: function(key, object) {\n            objects[key] = object;\n        },\n        remove: function(key) {\n            delete objects[key];\n        },\n        removeAll: function() {\n            objects = {};\n        }\n    };\n}\nconst EXTENSIONS = {\n    KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n    KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n    KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n    KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n    KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n    KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n    KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n    KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n    KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n    KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n    KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n    KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n    KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n    KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n    KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n    KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n    KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n    EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n    EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n    EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n    EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n    EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n        this.cache = {\n            refs: {},\n            uses: {}\n        };\n    }\n    _markDefs() {\n        const parser = this.parser;\n        const nodeDefs = this.parser.json.nodes || [];\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n            }\n        }\n    }\n    _loadLight(lightIndex) {\n        const parser = this.parser;\n        const cacheKey = \"light:\" + lightIndex;\n        let dependency = parser.cache.get(cacheKey);\n        if (dependency) return dependency;\n        const json = parser.json;\n        const extensions = json.extensions && json.extensions[this.name] || {};\n        const lightDefs = extensions.lights || [];\n        const lightDef = lightDefs[lightIndex];\n        let lightNode;\n        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n        const range = lightDef.range !== void 0 ? lightDef.range : 0;\n        switch(lightDef.type){\n            case \"directional\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case \"point\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case \"spot\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n                lightNode.distance = range;\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n        }\n        lightNode.position.set(0, 0, 0);\n        lightNode.decay = 2;\n        assignExtrasToUserData(lightNode, lightDef);\n        if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n        lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n        dependency = Promise.resolve(lightNode);\n        parser.cache.add(cacheKey, dependency);\n        return dependency;\n    }\n    getDependency(type, index) {\n        if (type !== \"light\") return;\n        return this._loadLight(index);\n    }\n    createNodeAttachment(nodeIndex) {\n        const self2 = this;\n        const parser = this.parser;\n        const json = parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n        const lightIndex = lightDef.light;\n        if (lightIndex === void 0) return null;\n        return this._loadLight(lightIndex).then(function(light) {\n            return parser._getNodeRef(self2.cache, lightIndex, light);\n        });\n    }\n}\nclass GLTFMaterialsUnlitExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n        const pending = [];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n        materialParams.opacity = 1;\n        const metallicRoughness = materialDef.pbrMetallicRoughness;\n        if (metallicRoughness) {\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n        if (emissiveStrength !== void 0) {\n            materialParams.emissiveIntensity = emissiveStrength;\n        }\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsClearcoatExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.clearcoatFactor !== void 0) {\n            materialParams.clearcoat = extension.clearcoatFactor;\n        }\n        if (extension.clearcoatTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n        }\n        if (extension.clearcoatRoughnessFactor !== void 0) {\n            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n        }\n        if (extension.clearcoatRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n        }\n        if (extension.clearcoatNormalTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n            if (extension.clearcoatNormalTexture.scale !== void 0) {\n                const scale = extension.clearcoatNormalTexture.scale;\n                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsDispersionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsIridescenceExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.iridescenceFactor !== void 0) {\n            materialParams.iridescence = extension.iridescenceFactor;\n        }\n        if (extension.iridescenceTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n        }\n        if (extension.iridescenceIor !== void 0) {\n            materialParams.iridescenceIOR = extension.iridescenceIor;\n        }\n        if (materialParams.iridescenceThicknessRange === void 0) {\n            materialParams.iridescenceThicknessRange = [\n                100,\n                400\n            ];\n        }\n        if (extension.iridescenceThicknessMinimum !== void 0) {\n            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n        }\n        if (extension.iridescenceThicknessMaximum !== void 0) {\n            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n        }\n        if (extension.iridescenceThicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsSheenExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n        materialParams.sheenRoughness = 0;\n        materialParams.sheen = 1;\n        const extension = materialDef.extensions[this.name];\n        if (extension.sheenColorFactor !== void 0) {\n            const colorFactor = extension.sheenColorFactor;\n            materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n        }\n        if (extension.sheenRoughnessFactor !== void 0) {\n            materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n        }\n        if (extension.sheenColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n        }\n        if (extension.sheenRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsTransmissionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.transmissionFactor !== void 0) {\n            materialParams.transmission = extension.transmissionFactor;\n        }\n        if (extension.transmissionTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsVolumeExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n        if (extension.thicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n        }\n        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n        const colorArray = extension.attenuationColor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIorExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsSpecularExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n        if (extension.specularTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n        }\n        const colorArray = extension.specularColorFactor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n        if (extension.specularColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsBumpExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n        if (extension.bumpTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsAnisotropyExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.anisotropyStrength !== void 0) {\n            materialParams.anisotropy = extension.anisotropyStrength;\n        }\n        if (extension.anisotropyRotation !== void 0) {\n            materialParams.anisotropyRotation = extension.anisotropyRotation;\n        }\n        if (extension.anisotropyTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFTextureBasisUExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n    loadTexture(textureIndex) {\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[this.name];\n        const loader = parser.options.ktx2Loader;\n        if (!loader) {\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n            } else {\n                return null;\n            }\n        }\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n    }\n}\nclass GLTFTextureWebPExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFTextureAVIFExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFMeshoptCompression {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n        this.parser = parser;\n    }\n    loadBufferView(index) {\n        const json = this.parser.json;\n        const bufferView = json.bufferViews[index];\n        if (bufferView.extensions && bufferView.extensions[this.name]) {\n            const extensionDef = bufferView.extensions[this.name];\n            const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n            const decoder = this.parser.options.meshoptDecoder;\n            if (!decoder || !decoder.supported) {\n                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                    throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n                } else {\n                    return null;\n                }\n            }\n            return buffer.then(function(res) {\n                const byteOffset = extensionDef.byteOffset || 0;\n                const byteLength = extensionDef.byteLength || 0;\n                const count = extensionDef.count;\n                const stride = extensionDef.byteStride;\n                const source = new Uint8Array(res, byteOffset, byteLength);\n                if (decoder.decodeGltfBufferAsync) {\n                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n                        return res2.buffer;\n                    });\n                } else {\n                    return decoder.ready.then(function() {\n                        const result = new ArrayBuffer(count * stride);\n                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n                        return result;\n                    });\n                }\n            });\n        } else {\n            return null;\n        }\n    }\n}\nclass GLTFMeshGpuInstancing {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n        this.parser = parser;\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n            return null;\n        }\n        const meshDef = json.meshes[nodeDef.mesh];\n        for (const primitive of meshDef.primitives){\n            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n                return null;\n            }\n        }\n        const extensionDef = nodeDef.extensions[this.name];\n        const attributesDef = extensionDef.attributes;\n        const pending = [];\n        const attributes = {};\n        for(const key in attributesDef){\n            pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor)=>{\n                attributes[key] = accessor;\n                return attributes[key];\n            }));\n        }\n        if (pending.length < 1) {\n            return null;\n        }\n        pending.push(this.parser.createNodeMesh(nodeIndex));\n        return Promise.all(pending).then((results)=>{\n            const nodeObject = results.pop();\n            const meshes = nodeObject.isGroup ? nodeObject.children : [\n                nodeObject\n            ];\n            const count = results[0].count;\n            const instancedMeshes = [];\n            for (const mesh of meshes){\n                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n                for(let i = 0; i < count; i++){\n                    if (attributes.TRANSLATION) {\n                        p.fromBufferAttribute(attributes.TRANSLATION, i);\n                    }\n                    if (attributes.ROTATION) {\n                        q.fromBufferAttribute(attributes.ROTATION, i);\n                    }\n                    if (attributes.SCALE) {\n                        s.fromBufferAttribute(attributes.SCALE, i);\n                    }\n                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n                }\n                for(const attributeName in attributes){\n                    if (attributeName === \"_COLOR_0\") {\n                        const attr = attributes[attributeName];\n                        instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n                    } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n                    }\n                }\n                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n                this.parser.assignFinalMaterial(instancedMesh);\n                instancedMeshes.push(instancedMesh);\n            }\n            if (nodeObject.isGroup) {\n                nodeObject.clear();\n                nodeObject.add(...instancedMeshes);\n                return nodeObject;\n            }\n            return instancedMeshes[0];\n        });\n    }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 1313821514,\n    BIN: 5130562\n};\nclass GLTFBinaryExtension {\n    constructor(data){\n        this.name = EXTENSIONS.KHR_BINARY_GLTF;\n        this.content = null;\n        this.body = null;\n        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n        this.header = {\n            magic: (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4))),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true)\n        };\n        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n            throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n        } else if (this.header.version < 2) {\n            throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n        }\n        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while(chunkIndex < chunkContentsLength){\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.content = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(contentArray);\n            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                this.body = data.slice(byteOffset, byteOffset + chunkLength);\n            }\n            chunkIndex += chunkLength;\n        }\n        if (this.content === null) {\n            throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n        }\n    }\n}\nclass GLTFDracoMeshCompressionExtension {\n    constructor(json, dracoLoader){\n        if (!dracoLoader) {\n            throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n        }\n        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n        this.json = json;\n        this.dracoLoader = dracoLoader;\n        this.dracoLoader.preload();\n    }\n    decodePrimitive(primitive, parser) {\n        const json = this.json;\n        const dracoLoader = this.dracoLoader;\n        const bufferViewIndex = primitive.extensions[this.name].bufferView;\n        const gltfAttributeMap = primitive.extensions[this.name].attributes;\n        const threeAttributeMap = {};\n        const attributeNormalizedMap = {};\n        const attributeTypeMap = {};\n        for(const attributeName in gltfAttributeMap){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n        }\n        for(const attributeName in primitive.attributes){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            if (gltfAttributeMap[attributeName] !== void 0) {\n                const accessorDef = json.accessors[primitive.attributes[attributeName]];\n                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                attributeTypeMap[threeAttributeName] = componentType.name;\n                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n            }\n        }\n        return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n            return new Promise(function(resolve, reject) {\n                dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n                    for(const attributeName in geometry.attributes){\n                        const attribute = geometry.attributes[attributeName];\n                        const normalized = attributeNormalizedMap[attributeName];\n                        if (normalized !== void 0) attribute.normalized = normalized;\n                    }\n                    resolve(geometry);\n                }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);\n            });\n        });\n    }\n}\nclass GLTFTextureTransformExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n    extendTexture(texture, transform) {\n        if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n            return texture;\n        }\n        texture = texture.clone();\n        if (transform.texCoord !== void 0) {\n            texture.channel = transform.texCoord;\n        }\n        if (transform.offset !== void 0) {\n            texture.offset.fromArray(transform.offset);\n        }\n        if (transform.rotation !== void 0) {\n            texture.rotation = transform.rotation;\n        }\n        if (transform.scale !== void 0) {\n            texture.repeat.fromArray(transform.scale);\n        }\n        texture.needsUpdate = true;\n        return texture;\n    }\n}\nclass GLTFMeshQuantizationExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){\n        super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n    copySampleValue_(index) {\n        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n        for(let i = 0; i !== valueSize; i++){\n            result[i] = values[offset + i];\n        }\n        return result;\n    }\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const stride2 = stride * 2;\n        const stride3 = stride * 3;\n        const td = t1 - t0;\n        const p = (t - t0) / td;\n        const pp = p * p;\n        const ppp = pp * p;\n        const offset1 = i1 * stride3;\n        const offset0 = offset1 - stride3;\n        const s2 = -2 * ppp + 3 * pp;\n        const s3 = ppp - pp;\n        const s0 = 1 - s2;\n        const s1 = s3 - pp + p;\n        for(let i = 0; i !== stride; i++){\n            const p0 = values[offset0 + i + stride];\n            const m0 = values[offset0 + i + stride2] * td;\n            const p1 = values[offset1 + i + stride];\n            const m1 = values[offset1 + i] * td;\n            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n        }\n        return result;\n    }\n}\nconst _q = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n        const result = super.interpolate_(i1, t0, t, t1);\n        _q.fromArray(result).normalize().toArray(result);\n        return result;\n    }\n}\nconst WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTES = {\n    POSITION: \"position\",\n    NORMAL: \"normal\",\n    TANGENT: \"tangent\",\n    // uv => uv1, 4 uv channels\n    // https://github.com/mrdoob/three.js/pull/25943\n    // https://github.com/mrdoob/three.js/pull/25788\n    ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 152 ? {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv1\",\n        TEXCOORD_2: \"uv2\",\n        TEXCOORD_3: \"uv3\"\n    } : {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv2\"\n    },\n    COLOR_0: \"color\",\n    WEIGHTS_0: \"skinWeight\",\n    JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n    scale: \"scale\",\n    translation: \"position\",\n    rotation: \"quaternion\",\n    weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n    CUBICSPLINE: void 0,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n    OPAQUE: \"OPAQUE\",\n    MASK: \"MASK\",\n    BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n    if (cache[\"DefaultMaterial\"] === void 0) {\n        cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 16777215,\n            emissive: 0,\n            metalness: 1,\n            roughness: 1,\n            transparent: false,\n            depthTest: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n        });\n    }\n    return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    for(const name in objectDef.extensions){\n        if (knownExtensions[name] === void 0) {\n            object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n            object.userData.gltfExtensions[name] = objectDef.extensions[name];\n        }\n    }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== void 0) {\n        if (typeof gltfDef.extras === \"object\") {\n            Object.assign(object.userData, gltfDef.extras);\n        } else {\n            console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n        }\n    }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    let hasMorphColor = false;\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (target.POSITION !== void 0) hasMorphPosition = true;\n        if (target.NORMAL !== void 0) hasMorphNormal = true;\n        if (target.COLOR_0 !== void 0) hasMorphColor = true;\n        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    const pendingColorAccessors = [];\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (hasMorphPosition) {\n            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n            pendingPositionAccessors.push(pendingAccessor);\n        }\n        if (hasMorphNormal) {\n            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n            pendingNormalAccessors.push(pendingAccessor);\n        }\n        if (hasMorphColor) {\n            const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n            pendingColorAccessors.push(pendingAccessor);\n        }\n    }\n    return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors),\n        Promise.all(pendingColorAccessors)\n    ]).then(function(accessors) {\n        const morphPositions = accessors[0];\n        const morphNormals = accessors[1];\n        const morphColors = accessors[2];\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n        if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n        geometry.morphTargetsRelative = true;\n        return geometry;\n    });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== void 0) {\n        for(let i = 0, il = meshDef.weights.length; i < il; i++){\n            mesh.morphTargetInfluences[i] = meshDef.weights[i];\n        }\n    }\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n        const targetNames = meshDef.extras.targetNames;\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n            mesh.morphTargetDictionary = {};\n            for(let i = 0, il = targetNames.length; i < il; i++){\n                mesh.morphTargetDictionary[targetNames[i]] = i;\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n        }\n    }\n}\nfunction createPrimitiveKey(primitiveDef) {\n    let geometryKey;\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    if (dracoExtension) {\n        geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n    } else {\n        geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n    }\n    if (primitiveDef.targets !== void 0) {\n        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){\n            geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n        }\n    }\n    return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n    let attributesKey = \"\";\n    const keys = Object.keys(attributes).sort();\n    for(let i = 0, il = keys.length; i < il; i++){\n        attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n    }\n    return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n    switch(constructor){\n        case Int8Array:\n            return 1 / 127;\n        case Uint8Array:\n            return 1 / 255;\n        case Int16Array:\n            return 1 / 32767;\n        case Uint16Array:\n            return 1 / 65535;\n        default:\n            throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n    }\n}\nfunction getImageURIMimeType(uri) {\n    if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n    if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n    return \"image/png\";\n}\nconst _identityMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n    constructor(json = {}, options = {}){\n        this.json = json;\n        this.extensions = {};\n        this.plugins = {};\n        this.options = options;\n        this.cache = new GLTFRegistry();\n        this.associations = /* @__PURE__ */ new Map();\n        this.primitiveCache = {};\n        this.nodeCache = {};\n        this.meshCache = {\n            refs: {},\n            uses: {}\n        };\n        this.cameraCache = {\n            refs: {},\n            uses: {}\n        };\n        this.lightCache = {\n            refs: {},\n            uses: {}\n        };\n        this.sourceCache = {};\n        this.textureCache = {};\n        this.nodeNamesUsed = {};\n        let isSafari = false;\n        let isFirefox = false;\n        let firefoxVersion = -1;\n        if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n            isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n        }\n        if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n        } else {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n        }\n        this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n        this.textureLoader.setRequestHeader(this.options.requestHeader);\n        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n        this.fileLoader.setResponseType(\"arraybuffer\");\n        if (this.options.crossOrigin === \"use-credentials\") {\n            this.fileLoader.setWithCredentials(true);\n        }\n    }\n    setExtensions(extensions) {\n        this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n        this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        this.cache.removeAll();\n        this.nodeCache = {};\n        this._invokeAll(function(ext) {\n            return ext._markDefs && ext._markDefs();\n        });\n        Promise.all(this._invokeAll(function(ext) {\n            return ext.beforeRoot && ext.beforeRoot();\n        })).then(function() {\n            return Promise.all([\n                parser.getDependencies(\"scene\"),\n                parser.getDependencies(\"animation\"),\n                parser.getDependencies(\"camera\")\n            ]);\n        }).then(function(dependencies) {\n            const result = {\n                scene: dependencies[0][json.scene || 0],\n                scenes: dependencies[0],\n                animations: dependencies[1],\n                cameras: dependencies[2],\n                asset: json.asset,\n                parser,\n                userData: {}\n            };\n            addUnknownExtensionsToUserData(extensions, result, json);\n            assignExtrasToUserData(result, json);\n            return Promise.all(parser._invokeAll(function(ext) {\n                return ext.afterRoot && ext.afterRoot(result);\n            })).then(function() {\n                for (const scene of result.scenes){\n                    scene.updateMatrixWorld();\n                }\n                onLoad(result);\n            });\n        }).catch(onError);\n    }\n    /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */ _markDefs() {\n        const nodeDefs = this.json.nodes || [];\n        const skinDefs = this.json.skins || [];\n        const meshDefs = this.json.meshes || [];\n        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){\n            const joints = skinDefs[skinIndex].joints;\n            for(let i = 0, il = joints.length; i < il; i++){\n                nodeDefs[joints[i]].isBone = true;\n            }\n        }\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.mesh !== void 0) {\n                this._addNodeRef(this.meshCache, nodeDef.mesh);\n                if (nodeDef.skin !== void 0) {\n                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                }\n            }\n            if (nodeDef.camera !== void 0) {\n                this._addNodeRef(this.cameraCache, nodeDef.camera);\n            }\n        }\n    }\n    /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */ _addNodeRef(cache, index) {\n        if (index === void 0) return;\n        if (cache.refs[index] === void 0) {\n            cache.refs[index] = cache.uses[index] = 0;\n        }\n        cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {\n        if (cache.refs[index] <= 1) return object;\n        const ref = object.clone();\n        const updateMappings = (original, clone)=>{\n            const mappings = this.associations.get(original);\n            if (mappings != null) {\n                this.associations.set(clone, mappings);\n            }\n            for (const [i, child] of original.children.entries()){\n                updateMappings(child, clone.children[i]);\n            }\n        };\n        updateMappings(object, ref);\n        ref.name += \"_instance_\" + cache.uses[index]++;\n        return ref;\n    }\n    _invokeOne(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.push(this);\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) return result;\n        }\n        return null;\n    }\n    _invokeAll(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.unshift(this);\n        const pending = [];\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) pending.push(result);\n        }\n        return pending;\n    }\n    /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */ getDependency(type, index) {\n        const cacheKey = type + \":\" + index;\n        let dependency = this.cache.get(cacheKey);\n        if (!dependency) {\n            switch(type){\n                case \"scene\":\n                    dependency = this.loadScene(index);\n                    break;\n                case \"node\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadNode && ext.loadNode(index);\n                    });\n                    break;\n                case \"mesh\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMesh && ext.loadMesh(index);\n                    });\n                    break;\n                case \"accessor\":\n                    dependency = this.loadAccessor(index);\n                    break;\n                case \"bufferView\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadBufferView && ext.loadBufferView(index);\n                    });\n                    break;\n                case \"buffer\":\n                    dependency = this.loadBuffer(index);\n                    break;\n                case \"material\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMaterial && ext.loadMaterial(index);\n                    });\n                    break;\n                case \"texture\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadTexture && ext.loadTexture(index);\n                    });\n                    break;\n                case \"skin\":\n                    dependency = this.loadSkin(index);\n                    break;\n                case \"animation\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadAnimation && ext.loadAnimation(index);\n                    });\n                    break;\n                case \"camera\":\n                    dependency = this.loadCamera(index);\n                    break;\n                default:\n                    dependency = this._invokeOne(function(ext) {\n                        return ext != this && ext.getDependency && ext.getDependency(type, index);\n                    });\n                    if (!dependency) {\n                        throw new Error(\"Unknown type: \" + type);\n                    }\n                    break;\n            }\n            this.cache.add(cacheKey, dependency);\n        }\n        return dependency;\n    }\n    /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */ getDependencies(type) {\n        let dependencies = this.cache.get(type);\n        if (!dependencies) {\n            const parser = this;\n            const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n            dependencies = Promise.all(defs.map(function(def, index) {\n                return parser.getDependency(type, index);\n            }));\n            this.cache.add(type, dependencies);\n        }\n        return dependencies;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBuffer(bufferIndex) {\n        const bufferDef = this.json.buffers[bufferIndex];\n        const loader = this.fileLoader;\n        if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n            throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n        }\n        if (bufferDef.uri === void 0 && bufferIndex === 0) {\n            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n        }\n        const options = this.options;\n        return new Promise(function(resolve, reject) {\n            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n                reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n            });\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBufferView(bufferViewIndex) {\n        const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n        return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n            const byteLength = bufferViewDef.byteLength || 0;\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */ loadAccessor(accessorIndex) {\n        const parser = this;\n        const json = this.json;\n        const accessorDef = this.json.accessors[accessorIndex];\n        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const normalized = accessorDef.normalized === true;\n            const array = new TypedArray(accessorDef.count * itemSize);\n            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n        }\n        const pendingBufferViews = [];\n        if (accessorDef.bufferView !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n        } else {\n            pendingBufferViews.push(null);\n        }\n        if (accessorDef.sparse !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n        }\n        return Promise.all(pendingBufferViews).then(function(bufferViews) {\n            const bufferView = bufferViews[0];\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n            const itemBytes = elementBytes * itemSize;\n            const byteOffset = accessorDef.byteOffset || 0;\n            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n            const normalized = accessorDef.normalized === true;\n            let array, bufferAttribute;\n            if (byteStride && byteStride !== itemBytes) {\n                const ibSlice = Math.floor(byteOffset / byteStride);\n                const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n                let ib = parser.cache.get(ibCacheKey);\n                if (!ib) {\n                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n                    parser.cache.add(ibCacheKey, ib);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n            } else {\n                if (bufferView === null) {\n                    array = new TypedArray(accessorDef.count * itemSize);\n                } else {\n                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n            }\n            if (accessorDef.sparse !== void 0) {\n                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                if (bufferView !== null) {\n                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                }\n                for(let i = 0, il = sparseIndices.length; i < il; i++){\n                    const index = sparseIndices[i];\n                    bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                    if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n                }\n            }\n            return bufferAttribute;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */ loadTexture(textureIndex) {\n        const json = this.json;\n        const options = this.options;\n        const textureDef = json.textures[textureIndex];\n        const sourceIndex = textureDef.source;\n        const sourceDef = json.images[sourceIndex];\n        let loader = this.textureLoader;\n        if (sourceDef.uri) {\n            const handler = options.manager.getHandler(sourceDef.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.loadTextureImage(textureIndex, sourceIndex, loader);\n    }\n    loadTextureImage(textureIndex, sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const textureDef = json.textures[textureIndex];\n        const sourceDef = json.images[sourceIndex];\n        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n        if (this.textureCache[cacheKey]) {\n            return this.textureCache[cacheKey];\n        }\n        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n            texture.flipY = false;\n            texture.name = textureDef.name || sourceDef.name || \"\";\n            if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n                texture.name = sourceDef.uri;\n            }\n            const samplers = json.samplers || {};\n            const sampler = samplers[textureDef.sampler] || {};\n            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            parser.associations.set(texture, {\n                textures: textureIndex\n            });\n            return texture;\n        }).catch(function() {\n            return null;\n        });\n        this.textureCache[cacheKey] = promise;\n        return promise;\n    }\n    loadImageSource(sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const options = this.options;\n        if (this.sourceCache[sourceIndex] !== void 0) {\n            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());\n        }\n        const sourceDef = json.images[sourceIndex];\n        const URL = self.URL || self.webkitURL;\n        let sourceURI = sourceDef.uri || \"\";\n        let isObjectURL = false;\n        if (sourceDef.bufferView !== void 0) {\n            sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n                isObjectURL = true;\n                const blob = new Blob([\n                    bufferView\n                ], {\n                    type: sourceDef.mimeType\n                });\n                sourceURI = URL.createObjectURL(blob);\n                return sourceURI;\n            });\n        } else if (sourceDef.uri === void 0) {\n            throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n        }\n        const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n            return new Promise(function(resolve, reject) {\n                let onLoad = resolve;\n                if (loader.isImageBitmapLoader === true) {\n                    onLoad = function(imageBitmap) {\n                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n                        texture.needsUpdate = true;\n                        resolve(texture);\n                    };\n                }\n                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n            });\n        }).then(function(texture) {\n            if (isObjectURL === true) {\n                URL.revokeObjectURL(sourceURI);\n            }\n            assignExtrasToUserData(texture, sourceDef);\n            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n            return texture;\n        }).catch(function(error) {\n            console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n            throw error;\n        });\n        this.sourceCache[sourceIndex] = promise;\n        return promise;\n    }\n    /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */ assignTexture(materialParams, mapName, mapDef, colorSpace) {\n        const parser = this;\n        return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n            if (!texture) return null;\n            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n                texture = texture.clone();\n                texture.channel = mapDef.texCoord;\n            }\n            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n                if (transform) {\n                    const gltfReference = parser.associations.get(texture);\n                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    parser.associations.set(texture, gltfReference);\n                }\n            }\n            if (colorSpace !== void 0) {\n                if (typeof colorSpace === \"number\") colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n                if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;\n                else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n            }\n            materialParams[mapName] = texture;\n            return texture;\n        });\n    }\n    /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */ assignFinalMaterial(mesh) {\n        const geometry = mesh.geometry;\n        let material = mesh.material;\n        const useDerivativeTangents = geometry.attributes.tangent === void 0;\n        const useVertexColors = geometry.attributes.color !== void 0;\n        const useFlatShading = geometry.attributes.normal === void 0;\n        if (mesh.isPoints) {\n            const cacheKey = \"PointsMaterial:\" + material.uuid;\n            let pointsMaterial = this.cache.get(cacheKey);\n            if (!pointsMaterial) {\n                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n                pointsMaterial.color.copy(material.color);\n                pointsMaterial.map = material.map;\n                pointsMaterial.sizeAttenuation = false;\n                this.cache.add(cacheKey, pointsMaterial);\n            }\n            material = pointsMaterial;\n        } else if (mesh.isLine) {\n            const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n            let lineMaterial = this.cache.get(cacheKey);\n            if (!lineMaterial) {\n                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n                lineMaterial.color.copy(material.color);\n                lineMaterial.map = material.map;\n                this.cache.add(cacheKey, lineMaterial);\n            }\n            material = lineMaterial;\n        }\n        if (useDerivativeTangents || useVertexColors || useFlatShading) {\n            let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n            if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n            if (useVertexColors) cacheKey += \"vertex-colors:\";\n            if (useFlatShading) cacheKey += \"flat-shading:\";\n            let cachedMaterial = this.cache.get(cacheKey);\n            if (!cachedMaterial) {\n                cachedMaterial = material.clone();\n                if (useVertexColors) cachedMaterial.vertexColors = true;\n                if (useFlatShading) cachedMaterial.flatShading = true;\n                if (useDerivativeTangents) {\n                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n                }\n                this.cache.add(cacheKey, cachedMaterial);\n                this.associations.set(cachedMaterial, this.associations.get(material));\n            }\n            material = cachedMaterial;\n        }\n        mesh.material = material;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */ loadMaterial(materialIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const materialDef = json.materials[materialIndex];\n        let materialType;\n        const materialParams = {};\n        const materialExtensions = materialDef.extensions || {};\n        const pending = [];\n        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n            materialType = kmuExtension.getMaterialType();\n            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n        } else {\n            const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            materialParams.opacity = 1;\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n            }\n            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n            if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n                pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n            }\n            materialType = this._invokeOne(function(ext) {\n                return ext.getMaterialType && ext.getMaterialType(materialIndex);\n            });\n            pending.push(Promise.all(this._invokeAll(function(ext) {\n                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n            })));\n        }\n        if (materialDef.doubleSided === true) {\n            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        }\n        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n        if (alphaMode === ALPHA_MODES.BLEND) {\n            materialParams.transparent = true;\n            materialParams.depthWrite = false;\n        } else {\n            materialParams.transparent = false;\n            if (alphaMode === ALPHA_MODES.MASK) {\n                materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n            }\n        }\n        if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n            if (materialDef.normalTexture.scale !== void 0) {\n                const scale = materialDef.normalTexture.scale;\n                materialParams.normalScale.set(scale, scale);\n            }\n        }\n        if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n            if (materialDef.occlusionTexture.strength !== void 0) {\n                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n            }\n        }\n        if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            const emissiveFactor = materialDef.emissiveFactor;\n            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);\n        }\n        if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n        }\n        return Promise.all(pending).then(function() {\n            const material = new materialType(materialParams);\n            if (materialDef.name) material.name = materialDef.name;\n            assignExtrasToUserData(material, materialDef);\n            parser.associations.set(material, {\n                materials: materialIndex\n            });\n            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n            return material;\n        });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {\n        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n        if (sanitizedName in this.nodeNamesUsed) {\n            return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n        } else {\n            this.nodeNamesUsed[sanitizedName] = 0;\n            return sanitizedName;\n        }\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */ loadGeometries(primitives) {\n        const parser = this;\n        const extensions = this.extensions;\n        const cache = this.primitiveCache;\n        function createDracoPrimitive(primitive) {\n            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n                return addPrimitiveAttributes(geometry, primitive, parser);\n            });\n        }\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const primitive = primitives[i];\n            const cacheKey = createPrimitiveKey(primitive);\n            const cached = cache[cacheKey];\n            if (cached) {\n                pending.push(cached.promise);\n            } else {\n                let geometryPromise;\n                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                    geometryPromise = createDracoPrimitive(primitive);\n                } else {\n                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n                }\n                cache[cacheKey] = {\n                    primitive,\n                    promise: geometryPromise\n                };\n                pending.push(geometryPromise);\n            }\n        }\n        return Promise.all(pending);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */ loadMesh(meshIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const meshDef = json.meshes[meshIndex];\n        const primitives = meshDef.primitives;\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n            pending.push(material);\n        }\n        pending.push(parser.loadGeometries(primitives));\n        return Promise.all(pending).then(function(results) {\n            const materials = results.slice(0, results.length - 1);\n            const geometries = results[results.length - 1];\n            const meshes = [];\n            for(let i = 0, il = geometries.length; i < il; i++){\n                const geometry = geometries[i];\n                const primitive = primitives[i];\n                let mesh;\n                const material = materials[i];\n                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n                    mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n                    if (mesh.isSkinnedMesh === true) {\n                        mesh.normalizeSkinWeights();\n                    }\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n                    }\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n                } else {\n                    throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n                }\n                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                    updateMorphTargets(mesh, meshDef);\n                }\n                mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n                assignExtrasToUserData(mesh, meshDef);\n                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n                parser.assignFinalMaterial(mesh);\n                meshes.push(mesh);\n            }\n            for(let i = 0, il = meshes.length; i < il; i++){\n                parser.associations.set(meshes[i], {\n                    meshes: meshIndex,\n                    primitives: i\n                });\n            }\n            if (meshes.length === 1) {\n                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n                return meshes[0];\n            }\n            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n            parser.associations.set(group, {\n                meshes: meshIndex\n            });\n            for(let i = 0, il = meshes.length; i < il; i++){\n                group.add(meshes[i]);\n            }\n            return group;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */ loadCamera(cameraIndex) {\n        let camera;\n        const cameraDef = this.json.cameras[cameraIndex];\n        const params = cameraDef[cameraDef.type];\n        if (!params) {\n            console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n            return;\n        }\n        if (cameraDef.type === \"perspective\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n        } else if (cameraDef.type === \"orthographic\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n        }\n        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n        assignExtrasToUserData(camera, cameraDef);\n        return Promise.resolve(camera);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */ loadSkin(skinIndex) {\n        const skinDef = this.json.skins[skinIndex];\n        const pending = [];\n        for(let i = 0, il = skinDef.joints.length; i < il; i++){\n            pending.push(this._loadNodeShallow(skinDef.joints[i]));\n        }\n        if (skinDef.inverseBindMatrices !== void 0) {\n            pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n        } else {\n            pending.push(null);\n        }\n        return Promise.all(pending).then(function(results) {\n            const inverseBindMatrices = results.pop();\n            const jointNodes = results;\n            const bones = [];\n            const boneInverses = [];\n            for(let i = 0, il = jointNodes.length; i < il; i++){\n                const jointNode = jointNodes[i];\n                if (jointNode) {\n                    bones.push(jointNode);\n                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                    if (inverseBindMatrices !== null) {\n                        mat.fromArray(inverseBindMatrices.array, i * 16);\n                    }\n                    boneInverses.push(mat);\n                } else {\n                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */ loadAnimation(animationIndex) {\n        const json = this.json;\n        const parser = this;\n        const animationDef = json.animations[animationIndex];\n        const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n        const pendingNodes = [];\n        const pendingInputAccessors = [];\n        const pendingOutputAccessors = [];\n        const pendingSamplers = [];\n        const pendingTargets = [];\n        for(let i = 0, il = animationDef.channels.length; i < il; i++){\n            const channel = animationDef.channels[i];\n            const sampler = animationDef.samplers[channel.sampler];\n            const target = channel.target;\n            const name = target.node;\n            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n            if (target.node === void 0) continue;\n            pendingNodes.push(this.getDependency(\"node\", name));\n            pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n            pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n            pendingSamplers.push(sampler);\n            pendingTargets.push(target);\n        }\n        return Promise.all([\n            Promise.all(pendingNodes),\n            Promise.all(pendingInputAccessors),\n            Promise.all(pendingOutputAccessors),\n            Promise.all(pendingSamplers),\n            Promise.all(pendingTargets)\n        ]).then(function(dependencies) {\n            const nodes = dependencies[0];\n            const inputAccessors = dependencies[1];\n            const outputAccessors = dependencies[2];\n            const samplers = dependencies[3];\n            const targets = dependencies[4];\n            const tracks = [];\n            for(let i = 0, il = nodes.length; i < il; i++){\n                const node = nodes[i];\n                const inputAccessor = inputAccessors[i];\n                const outputAccessor = outputAccessors[i];\n                const sampler = samplers[i];\n                const target = targets[i];\n                if (node === void 0) continue;\n                if (node.updateMatrix) {\n                    node.updateMatrix();\n                }\n                const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n                if (createdTracks) {\n                    for(let k = 0; k < createdTracks.length; k++){\n                        tracks.push(createdTracks[k]);\n                    }\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n        });\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        if (nodeDef.mesh === void 0) return null;\n        return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n            if (nodeDef.weights !== void 0) {\n                node.traverse(function(o) {\n                    if (!o.isMesh) return;\n                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){\n                        o.morphTargetInfluences[i] = nodeDef.weights[i];\n                    }\n                });\n            }\n            return node;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */ loadNode(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        const nodePending = parser._loadNodeShallow(nodeIndex);\n        const childPending = [];\n        const childrenDef = nodeDef.children || [];\n        for(let i = 0, il = childrenDef.length; i < il; i++){\n            childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n        }\n        const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n        return Promise.all([\n            nodePending,\n            Promise.all(childPending),\n            skeletonPending\n        ]).then(function(results) {\n            const node = results[0];\n            const children = results[1];\n            const skeleton = results[2];\n            if (skeleton !== null) {\n                node.traverse(function(mesh) {\n                    if (!mesh.isSkinnedMesh) return;\n                    mesh.bind(skeleton, _identityMatrix);\n                });\n            }\n            for(let i = 0, il = children.length; i < il; i++){\n                node.add(children[i]);\n            }\n            return node;\n        });\n    }\n    // ._loadNodeShallow() parses a single node.\n    // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n    _loadNodeShallow(nodeIndex) {\n        const json = this.json;\n        const extensions = this.extensions;\n        const parser = this;\n        if (this.nodeCache[nodeIndex] !== void 0) {\n            return this.nodeCache[nodeIndex];\n        }\n        const nodeDef = json.nodes[nodeIndex];\n        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n        const pending = [];\n        const meshPromise = parser._invokeOne(function(ext) {\n            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n            pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== void 0) {\n            pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n            }));\n        }\n        parser._invokeAll(function(ext) {\n            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function(promise) {\n            pending.push(promise);\n        });\n        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n            let node;\n            if (nodeDef.isBone === true) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n            } else if (objects.length > 1) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            } else if (objects.length === 1) {\n                node = objects[0];\n            } else {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            }\n            if (node !== objects[0]) {\n                for(let i = 0, il = objects.length; i < il; i++){\n                    node.add(objects[i]);\n                }\n            }\n            if (nodeDef.name) {\n                node.userData.name = nodeDef.name;\n                node.name = nodeName;\n            }\n            assignExtrasToUserData(node, nodeDef);\n            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n            if (nodeDef.matrix !== void 0) {\n                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                matrix.fromArray(nodeDef.matrix);\n                node.applyMatrix4(matrix);\n            } else {\n                if (nodeDef.translation !== void 0) {\n                    node.position.fromArray(nodeDef.translation);\n                }\n                if (nodeDef.rotation !== void 0) {\n                    node.quaternion.fromArray(nodeDef.rotation);\n                }\n                if (nodeDef.scale !== void 0) {\n                    node.scale.fromArray(nodeDef.scale);\n                }\n            }\n            if (!parser.associations.has(node)) {\n                parser.associations.set(node, {});\n            }\n            parser.associations.get(node).nodes = nodeIndex;\n            return node;\n        });\n        return this.nodeCache[nodeIndex];\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */ loadScene(sceneIndex) {\n        const extensions = this.extensions;\n        const sceneDef = this.json.scenes[sceneIndex];\n        const parser = this;\n        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n        assignExtrasToUserData(scene, sceneDef);\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n        const nodeIds = sceneDef.nodes || [];\n        const pending = [];\n        for(let i = 0, il = nodeIds.length; i < il; i++){\n            pending.push(parser.getDependency(\"node\", nodeIds[i]));\n        }\n        return Promise.all(pending).then(function(nodes) {\n            for(let i = 0, il = nodes.length; i < il; i++){\n                scene.add(nodes[i]);\n            }\n            const reduceAssociations = (node)=>{\n                const reducedAssociations = /* @__PURE__ */ new Map();\n                for (const [key, value] of parser.associations){\n                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n                        reducedAssociations.set(key, value);\n                    }\n                }\n                node.traverse((node2)=>{\n                    const mappings = parser.associations.get(node2);\n                    if (mappings != null) {\n                        reducedAssociations.set(node2, mappings);\n                    }\n                });\n                return reducedAssociations;\n            };\n            parser.associations = reduceAssociations(scene);\n            return scene;\n        });\n    }\n    _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n        const tracks = [];\n        const targetName = node.name ? node.name : node.uuid;\n        const targetNames = [];\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n            node.traverse(function(object) {\n                if (object.morphTargetInfluences) {\n                    targetNames.push(object.name ? object.name : object.uuid);\n                }\n            });\n        } else {\n            targetNames.push(targetName);\n        }\n        let TypedKeyframeTrack;\n        switch(PATH_PROPERTIES[target.path]){\n            case PATH_PROPERTIES.weights:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                break;\n            case PATH_PROPERTIES.rotation:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n                break;\n            case PATH_PROPERTIES.position:\n            case PATH_PROPERTIES.scale:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                break;\n            default:\n                switch(outputAccessor.itemSize){\n                    case 1:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                        break;\n                    case 2:\n                    case 3:\n                    default:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                        break;\n                }\n                break;\n        }\n        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n        const outputArray = this._getArrayFromAccessor(outputAccessor);\n        for(let j = 0, jl = targetNames.length; j < jl; j++){\n            const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n            if (sampler.interpolation === \"CUBICSPLINE\") {\n                this._createCubicSplineTrackInterpolant(track);\n            }\n            tracks.push(track);\n        }\n        return tracks;\n    }\n    _getArrayFromAccessor(accessor) {\n        let outputArray = accessor.array;\n        if (accessor.normalized) {\n            const scale = getNormalizedComponentScale(outputArray.constructor);\n            const scaled = new Float32Array(outputArray.length);\n            for(let j = 0, jl = outputArray.length; j < jl; j++){\n                scaled[j] = outputArray[j] * scale;\n            }\n            outputArray = scaled;\n        }\n        return outputArray;\n    }\n    _createCubicSplineTrackInterpolant(track) {\n        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n            const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n        };\n        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n    }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    if (attributes.POSITION !== void 0) {\n        const accessor = parser.json.accessors[attributes.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n            if (accessor.normalized) {\n                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                box.min.multiplyScalar(boxScale);\n                box.max.multiplyScalar(boxScale);\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n            return;\n        }\n    } else {\n        return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== void 0) {\n        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        for(let i = 0, il = targets.length; i < il; i++){\n            const target = targets[i];\n            if (target.POSITION !== void 0) {\n                const accessor = parser.json.accessors[target.POSITION];\n                const min = accessor.min;\n                const max = accessor.max;\n                if (min !== void 0 && max !== void 0) {\n                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                    if (accessor.normalized) {\n                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                        vector.multiplyScalar(boxScale);\n                    }\n                    maxDisplacement.max(vector);\n                } else {\n                    console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n                }\n            }\n        }\n        box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n        return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n            geometry.setAttribute(attributeName, accessor);\n        });\n    }\n    for(const gltfAttributeName in attributes){\n        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n        if (threeAttributeName in geometry.attributes) continue;\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== void 0 && !geometry.index) {\n        const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n            geometry.setIndex(accessor2);\n        });\n        pending.push(accessor);\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function() {\n        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n}\n //# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwOUI7QUFDcDVCO0FBQ2xCO0FBQ0s7QUFDekQsTUFBTWlFLGlCQUFpQjtBQUN2QixNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsbUJBQW1CckUseUNBQU1BO0lBQzdCc0UsWUFBWUMsT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJQyxnQ0FBZ0NEO1FBQzdDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlFLGlDQUFpQ0Y7UUFDOUM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUcsMkJBQTJCSDtRQUN4QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJSSx5QkFBeUJKO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlLLHlCQUF5Qkw7UUFDdEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSU0sNEJBQTRCTjtRQUN6QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJTyxtQ0FBbUNQO1FBQ2hEO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlRLDZCQUE2QlI7UUFDMUM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSVMsMEJBQTBCVDtRQUN2QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJVSx1Q0FBdUNWO1FBQ3BEO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlXLCtCQUErQlg7UUFDNUM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSVksa0NBQWtDWjtRQUMvQztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJYSxpQ0FBaUNiO1FBQzlDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUljLDJCQUEyQmQ7UUFDeEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSWUsb0JBQW9CZjtRQUNqQztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJZ0IsdUJBQXVCaEI7UUFDcEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSWlCLHNCQUFzQmpCO1FBQ25DO0lBQ0Y7SUFDQWtCLEtBQUtDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxNQUFNQyxRQUFRLElBQUk7UUFDbEIsSUFBSUM7UUFDSixJQUFJLElBQUksQ0FBQ0EsWUFBWSxLQUFLLElBQUk7WUFDNUJBLGVBQWUsSUFBSSxDQUFDQSxZQUFZO1FBQ2xDLE9BQU8sSUFBSSxJQUFJLENBQUNDLElBQUksS0FBSyxJQUFJO1lBQzNCLE1BQU1DLGNBQWN0Ryw4Q0FBV0EsQ0FBQ3VHLGNBQWMsQ0FBQ1I7WUFDL0NLLGVBQWVwRyw4Q0FBV0EsQ0FBQ3dHLFVBQVUsQ0FBQ0YsYUFBYSxJQUFJLENBQUNELElBQUk7UUFDOUQsT0FBTztZQUNMRCxlQUFlcEcsOENBQVdBLENBQUN1RyxjQUFjLENBQUNSO1FBQzVDO1FBQ0EsSUFBSSxDQUFDekIsT0FBTyxDQUFDbUMsU0FBUyxDQUFDVjtRQUN2QixNQUFNVyxXQUFXLFNBQVNDLENBQUM7WUFDekIsSUFBSVQsU0FBUztnQkFDWEEsUUFBUVM7WUFDVixPQUFPO2dCQUNMQyxRQUFRQyxLQUFLLENBQUNGO1lBQ2hCO1lBQ0FSLE1BQU03QixPQUFPLENBQUN3QyxTQUFTLENBQUNmO1lBQ3hCSSxNQUFNN0IsT0FBTyxDQUFDeUMsT0FBTyxDQUFDaEI7UUFDeEI7UUFDQSxNQUFNaUIsU0FBUyxJQUFJL0csNkNBQVVBLENBQUMsSUFBSSxDQUFDcUUsT0FBTztRQUMxQzBDLE9BQU9DLE9BQU8sQ0FBQyxJQUFJLENBQUNaLElBQUk7UUFDeEJXLE9BQU9FLGVBQWUsQ0FBQztRQUN2QkYsT0FBT0csZ0JBQWdCLENBQUMsSUFBSSxDQUFDQyxhQUFhO1FBQzFDSixPQUFPSyxrQkFBa0IsQ0FBQyxJQUFJLENBQUNDLGVBQWU7UUFDOUNOLE9BQU9sQixJQUFJLENBQ1RDLEtBQ0EsU0FBU3dCLElBQUk7WUFDWCxJQUFJO2dCQUNGcEIsTUFBTXFCLEtBQUssQ0FDVEQsTUFDQW5CLGNBQ0EsU0FBU3FCLElBQUk7b0JBQ1h6QixPQUFPeUI7b0JBQ1B0QixNQUFNN0IsT0FBTyxDQUFDeUMsT0FBTyxDQUFDaEI7Z0JBQ3hCLEdBQ0FXO1lBRUosRUFBRSxPQUFPQyxHQUFHO2dCQUNWRCxTQUFTQztZQUNYO1FBQ0YsR0FDQVYsWUFDQVM7SUFFSjtJQUNBZ0IsZUFBZW5ELFdBQVcsRUFBRTtRQUMxQixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFDbkIsT0FBTyxJQUFJO0lBQ2I7SUFDQW9ELGVBQWU7UUFDYixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQUMsY0FBY3JELFVBQVUsRUFBRTtRQUN4QixJQUFJLENBQUNBLFVBQVUsR0FBR0E7UUFDbEIsT0FBTyxJQUFJO0lBQ2I7SUFDQXNELGtCQUFrQnJELGNBQWMsRUFBRTtRQUNoQyxJQUFJLENBQUNBLGNBQWMsR0FBR0E7UUFDdEIsT0FBTyxJQUFJO0lBQ2I7SUFDQUUsU0FBU29ELFFBQVEsRUFBRTtRQUNqQixJQUFJLElBQUksQ0FBQ3JELGVBQWUsQ0FBQ3NELE9BQU8sQ0FBQ0QsY0FBYyxDQUFDLEdBQUc7WUFDakQsSUFBSSxDQUFDckQsZUFBZSxDQUFDdUQsSUFBSSxDQUFDRjtRQUM1QjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FHLFdBQVdILFFBQVEsRUFBRTtRQUNuQixJQUFJLElBQUksQ0FBQ3JELGVBQWUsQ0FBQ3NELE9BQU8sQ0FBQ0QsY0FBYyxDQUFDLEdBQUc7WUFDakQsSUFBSSxDQUFDckQsZUFBZSxDQUFDeUQsTUFBTSxDQUFDLElBQUksQ0FBQ3pELGVBQWUsQ0FBQ3NELE9BQU8sQ0FBQ0QsV0FBVztRQUN0RTtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FQLE1BQU1ELElBQUksRUFBRWxCLElBQUksRUFBRUwsTUFBTSxFQUFFRSxPQUFPLEVBQUU7UUFDakMsSUFBSWtDO1FBQ0osTUFBTUMsYUFBYSxDQUFDO1FBQ3BCLE1BQU1DLFVBQVUsQ0FBQztRQUNqQixJQUFJLE9BQU9mLFNBQVMsVUFBVTtZQUM1QmEsT0FBT0csS0FBS2YsS0FBSyxDQUFDRDtRQUNwQixPQUFPLElBQUlBLGdCQUFnQmlCLGFBQWE7WUFDdEMsTUFBTUMsUUFBUTFFLG9FQUFVQSxDQUFDLElBQUkyRSxXQUFXbkIsS0FBS29CLEtBQUssQ0FBQyxHQUFHO1lBQ3RELElBQUlGLFVBQVVHLCtCQUErQjtnQkFDM0MsSUFBSTtvQkFDRlAsVUFBVSxDQUFDUSxXQUFXQyxlQUFlLENBQUMsR0FBRyxJQUFJQyxvQkFBb0J4QjtnQkFDbkUsRUFBRSxPQUFPVixPQUFPO29CQUNkLElBQUlYLFNBQ0ZBLFFBQVFXO29CQUNWO2dCQUNGO2dCQUNBdUIsT0FBT0csS0FBS2YsS0FBSyxDQUFDYSxVQUFVLENBQUNRLFdBQVdDLGVBQWUsQ0FBQyxDQUFDRSxPQUFPO1lBQ2xFLE9BQU87Z0JBQ0xaLE9BQU9HLEtBQUtmLEtBQUssQ0FBQ3pELG9FQUFVQSxDQUFDLElBQUkyRSxXQUFXbkI7WUFDOUM7UUFDRixPQUFPO1lBQ0xhLE9BQU9iO1FBQ1Q7UUFDQSxJQUFJYSxLQUFLYSxLQUFLLEtBQUssS0FBSyxLQUFLYixLQUFLYSxLQUFLLENBQUNuRixPQUFPLENBQUMsRUFBRSxHQUFHLEdBQUc7WUFDdEQsSUFBSW9DLFNBQ0ZBLFFBQVEsSUFBSTBCLE1BQU07WUFDcEI7UUFDRjtRQUNBLE1BQU1oRCxTQUFTLElBQUlzRSxXQUFXZCxNQUFNO1lBQ2xDL0IsTUFBTUEsUUFBUSxJQUFJLENBQUNELFlBQVksSUFBSTtZQUNuQytDLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQzdCL0IsZUFBZSxJQUFJLENBQUNBLGFBQWE7WUFDakM5QyxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQkUsWUFBWSxJQUFJLENBQUNBLFVBQVU7WUFDM0JDLGdCQUFnQixJQUFJLENBQUNBLGNBQWM7UUFDckM7UUFDQUcsT0FBT3dFLFVBQVUsQ0FBQ2pDLGdCQUFnQixDQUFDLElBQUksQ0FBQ0MsYUFBYTtRQUNyRCxJQUFLLElBQUlpQyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDM0UsZUFBZSxDQUFDNEUsTUFBTSxFQUFFRCxJQUFLO1lBQ3BELE1BQU1FLFNBQVMsSUFBSSxDQUFDN0UsZUFBZSxDQUFDMkUsRUFBRSxDQUFDekU7WUFDdkMsSUFBSSxDQUFDMkUsT0FBT0MsSUFBSSxFQUNkNUMsUUFBUUMsS0FBSyxDQUFDO1lBQ2hCeUIsT0FBTyxDQUFDaUIsT0FBT0MsSUFBSSxDQUFDLEdBQUdEO1lBQ3ZCbEIsVUFBVSxDQUFDa0IsT0FBT0MsSUFBSSxDQUFDLEdBQUc7UUFDNUI7UUFDQSxJQUFJcEIsS0FBS3FCLGNBQWMsRUFBRTtZQUN2QixJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSWpCLEtBQUtxQixjQUFjLENBQUNILE1BQU0sRUFBRSxFQUFFRCxFQUFHO2dCQUNuRCxNQUFNSyxnQkFBZ0J0QixLQUFLcUIsY0FBYyxDQUFDSixFQUFFO2dCQUM1QyxNQUFNTSxxQkFBcUJ2QixLQUFLdUIsa0JBQWtCLElBQUksRUFBRTtnQkFDeEQsT0FBUUQ7b0JBQ04sS0FBS2IsV0FBV2UsbUJBQW1CO3dCQUNqQ3ZCLFVBQVUsQ0FBQ3FCLGNBQWMsR0FBRyxJQUFJRzt3QkFDaEM7b0JBQ0YsS0FBS2hCLFdBQVdpQiwwQkFBMEI7d0JBQ3hDekIsVUFBVSxDQUFDcUIsY0FBYyxHQUFHLElBQUlLLGtDQUFrQzNCLE1BQU0sSUFBSSxDQUFDN0QsV0FBVzt3QkFDeEY7b0JBQ0YsS0FBS3NFLFdBQVdtQixxQkFBcUI7d0JBQ25DM0IsVUFBVSxDQUFDcUIsY0FBYyxHQUFHLElBQUlPO3dCQUNoQztvQkFDRixLQUFLcEIsV0FBV3FCLHFCQUFxQjt3QkFDbkM3QixVQUFVLENBQUNxQixjQUFjLEdBQUcsSUFBSVM7d0JBQ2hDO29CQUNGO3dCQUNFLElBQUlSLG1CQUFtQjNCLE9BQU8sQ0FBQzBCLGtCQUFrQixLQUFLcEIsT0FBTyxDQUFDb0IsY0FBYyxLQUFLLEtBQUssR0FBRzs0QkFDdkY5QyxRQUFRd0QsSUFBSSxDQUFDLDBDQUEwQ1YsZ0JBQWdCO3dCQUN6RTtnQkFDSjtZQUNGO1FBQ0Y7UUFDQTlFLE9BQU95RixhQUFhLENBQUNoQztRQUNyQnpELE9BQU8wRixVQUFVLENBQUNoQztRQUNsQjFELE9BQU80QyxLQUFLLENBQUN4QixRQUFRRTtJQUN2QjtJQUNBcUUsV0FBV2hELElBQUksRUFBRWxCLElBQUksRUFBRTtRQUNyQixNQUFNRixRQUFRLElBQUk7UUFDbEIsT0FBTyxJQUFJcUUsUUFBUSxTQUFTQyxPQUFPLEVBQUVDLE1BQU07WUFDekN2RSxNQUFNcUIsS0FBSyxDQUFDRCxNQUFNbEIsTUFBTW9FLFNBQVNDO1FBQ25DO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDO0lBQ1AsSUFBSUMsVUFBVSxDQUFDO0lBQ2YsT0FBTztRQUNMQyxLQUFLLFNBQVNDLEdBQUc7WUFDZixPQUFPRixPQUFPLENBQUNFLElBQUk7UUFDckI7UUFDQUMsS0FBSyxTQUFTRCxHQUFHLEVBQUVFLE1BQU07WUFDdkJKLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHRTtRQUNqQjtRQUNBQyxRQUFRLFNBQVNILEdBQUc7WUFDbEIsT0FBT0YsT0FBTyxDQUFDRSxJQUFJO1FBQ3JCO1FBQ0FJLFdBQVc7WUFDVE4sVUFBVSxDQUFDO1FBQ2I7SUFDRjtBQUNGO0FBQ0EsTUFBTS9CLGFBQWE7SUFDakJDLGlCQUFpQjtJQUNqQmdCLDRCQUE0QjtJQUM1QnFCLHFCQUFxQjtJQUNyQkMseUJBQXlCO0lBQ3pCQywwQkFBMEI7SUFDMUJDLG1CQUFtQjtJQUNuQkMscUJBQXFCO0lBQ3JCQyx3QkFBd0I7SUFDeEJDLDRCQUE0QjtJQUM1QkMsMkJBQTJCO0lBQzNCQywwQkFBMEI7SUFDMUIvQixxQkFBcUI7SUFDckJnQyxzQkFBc0I7SUFDdEJDLG9CQUFvQjtJQUNwQjdCLHVCQUF1QjtJQUN2QkUsdUJBQXVCO0lBQ3ZCNEIsaUNBQWlDO0lBQ2pDQyxvQkFBb0I7SUFDcEJDLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyx5QkFBeUI7SUFDekJDLHlCQUF5QjtBQUMzQjtBQUNBLE1BQU14RztJQUNKdEIsWUFBWU8sTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzRFLElBQUksR0FBR1gsV0FBV3NDLG1CQUFtQjtRQUMxQyxJQUFJLENBQUNpQixLQUFLLEdBQUc7WUFBRUMsTUFBTSxDQUFDO1lBQUdDLE1BQU0sQ0FBQztRQUFFO0lBQ3BDO0lBQ0FDLFlBQVk7UUFDVixNQUFNM0gsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTTRILFdBQVcsSUFBSSxDQUFDNUgsTUFBTSxDQUFDd0QsSUFBSSxDQUFDcUUsS0FBSyxJQUFJLEVBQUU7UUFDN0MsSUFBSyxJQUFJQyxZQUFZLEdBQUdDLGFBQWFILFNBQVNsRCxNQUFNLEVBQUVvRCxZQUFZQyxZQUFZRCxZQUFhO1lBQ3pGLE1BQU1FLFVBQVVKLFFBQVEsQ0FBQ0UsVUFBVTtZQUNuQyxJQUFJRSxRQUFRdkUsVUFBVSxJQUFJdUUsUUFBUXZFLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsSUFBSW9ELFFBQVF2RSxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLENBQUNxRCxLQUFLLEtBQUssS0FBSyxHQUFHO2dCQUN6R2pJLE9BQU9rSSxXQUFXLENBQUMsSUFBSSxDQUFDVixLQUFLLEVBQUVRLFFBQVF2RSxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLENBQUNxRCxLQUFLO1lBQ3BFO1FBQ0Y7SUFDRjtJQUNBRSxXQUFXQyxVQUFVLEVBQUU7UUFDckIsTUFBTXBJLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU1xSSxXQUFXLFdBQVdEO1FBQzVCLElBQUlFLGFBQWF0SSxPQUFPd0gsS0FBSyxDQUFDdkIsR0FBRyxDQUFDb0M7UUFDbEMsSUFBSUMsWUFDRixPQUFPQTtRQUNULE1BQU05RSxPQUFPeEQsT0FBT3dELElBQUk7UUFDeEIsTUFBTUMsYUFBYUQsS0FBS0MsVUFBVSxJQUFJRCxLQUFLQyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLElBQUksQ0FBQztRQUNyRSxNQUFNMkQsWUFBWTlFLFdBQVcrRSxNQUFNLElBQUksRUFBRTtRQUN6QyxNQUFNQyxXQUFXRixTQUFTLENBQUNILFdBQVc7UUFDdEMsSUFBSU07UUFDSixNQUFNQyxRQUFRLElBQUlyTix3Q0FBS0EsQ0FBQztRQUN4QixJQUFJbU4sU0FBU0UsS0FBSyxLQUFLLEtBQUssR0FDMUJBLE1BQU1DLE1BQU0sQ0FBQ0gsU0FBU0UsS0FBSyxDQUFDLEVBQUUsRUFBRUYsU0FBU0UsS0FBSyxDQUFDLEVBQUUsRUFBRUYsU0FBU0UsS0FBSyxDQUFDLEVBQUUsRUFBRXRKO1FBQ3hFLE1BQU13SixRQUFRSixTQUFTSSxLQUFLLEtBQUssS0FBSyxJQUFJSixTQUFTSSxLQUFLLEdBQUc7UUFDM0QsT0FBUUosU0FBU0ssSUFBSTtZQUNuQixLQUFLO2dCQUNISixZQUFZLElBQUlqTixtREFBZ0JBLENBQUNrTjtnQkFDakNELFVBQVVLLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQ3JDUCxVQUFVdkMsR0FBRyxDQUFDdUMsVUFBVUssTUFBTTtnQkFDOUI7WUFDRixLQUFLO2dCQUNITCxZQUFZLElBQUlsTiw2Q0FBVUEsQ0FBQ21OO2dCQUMzQkQsVUFBVVEsUUFBUSxHQUFHTDtnQkFDckI7WUFDRixLQUFLO2dCQUNISCxZQUFZLElBQUluTiw0Q0FBU0EsQ0FBQ29OO2dCQUMxQkQsVUFBVVEsUUFBUSxHQUFHTDtnQkFDckJKLFNBQVNVLElBQUksR0FBR1YsU0FBU1UsSUFBSSxJQUFJLENBQUM7Z0JBQ2xDVixTQUFTVSxJQUFJLENBQUNDLGNBQWMsR0FBR1gsU0FBU1UsSUFBSSxDQUFDQyxjQUFjLEtBQUssS0FBSyxJQUFJWCxTQUFTVSxJQUFJLENBQUNDLGNBQWMsR0FBRztnQkFDeEdYLFNBQVNVLElBQUksQ0FBQ0UsY0FBYyxHQUFHWixTQUFTVSxJQUFJLENBQUNFLGNBQWMsS0FBSyxLQUFLLElBQUlaLFNBQVNVLElBQUksQ0FBQ0UsY0FBYyxHQUFHQyxLQUFLQyxFQUFFLEdBQUc7Z0JBQ2xIYixVQUFVYyxLQUFLLEdBQUdmLFNBQVNVLElBQUksQ0FBQ0UsY0FBYztnQkFDOUNYLFVBQVVlLFFBQVEsR0FBRyxJQUFJaEIsU0FBU1UsSUFBSSxDQUFDQyxjQUFjLEdBQUdYLFNBQVNVLElBQUksQ0FBQ0UsY0FBYztnQkFDcEZYLFVBQVVLLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQ3JDUCxVQUFVdkMsR0FBRyxDQUFDdUMsVUFBVUssTUFBTTtnQkFDOUI7WUFDRjtnQkFDRSxNQUFNLElBQUkvRixNQUFNLDhDQUE4Q3lGLFNBQVNLLElBQUk7UUFDL0U7UUFDQUosVUFBVU0sUUFBUSxDQUFDQyxHQUFHLENBQUMsR0FBRyxHQUFHO1FBQzdCUCxVQUFVZ0IsS0FBSyxHQUFHO1FBQ2xCQyx1QkFBdUJqQixXQUFXRDtRQUNsQyxJQUFJQSxTQUFTbUIsU0FBUyxLQUFLLEtBQUssR0FDOUJsQixVQUFVa0IsU0FBUyxHQUFHbkIsU0FBU21CLFNBQVM7UUFDMUNsQixVQUFVOUQsSUFBSSxHQUFHNUUsT0FBTzZKLGdCQUFnQixDQUFDcEIsU0FBUzdELElBQUksSUFBSSxXQUFXd0Q7UUFDckVFLGFBQWExQyxRQUFRQyxPQUFPLENBQUM2QztRQUM3QjFJLE9BQU93SCxLQUFLLENBQUNyQixHQUFHLENBQUNrQyxVQUFVQztRQUMzQixPQUFPQTtJQUNUO0lBQ0F3QixjQUFjaEIsSUFBSSxFQUFFaUIsS0FBSyxFQUFFO1FBQ3pCLElBQUlqQixTQUFTLFNBQ1g7UUFDRixPQUFPLElBQUksQ0FBQ1gsVUFBVSxDQUFDNEI7SUFDekI7SUFDQUMscUJBQXFCbEMsU0FBUyxFQUFFO1FBQzlCLE1BQU1tQyxRQUFRLElBQUk7UUFDbEIsTUFBTWpLLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU13RCxPQUFPeEQsT0FBT3dELElBQUk7UUFDeEIsTUFBTXdFLFVBQVV4RSxLQUFLcUUsS0FBSyxDQUFDQyxVQUFVO1FBQ3JDLE1BQU1XLFdBQVdULFFBQVF2RSxVQUFVLElBQUl1RSxRQUFRdkUsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDekUsTUFBTXdELGFBQWFLLFNBQVNSLEtBQUs7UUFDakMsSUFBSUcsZUFBZSxLQUFLLEdBQ3RCLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxZQUFZOEIsSUFBSSxDQUFDLFNBQVNqQyxLQUFLO1lBQ3BELE9BQU9qSSxPQUFPbUssV0FBVyxDQUFDRixNQUFNekMsS0FBSyxFQUFFWSxZQUFZSDtRQUNyRDtJQUNGO0FBQ0Y7QUFDQSxNQUFNaEQ7SUFDSnhGLGFBQWM7UUFDWixJQUFJLENBQUNtRixJQUFJLEdBQUdYLFdBQVdlLG1CQUFtQjtJQUM1QztJQUNBb0Ysa0JBQWtCO1FBQ2hCLE9BQU8xTyxvREFBaUJBO0lBQzFCO0lBQ0EyTyxhQUFhQyxjQUFjLEVBQUVDLFdBQVcsRUFBRXZLLE1BQU0sRUFBRTtRQUNoRCxNQUFNd0ssVUFBVSxFQUFFO1FBQ2xCRixlQUFlM0IsS0FBSyxHQUFHLElBQUlyTix3Q0FBS0EsQ0FBQyxHQUFHLEdBQUc7UUFDdkNnUCxlQUFlRyxPQUFPLEdBQUc7UUFDekIsTUFBTUMsb0JBQW9CSCxZQUFZSSxvQkFBb0I7UUFDMUQsSUFBSUQsbUJBQW1CO1lBQ3JCLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0gsa0JBQWtCSSxlQUFlLEdBQUc7Z0JBQ3BELE1BQU1DLFFBQVFMLGtCQUFrQkksZUFBZTtnQkFDL0NSLGVBQWUzQixLQUFLLENBQUNDLE1BQU0sQ0FBQ21DLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUUxTDtnQkFDMURpTCxlQUFlRyxPQUFPLEdBQUdNLEtBQUssQ0FBQyxFQUFFO1lBQ25DO1lBQ0EsSUFBSUwsa0JBQWtCTSxnQkFBZ0IsS0FBSyxLQUFLLEdBQUc7Z0JBQ2pEUixRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLE9BQU9JLGtCQUFrQk0sZ0JBQWdCLEVBQUU1TDtZQUMvRjtRQUNGO1FBQ0EsT0FBT3dHLFFBQVFzRixHQUFHLENBQUNWO0lBQ3JCO0FBQ0Y7QUFDQSxNQUFNOUo7SUFDSmpCLFlBQVlPLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUM0RSxJQUFJLEdBQUdYLFdBQVdpRCwrQkFBK0I7SUFDeEQ7SUFDQWlFLHFCQUFxQkMsYUFBYSxFQUFFZCxjQUFjLEVBQUU7UUFDbEQsTUFBTXRLLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQUU7WUFDakUsT0FBT2dCLFFBQVFDLE9BQU87UUFDeEI7UUFDQSxNQUFNeUYsbUJBQW1CZixZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxDQUFDMEcsZ0JBQWdCO1FBQzNFLElBQUlBLHFCQUFxQixLQUFLLEdBQUc7WUFDL0JoQixlQUFlaUIsaUJBQWlCLEdBQUdEO1FBQ3JDO1FBQ0EsT0FBTzFGLFFBQVFDLE9BQU87SUFDeEI7QUFDRjtBQUNBLE1BQU01RjtJQUNKUixZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXdUMsdUJBQXVCO0lBQ2hEO0lBQ0E0RCxnQkFBZ0JnQixhQUFhLEVBQUU7UUFDN0IsTUFBTXBMLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQy9ELE9BQU87UUFDVCxPQUFPakosdURBQW9CQTtJQUM3QjtJQUNBd1AscUJBQXFCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRTtRQUNsRCxNQUFNdEssU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTXVLLGNBQWN2SyxPQUFPd0QsSUFBSSxDQUFDNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ3hELElBQUksQ0FBQ2IsWUFBWTlHLFVBQVUsSUFBSSxDQUFDOEcsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFBRTtZQUNqRSxPQUFPZ0IsUUFBUUMsT0FBTztRQUN4QjtRQUNBLE1BQU0yRSxVQUFVLEVBQUU7UUFDbEIsTUFBTWdCLFlBQVlqQixZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQztRQUNuRCxJQUFJNEcsVUFBVUMsZUFBZSxLQUFLLEtBQUssR0FBRztZQUN4Q25CLGVBQWVvQixTQUFTLEdBQUdGLFVBQVVDLGVBQWU7UUFDdEQ7UUFDQSxJQUFJRCxVQUFVRyxnQkFBZ0IsS0FBSyxLQUFLLEdBQUc7WUFDekNuQixRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLGdCQUFnQmtCLFVBQVVHLGdCQUFnQjtRQUM5RjtRQUNBLElBQUlILFVBQVVJLHdCQUF3QixLQUFLLEtBQUssR0FBRztZQUNqRHRCLGVBQWV1QixrQkFBa0IsR0FBR0wsVUFBVUksd0JBQXdCO1FBQ3hFO1FBQ0EsSUFBSUosVUFBVU0seUJBQXlCLEtBQUssS0FBSyxHQUFHO1lBQ2xEdEIsUUFBUW5ILElBQUksQ0FBQ3JELE9BQU9pTCxhQUFhLENBQUNYLGdCQUFnQix5QkFBeUJrQixVQUFVTSx5QkFBeUI7UUFDaEg7UUFDQSxJQUFJTixVQUFVTyxzQkFBc0IsS0FBSyxLQUFLLEdBQUc7WUFDL0N2QixRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLHNCQUFzQmtCLFVBQVVPLHNCQUFzQjtZQUN4RyxJQUFJUCxVQUFVTyxzQkFBc0IsQ0FBQ0MsS0FBSyxLQUFLLEtBQUssR0FBRztnQkFDckQsTUFBTUEsUUFBUVIsVUFBVU8sc0JBQXNCLENBQUNDLEtBQUs7Z0JBQ3BEMUIsZUFBZTJCLG9CQUFvQixHQUFHLElBQUlyUSwwQ0FBT0EsQ0FBQ29RLE9BQU9BO1lBQzNEO1FBQ0Y7UUFDQSxPQUFPcEcsUUFBUXNGLEdBQUcsQ0FBQ1Y7SUFDckI7QUFDRjtBQUNBLE1BQU10SztJQUNKVCxZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXd0Msd0JBQXdCO0lBQ2pEO0lBQ0EyRCxnQkFBZ0JnQixhQUFhLEVBQUU7UUFDN0IsTUFBTXBMLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQy9ELE9BQU87UUFDVCxPQUFPakosdURBQW9CQTtJQUM3QjtJQUNBd1AscUJBQXFCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRTtRQUNsRCxNQUFNdEssU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTXVLLGNBQWN2SyxPQUFPd0QsSUFBSSxDQUFDNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ3hELElBQUksQ0FBQ2IsWUFBWTlHLFVBQVUsSUFBSSxDQUFDOEcsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFBRTtZQUNqRSxPQUFPZ0IsUUFBUUMsT0FBTztRQUN4QjtRQUNBLE1BQU0yRixZQUFZakIsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUM7UUFDbkQwRixlQUFlNEIsVUFBVSxHQUFHVixVQUFVVSxVQUFVLEtBQUssS0FBSyxJQUFJVixVQUFVVSxVQUFVLEdBQUc7UUFDckYsT0FBT3RHLFFBQVFDLE9BQU87SUFDeEI7QUFDRjtBQUNBLE1BQU1qRjtJQUNKbkIsWUFBWU8sTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzRFLElBQUksR0FBR1gsV0FBVzZDLHlCQUF5QjtJQUNsRDtJQUNBc0QsZ0JBQWdCZ0IsYUFBYSxFQUFFO1FBQzdCLE1BQU1wTCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNdUssY0FBY3ZLLE9BQU93RCxJQUFJLENBQUM2SCxTQUFTLENBQUNELGNBQWM7UUFDeEQsSUFBSSxDQUFDYixZQUFZOUcsVUFBVSxJQUFJLENBQUM4RyxZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxFQUMvRCxPQUFPO1FBQ1QsT0FBT2pKLHVEQUFvQkE7SUFDN0I7SUFDQXdQLHFCQUFxQkMsYUFBYSxFQUFFZCxjQUFjLEVBQUU7UUFDbEQsTUFBTXRLLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQUU7WUFDakUsT0FBT2dCLFFBQVFDLE9BQU87UUFDeEI7UUFDQSxNQUFNMkUsVUFBVSxFQUFFO1FBQ2xCLE1BQU1nQixZQUFZakIsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUM7UUFDbkQsSUFBSTRHLFVBQVVXLGlCQUFpQixLQUFLLEtBQUssR0FBRztZQUMxQzdCLGVBQWU4QixXQUFXLEdBQUdaLFVBQVVXLGlCQUFpQjtRQUMxRDtRQUNBLElBQUlYLFVBQVVhLGtCQUFrQixLQUFLLEtBQUssR0FBRztZQUMzQzdCLFFBQVFuSCxJQUFJLENBQUNyRCxPQUFPaUwsYUFBYSxDQUFDWCxnQkFBZ0Isa0JBQWtCa0IsVUFBVWEsa0JBQWtCO1FBQ2xHO1FBQ0EsSUFBSWIsVUFBVWMsY0FBYyxLQUFLLEtBQUssR0FBRztZQUN2Q2hDLGVBQWVpQyxjQUFjLEdBQUdmLFVBQVVjLGNBQWM7UUFDMUQ7UUFDQSxJQUFJaEMsZUFBZWtDLHlCQUF5QixLQUFLLEtBQUssR0FBRztZQUN2RGxDLGVBQWVrQyx5QkFBeUIsR0FBRztnQkFBQztnQkFBSzthQUFJO1FBQ3ZEO1FBQ0EsSUFBSWhCLFVBQVVpQiwyQkFBMkIsS0FBSyxLQUFLLEdBQUc7WUFDcERuQyxlQUFla0MseUJBQXlCLENBQUMsRUFBRSxHQUFHaEIsVUFBVWlCLDJCQUEyQjtRQUNyRjtRQUNBLElBQUlqQixVQUFVa0IsMkJBQTJCLEtBQUssS0FBSyxHQUFHO1lBQ3BEcEMsZUFBZWtDLHlCQUF5QixDQUFDLEVBQUUsR0FBR2hCLFVBQVVrQiwyQkFBMkI7UUFDckY7UUFDQSxJQUFJbEIsVUFBVW1CLDJCQUEyQixLQUFLLEtBQUssR0FBRztZQUNwRG5DLFFBQVFuSCxJQUFJLENBQ1ZyRCxPQUFPaUwsYUFBYSxDQUFDWCxnQkFBZ0IsMkJBQTJCa0IsVUFBVW1CLDJCQUEyQjtRQUV6RztRQUNBLE9BQU8vRyxRQUFRc0YsR0FBRyxDQUFDVjtJQUNyQjtBQUNGO0FBQ0EsTUFBTWxLO0lBQ0piLFlBQVlPLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUM0RSxJQUFJLEdBQUdYLFdBQVcwQyxtQkFBbUI7SUFDNUM7SUFDQXlELGdCQUFnQmdCLGFBQWEsRUFBRTtRQUM3QixNQUFNcEwsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTXVLLGNBQWN2SyxPQUFPd0QsSUFBSSxDQUFDNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ3hELElBQUksQ0FBQ2IsWUFBWTlHLFVBQVUsSUFBSSxDQUFDOEcsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFDL0QsT0FBTztRQUNULE9BQU9qSix1REFBb0JBO0lBQzdCO0lBQ0F3UCxxQkFBcUJDLGFBQWEsRUFBRWQsY0FBYyxFQUFFO1FBQ2xELE1BQU10SyxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNdUssY0FBY3ZLLE9BQU93RCxJQUFJLENBQUM2SCxTQUFTLENBQUNELGNBQWM7UUFDeEQsSUFBSSxDQUFDYixZQUFZOUcsVUFBVSxJQUFJLENBQUM4RyxZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxFQUFFO1lBQ2pFLE9BQU9nQixRQUFRQyxPQUFPO1FBQ3hCO1FBQ0EsTUFBTTJFLFVBQVUsRUFBRTtRQUNsQkYsZUFBZXNDLFVBQVUsR0FBRyxJQUFJdFIsd0NBQUtBLENBQUMsR0FBRyxHQUFHO1FBQzVDZ1AsZUFBZXVDLGNBQWMsR0FBRztRQUNoQ3ZDLGVBQWV3QyxLQUFLLEdBQUc7UUFDdkIsTUFBTXRCLFlBQVlqQixZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQztRQUNuRCxJQUFJNEcsVUFBVXVCLGdCQUFnQixLQUFLLEtBQUssR0FBRztZQUN6QyxNQUFNQyxjQUFjeEIsVUFBVXVCLGdCQUFnQjtZQUM5Q3pDLGVBQWVzQyxVQUFVLENBQUNoRSxNQUFNLENBQUNvRSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFM047UUFDbkY7UUFDQSxJQUFJbU0sVUFBVXlCLG9CQUFvQixLQUFLLEtBQUssR0FBRztZQUM3QzNDLGVBQWV1QyxjQUFjLEdBQUdyQixVQUFVeUIsb0JBQW9CO1FBQ2hFO1FBQ0EsSUFBSXpCLFVBQVUwQixpQkFBaUIsS0FBSyxLQUFLLEdBQUc7WUFDMUMxQyxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLGlCQUFpQmtCLFVBQVUwQixpQkFBaUIsRUFBRTlOO1FBQ2xHO1FBQ0EsSUFBSW9NLFVBQVUyQixxQkFBcUIsS0FBSyxLQUFLLEdBQUc7WUFDOUMzQyxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLHFCQUFxQmtCLFVBQVUyQixxQkFBcUI7UUFDeEc7UUFDQSxPQUFPdkgsUUFBUXNGLEdBQUcsQ0FBQ1Y7SUFDckI7QUFDRjtBQUNBLE1BQU1qSztJQUNKZCxZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXNEMsMEJBQTBCO0lBQ25EO0lBQ0F1RCxnQkFBZ0JnQixhQUFhLEVBQUU7UUFDN0IsTUFBTXBMLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQy9ELE9BQU87UUFDVCxPQUFPakosdURBQW9CQTtJQUM3QjtJQUNBd1AscUJBQXFCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRTtRQUNsRCxNQUFNdEssU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTXVLLGNBQWN2SyxPQUFPd0QsSUFBSSxDQUFDNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ3hELElBQUksQ0FBQ2IsWUFBWTlHLFVBQVUsSUFBSSxDQUFDOEcsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFBRTtZQUNqRSxPQUFPZ0IsUUFBUUMsT0FBTztRQUN4QjtRQUNBLE1BQU0yRSxVQUFVLEVBQUU7UUFDbEIsTUFBTWdCLFlBQVlqQixZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQztRQUNuRCxJQUFJNEcsVUFBVTRCLGtCQUFrQixLQUFLLEtBQUssR0FBRztZQUMzQzlDLGVBQWUrQyxZQUFZLEdBQUc3QixVQUFVNEIsa0JBQWtCO1FBQzVEO1FBQ0EsSUFBSTVCLFVBQVU4QixtQkFBbUIsS0FBSyxLQUFLLEdBQUc7WUFDNUM5QyxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLG1CQUFtQmtCLFVBQVU4QixtQkFBbUI7UUFDcEc7UUFDQSxPQUFPMUgsUUFBUXNGLEdBQUcsQ0FBQ1Y7SUFDckI7QUFDRjtBQUNBLE1BQU1oSztJQUNKZixZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXK0Msb0JBQW9CO0lBQzdDO0lBQ0FvRCxnQkFBZ0JnQixhQUFhLEVBQUU7UUFDN0IsTUFBTXBMLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQy9ELE9BQU87UUFDVCxPQUFPakosdURBQW9CQTtJQUM3QjtJQUNBd1AscUJBQXFCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRTtRQUNsRCxNQUFNdEssU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTXVLLGNBQWN2SyxPQUFPd0QsSUFBSSxDQUFDNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ3hELElBQUksQ0FBQ2IsWUFBWTlHLFVBQVUsSUFBSSxDQUFDOEcsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFBRTtZQUNqRSxPQUFPZ0IsUUFBUUMsT0FBTztRQUN4QjtRQUNBLE1BQU0yRSxVQUFVLEVBQUU7UUFDbEIsTUFBTWdCLFlBQVlqQixZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQztRQUNuRDBGLGVBQWVpRCxTQUFTLEdBQUcvQixVQUFVZ0MsZUFBZSxLQUFLLEtBQUssSUFBSWhDLFVBQVVnQyxlQUFlLEdBQUc7UUFDOUYsSUFBSWhDLFVBQVVpQyxnQkFBZ0IsS0FBSyxLQUFLLEdBQUc7WUFDekNqRCxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLGdCQUFnQmtCLFVBQVVpQyxnQkFBZ0I7UUFDOUY7UUFDQW5ELGVBQWVvRCxtQkFBbUIsR0FBR2xDLFVBQVVrQyxtQkFBbUIsSUFBSUM7UUFDdEUsTUFBTUMsYUFBYXBDLFVBQVVxQyxnQkFBZ0IsSUFBSTtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQzFEdkQsZUFBZXVELGdCQUFnQixHQUFHLElBQUl2Uyx3Q0FBS0EsR0FBR3NOLE1BQU0sQ0FDbERnRixVQUFVLENBQUMsRUFBRSxFQUNiQSxVQUFVLENBQUMsRUFBRSxFQUNiQSxVQUFVLENBQUMsRUFBRSxFQUNidk87UUFFRixPQUFPdUcsUUFBUXNGLEdBQUcsQ0FBQ1Y7SUFDckI7QUFDRjtBQUNBLE1BQU0vSjtJQUNKaEIsWUFBWU8sTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzRFLElBQUksR0FBR1gsV0FBV3lDLGlCQUFpQjtJQUMxQztJQUNBMEQsZ0JBQWdCZ0IsYUFBYSxFQUFFO1FBQzdCLE1BQU1wTCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNdUssY0FBY3ZLLE9BQU93RCxJQUFJLENBQUM2SCxTQUFTLENBQUNELGNBQWM7UUFDeEQsSUFBSSxDQUFDYixZQUFZOUcsVUFBVSxJQUFJLENBQUM4RyxZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxFQUMvRCxPQUFPO1FBQ1QsT0FBT2pKLHVEQUFvQkE7SUFDN0I7SUFDQXdQLHFCQUFxQkMsYUFBYSxFQUFFZCxjQUFjLEVBQUU7UUFDbEQsTUFBTXRLLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQUU7WUFDakUsT0FBT2dCLFFBQVFDLE9BQU87UUFDeEI7UUFDQSxNQUFNMkYsWUFBWWpCLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDO1FBQ25EMEYsZUFBZXdELEdBQUcsR0FBR3RDLFVBQVVzQyxHQUFHLEtBQUssS0FBSyxJQUFJdEMsVUFBVXNDLEdBQUcsR0FBRztRQUNoRSxPQUFPbEksUUFBUUMsT0FBTztJQUN4QjtBQUNGO0FBQ0EsTUFBTWxGO0lBQ0psQixZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXMkMsc0JBQXNCO0lBQy9DO0lBQ0F3RCxnQkFBZ0JnQixhQUFhLEVBQUU7UUFDN0IsTUFBTXBMLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQy9ELE9BQU87UUFDVCxPQUFPakosdURBQW9CQTtJQUM3QjtJQUNBd1AscUJBQXFCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRTtRQUNsRCxNQUFNdEssU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTXVLLGNBQWN2SyxPQUFPd0QsSUFBSSxDQUFDNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ3hELElBQUksQ0FBQ2IsWUFBWTlHLFVBQVUsSUFBSSxDQUFDOEcsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFBRTtZQUNqRSxPQUFPZ0IsUUFBUUMsT0FBTztRQUN4QjtRQUNBLE1BQU0yRSxVQUFVLEVBQUU7UUFDbEIsTUFBTWdCLFlBQVlqQixZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQztRQUNuRDBGLGVBQWV5RCxpQkFBaUIsR0FBR3ZDLFVBQVV3QyxjQUFjLEtBQUssS0FBSyxJQUFJeEMsVUFBVXdDLGNBQWMsR0FBRztRQUNwRyxJQUFJeEMsVUFBVXlDLGVBQWUsS0FBSyxLQUFLLEdBQUc7WUFDeEN6RCxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLHdCQUF3QmtCLFVBQVV5QyxlQUFlO1FBQ3JHO1FBQ0EsTUFBTUwsYUFBYXBDLFVBQVUwQyxtQkFBbUIsSUFBSTtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQzdENUQsZUFBZTZELGFBQWEsR0FBRyxJQUFJN1Msd0NBQUtBLEdBQUdzTixNQUFNLENBQUNnRixVQUFVLENBQUMsRUFBRSxFQUFFQSxVQUFVLENBQUMsRUFBRSxFQUFFQSxVQUFVLENBQUMsRUFBRSxFQUFFdk87UUFDL0YsSUFBSW1NLFVBQVU0QyxvQkFBb0IsS0FBSyxLQUFLLEdBQUc7WUFDN0M1RCxRQUFRbkgsSUFBSSxDQUNWckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLG9CQUFvQmtCLFVBQVU0QyxvQkFBb0IsRUFBRWhQO1FBRTdGO1FBQ0EsT0FBT3dHLFFBQVFzRixHQUFHLENBQUNWO0lBQ3JCO0FBQ0Y7QUFDQSxNQUFNMUo7SUFDSnJCLFlBQVlPLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUM0RSxJQUFJLEdBQUdYLFdBQVdrRCxrQkFBa0I7SUFDM0M7SUFDQWlELGdCQUFnQmdCLGFBQWEsRUFBRTtRQUM3QixNQUFNcEwsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTXVLLGNBQWN2SyxPQUFPd0QsSUFBSSxDQUFDNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ3hELElBQUksQ0FBQ2IsWUFBWTlHLFVBQVUsSUFBSSxDQUFDOEcsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFDL0QsT0FBTztRQUNULE9BQU9qSix1REFBb0JBO0lBQzdCO0lBQ0F3UCxxQkFBcUJDLGFBQWEsRUFBRWQsY0FBYyxFQUFFO1FBQ2xELE1BQU10SyxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNdUssY0FBY3ZLLE9BQU93RCxJQUFJLENBQUM2SCxTQUFTLENBQUNELGNBQWM7UUFDeEQsSUFBSSxDQUFDYixZQUFZOUcsVUFBVSxJQUFJLENBQUM4RyxZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxFQUFFO1lBQ2pFLE9BQU9nQixRQUFRQyxPQUFPO1FBQ3hCO1FBQ0EsTUFBTTJFLFVBQVUsRUFBRTtRQUNsQixNQUFNZ0IsWUFBWWpCLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDO1FBQ25EMEYsZUFBZStELFNBQVMsR0FBRzdDLFVBQVU4QyxVQUFVLEtBQUssS0FBSyxJQUFJOUMsVUFBVThDLFVBQVUsR0FBRztRQUNwRixJQUFJOUMsVUFBVStDLFdBQVcsS0FBSyxLQUFLLEdBQUc7WUFDcEMvRCxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLFdBQVdrQixVQUFVK0MsV0FBVztRQUNwRjtRQUNBLE9BQU8zSSxRQUFRc0YsR0FBRyxDQUFDVjtJQUNyQjtBQUNGO0FBQ0EsTUFBTTNKO0lBQ0pwQixZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXOEMsd0JBQXdCO0lBQ2pEO0lBQ0FxRCxnQkFBZ0JnQixhQUFhLEVBQUU7UUFDN0IsTUFBTXBMLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU11SyxjQUFjdkssT0FBT3dELElBQUksQ0FBQzZILFNBQVMsQ0FBQ0QsY0FBYztRQUN4RCxJQUFJLENBQUNiLFlBQVk5RyxVQUFVLElBQUksQ0FBQzhHLFlBQVk5RyxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLEVBQy9ELE9BQU87UUFDVCxPQUFPakosdURBQW9CQTtJQUM3QjtJQUNBd1AscUJBQXFCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRTtRQUNsRCxNQUFNdEssU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTXVLLGNBQWN2SyxPQUFPd0QsSUFBSSxDQUFDNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ3hELElBQUksQ0FBQ2IsWUFBWTlHLFVBQVUsSUFBSSxDQUFDOEcsWUFBWTlHLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFBRTtZQUNqRSxPQUFPZ0IsUUFBUUMsT0FBTztRQUN4QjtRQUNBLE1BQU0yRSxVQUFVLEVBQUU7UUFDbEIsTUFBTWdCLFlBQVlqQixZQUFZOUcsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQztRQUNuRCxJQUFJNEcsVUFBVWdELGtCQUFrQixLQUFLLEtBQUssR0FBRztZQUMzQ2xFLGVBQWVtRSxVQUFVLEdBQUdqRCxVQUFVZ0Qsa0JBQWtCO1FBQzFEO1FBQ0EsSUFBSWhELFVBQVVrRCxrQkFBa0IsS0FBSyxLQUFLLEdBQUc7WUFDM0NwRSxlQUFlb0Usa0JBQWtCLEdBQUdsRCxVQUFVa0Qsa0JBQWtCO1FBQ2xFO1FBQ0EsSUFBSWxELFVBQVVtRCxpQkFBaUIsS0FBSyxLQUFLLEdBQUc7WUFDMUNuRSxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLGlCQUFpQmtCLFVBQVVtRCxpQkFBaUI7UUFDaEc7UUFDQSxPQUFPL0ksUUFBUXNGLEdBQUcsQ0FBQ1Y7SUFDckI7QUFDRjtBQUNBLE1BQU1ySztJQUNKVixZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXZ0Qsa0JBQWtCO0lBQzNDO0lBQ0EySCxZQUFZQyxZQUFZLEVBQUU7UUFDeEIsTUFBTTdPLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU13RCxPQUFPeEQsT0FBT3dELElBQUk7UUFDeEIsTUFBTXNMLGFBQWF0TCxLQUFLdUwsUUFBUSxDQUFDRixhQUFhO1FBQzlDLElBQUksQ0FBQ0MsV0FBV3JMLFVBQVUsSUFBSSxDQUFDcUwsV0FBV3JMLFVBQVUsQ0FBQyxJQUFJLENBQUNtQixJQUFJLENBQUMsRUFBRTtZQUMvRCxPQUFPO1FBQ1Q7UUFDQSxNQUFNNEcsWUFBWXNELFdBQVdyTCxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDO1FBQ2xELE1BQU14QyxTQUFTcEMsT0FBT2dQLE9BQU8sQ0FBQ3BQLFVBQVU7UUFDeEMsSUFBSSxDQUFDd0MsUUFBUTtZQUNYLElBQUlvQixLQUFLdUIsa0JBQWtCLElBQUl2QixLQUFLdUIsa0JBQWtCLENBQUMzQixPQUFPLENBQUMsSUFBSSxDQUFDd0IsSUFBSSxLQUFLLEdBQUc7Z0JBQzlFLE1BQU0sSUFBSTVCLE1BQU07WUFDbEIsT0FBTztnQkFDTCxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU9oRCxPQUFPaVAsZ0JBQWdCLENBQUNKLGNBQWNyRCxVQUFVMEQsTUFBTSxFQUFFOU07SUFDakU7QUFDRjtBQUNBLE1BQU1oQztJQUNKWCxZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXbUQsZ0JBQWdCO1FBQ3ZDLElBQUksQ0FBQytILFdBQVcsR0FBRztJQUNyQjtJQUNBUCxZQUFZQyxZQUFZLEVBQUU7UUFDeEIsTUFBTWpLLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU01RSxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNd0QsT0FBT3hELE9BQU93RCxJQUFJO1FBQ3hCLE1BQU1zTCxhQUFhdEwsS0FBS3VMLFFBQVEsQ0FBQ0YsYUFBYTtRQUM5QyxJQUFJLENBQUNDLFdBQVdyTCxVQUFVLElBQUksQ0FBQ3FMLFdBQVdyTCxVQUFVLENBQUNtQixLQUFLLEVBQUU7WUFDMUQsT0FBTztRQUNUO1FBQ0EsTUFBTTRHLFlBQVlzRCxXQUFXckwsVUFBVSxDQUFDbUIsS0FBSztRQUM3QyxNQUFNc0ssU0FBUzFMLEtBQUs0TCxNQUFNLENBQUM1RCxVQUFVMEQsTUFBTSxDQUFDO1FBQzVDLElBQUk5TSxTQUFTcEMsT0FBT3FQLGFBQWE7UUFDakMsSUFBSUgsT0FBT0ksR0FBRyxFQUFFO1lBQ2QsTUFBTUMsVUFBVXZQLE9BQU9nUCxPQUFPLENBQUN0UCxPQUFPLENBQUM4UCxVQUFVLENBQUNOLE9BQU9JLEdBQUc7WUFDNUQsSUFBSUMsWUFBWSxNQUNkbk4sU0FBU21OO1FBQ2I7UUFDQSxPQUFPLElBQUksQ0FBQ0UsYUFBYSxHQUFHdkYsSUFBSSxDQUFDLFNBQVNpRixXQUFXO1lBQ25ELElBQUlBLGFBQ0YsT0FBT25QLE9BQU9pUCxnQkFBZ0IsQ0FBQ0osY0FBY3JELFVBQVUwRCxNQUFNLEVBQUU5TTtZQUNqRSxJQUFJb0IsS0FBS3VCLGtCQUFrQixJQUFJdkIsS0FBS3VCLGtCQUFrQixDQUFDM0IsT0FBTyxDQUFDd0IsU0FBUyxHQUFHO2dCQUN6RSxNQUFNLElBQUk1QixNQUFNO1lBQ2xCO1lBQ0EsT0FBT2hELE9BQU80TyxXQUFXLENBQUNDO1FBQzVCO0lBQ0Y7SUFDQVksZ0JBQWdCO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ04sV0FBVyxFQUFFO1lBQ3JCLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUl2SixRQUFRLFNBQVNDLE9BQU87Z0JBQzdDLE1BQU02SixRQUFRLElBQUlDO2dCQUNsQkQsTUFBTUUsR0FBRyxHQUFHO2dCQUNaRixNQUFNRyxNQUFNLEdBQUdILE1BQU1JLE9BQU8sR0FBRztvQkFDN0JqSyxRQUFRNkosTUFBTUssTUFBTSxLQUFLO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQ1osV0FBVztJQUN6QjtBQUNGO0FBQ0EsTUFBTTlPO0lBQ0paLFlBQVlPLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUM0RSxJQUFJLEdBQUdYLFdBQVdvRCxnQkFBZ0I7UUFDdkMsSUFBSSxDQUFDOEgsV0FBVyxHQUFHO0lBQ3JCO0lBQ0FQLFlBQVlDLFlBQVksRUFBRTtRQUN4QixNQUFNakssT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTTVFLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU13RCxPQUFPeEQsT0FBT3dELElBQUk7UUFDeEIsTUFBTXNMLGFBQWF0TCxLQUFLdUwsUUFBUSxDQUFDRixhQUFhO1FBQzlDLElBQUksQ0FBQ0MsV0FBV3JMLFVBQVUsSUFBSSxDQUFDcUwsV0FBV3JMLFVBQVUsQ0FBQ21CLEtBQUssRUFBRTtZQUMxRCxPQUFPO1FBQ1Q7UUFDQSxNQUFNNEcsWUFBWXNELFdBQVdyTCxVQUFVLENBQUNtQixLQUFLO1FBQzdDLE1BQU1zSyxTQUFTMUwsS0FBSzRMLE1BQU0sQ0FBQzVELFVBQVUwRCxNQUFNLENBQUM7UUFDNUMsSUFBSTlNLFNBQVNwQyxPQUFPcVAsYUFBYTtRQUNqQyxJQUFJSCxPQUFPSSxHQUFHLEVBQUU7WUFDZCxNQUFNQyxVQUFVdlAsT0FBT2dQLE9BQU8sQ0FBQ3RQLE9BQU8sQ0FBQzhQLFVBQVUsQ0FBQ04sT0FBT0ksR0FBRztZQUM1RCxJQUFJQyxZQUFZLE1BQ2RuTixTQUFTbU47UUFDYjtRQUNBLE9BQU8sSUFBSSxDQUFDRSxhQUFhLEdBQUd2RixJQUFJLENBQUMsU0FBU2lGLFdBQVc7WUFDbkQsSUFBSUEsYUFDRixPQUFPblAsT0FBT2lQLGdCQUFnQixDQUFDSixjQUFjckQsVUFBVTBELE1BQU0sRUFBRTlNO1lBQ2pFLElBQUlvQixLQUFLdUIsa0JBQWtCLElBQUl2QixLQUFLdUIsa0JBQWtCLENBQUMzQixPQUFPLENBQUN3QixTQUFTLEdBQUc7Z0JBQ3pFLE1BQU0sSUFBSTVCLE1BQU07WUFDbEI7WUFDQSxPQUFPaEQsT0FBTzRPLFdBQVcsQ0FBQ0M7UUFDNUI7SUFDRjtJQUNBWSxnQkFBZ0I7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDTixXQUFXLEVBQUU7WUFDckIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSXZKLFFBQVEsU0FBU0MsT0FBTztnQkFDN0MsTUFBTTZKLFFBQVEsSUFBSUM7Z0JBQ2xCRCxNQUFNRSxHQUFHLEdBQUc7Z0JBQ1pGLE1BQU1HLE1BQU0sR0FBR0gsTUFBTUksT0FBTyxHQUFHO29CQUM3QmpLLFFBQVE2SixNQUFNSyxNQUFNLEtBQUs7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDWixXQUFXO0lBQ3pCO0FBQ0Y7QUFDQSxNQUFNbk87SUFDSnZCLFlBQVlPLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUM0RSxJQUFJLEdBQUdYLFdBQVdxRCx1QkFBdUI7UUFDOUMsSUFBSSxDQUFDdEgsTUFBTSxHQUFHQTtJQUNoQjtJQUNBZ1EsZUFBZWpHLEtBQUssRUFBRTtRQUNwQixNQUFNdkcsT0FBTyxJQUFJLENBQUN4RCxNQUFNLENBQUN3RCxJQUFJO1FBQzdCLE1BQU15TSxhQUFhek0sS0FBSzBNLFdBQVcsQ0FBQ25HLE1BQU07UUFDMUMsSUFBSWtHLFdBQVd4TSxVQUFVLElBQUl3TSxXQUFXeE0sVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxFQUFFO1lBQzdELE1BQU11TCxlQUFlRixXQUFXeE0sVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQztZQUNyRCxNQUFNd0wsU0FBUyxJQUFJLENBQUNwUSxNQUFNLENBQUM4SixhQUFhLENBQUMsVUFBVXFHLGFBQWFDLE1BQU07WUFDdEUsTUFBTUMsVUFBVSxJQUFJLENBQUNyUSxNQUFNLENBQUNnUCxPQUFPLENBQUNuUCxjQUFjO1lBQ2xELElBQUksQ0FBQ3dRLFdBQVcsQ0FBQ0EsUUFBUUMsU0FBUyxFQUFFO2dCQUNsQyxJQUFJOU0sS0FBS3VCLGtCQUFrQixJQUFJdkIsS0FBS3VCLGtCQUFrQixDQUFDM0IsT0FBTyxDQUFDLElBQUksQ0FBQ3dCLElBQUksS0FBSyxHQUFHO29CQUM5RSxNQUFNLElBQUk1QixNQUFNO2dCQUNsQixPQUFPO29CQUNMLE9BQU87Z0JBQ1Q7WUFDRjtZQUNBLE9BQU9vTixPQUFPbEcsSUFBSSxDQUFDLFNBQVNxRyxHQUFHO2dCQUM3QixNQUFNQyxhQUFhTCxhQUFhSyxVQUFVLElBQUk7Z0JBQzlDLE1BQU1DLGFBQWFOLGFBQWFNLFVBQVUsSUFBSTtnQkFDOUMsTUFBTUMsUUFBUVAsYUFBYU8sS0FBSztnQkFDaEMsTUFBTUMsU0FBU1IsYUFBYVMsVUFBVTtnQkFDdEMsTUFBTTFCLFNBQVMsSUFBSXBMLFdBQVd5TSxLQUFLQyxZQUFZQztnQkFDL0MsSUFBSUosUUFBUVEscUJBQXFCLEVBQUU7b0JBQ2pDLE9BQU9SLFFBQVFRLHFCQUFxQixDQUFDSCxPQUFPQyxRQUFRekIsUUFBUWlCLGFBQWFXLElBQUksRUFBRVgsYUFBYVksTUFBTSxFQUFFN0csSUFBSSxDQUFDLFNBQVM4RyxJQUFJO3dCQUNwSCxPQUFPQSxLQUFLWixNQUFNO29CQUNwQjtnQkFDRixPQUFPO29CQUNMLE9BQU9DLFFBQVFZLEtBQUssQ0FBQy9HLElBQUksQ0FBQzt3QkFDeEIsTUFBTWdILFNBQVMsSUFBSXROLFlBQVk4TSxRQUFRQzt3QkFDdkNOLFFBQVFjLGdCQUFnQixDQUN0QixJQUFJck4sV0FBV29OLFNBQ2ZSLE9BQ0FDLFFBQ0F6QixRQUNBaUIsYUFBYVcsSUFBSSxFQUNqQlgsYUFBYVksTUFBTTt3QkFFckIsT0FBT0c7b0JBQ1Q7Z0JBQ0Y7WUFDRjtRQUNGLE9BQU87WUFDTCxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsTUFBTWpRO0lBQ0p4QixZQUFZTyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDNEUsSUFBSSxHQUFHWCxXQUFXc0QsdUJBQXVCO1FBQzlDLElBQUksQ0FBQ3ZILE1BQU0sR0FBR0E7SUFDaEI7SUFDQW9SLGVBQWV0SixTQUFTLEVBQUU7UUFDeEIsTUFBTXRFLE9BQU8sSUFBSSxDQUFDeEQsTUFBTSxDQUFDd0QsSUFBSTtRQUM3QixNQUFNd0UsVUFBVXhFLEtBQUtxRSxLQUFLLENBQUNDLFVBQVU7UUFDckMsSUFBSSxDQUFDRSxRQUFRdkUsVUFBVSxJQUFJLENBQUN1RSxRQUFRdkUsVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxJQUFJb0QsUUFBUXFKLElBQUksS0FBSyxLQUFLLEdBQUc7WUFDcEYsT0FBTztRQUNUO1FBQ0EsTUFBTUMsVUFBVTlOLEtBQUsrTixNQUFNLENBQUN2SixRQUFRcUosSUFBSSxDQUFDO1FBQ3pDLEtBQUssTUFBTUcsYUFBYUYsUUFBUUcsVUFBVSxDQUFFO1lBQzFDLElBQUlELFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCQyxTQUFTLElBQUlILFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCRSxjQUFjLElBQUlKLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCRyxZQUFZLElBQUlMLFVBQVVWLElBQUksS0FBSyxLQUFLLEdBQUc7Z0JBQ3JMLE9BQU87WUFDVDtRQUNGO1FBQ0EsTUFBTVgsZUFBZW5JLFFBQVF2RSxVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDO1FBQ2xELE1BQU1rTixnQkFBZ0IzQixhQUFhNEIsVUFBVTtRQUM3QyxNQUFNdkgsVUFBVSxFQUFFO1FBQ2xCLE1BQU11SCxhQUFhLENBQUM7UUFDcEIsSUFBSyxNQUFNN0wsT0FBTzRMLGNBQWU7WUFDL0J0SCxRQUFRbkgsSUFBSSxDQUNWLElBQUksQ0FBQ3JELE1BQU0sQ0FBQzhKLGFBQWEsQ0FBQyxZQUFZZ0ksYUFBYSxDQUFDNUwsSUFBSSxFQUFFZ0UsSUFBSSxDQUFDLENBQUM4SDtnQkFDOURELFVBQVUsQ0FBQzdMLElBQUksR0FBRzhMO2dCQUNsQixPQUFPRCxVQUFVLENBQUM3TCxJQUFJO1lBQ3hCO1FBRUo7UUFDQSxJQUFJc0UsUUFBUTlGLE1BQU0sR0FBRyxHQUFHO1lBQ3RCLE9BQU87UUFDVDtRQUNBOEYsUUFBUW5ILElBQUksQ0FBQyxJQUFJLENBQUNyRCxNQUFNLENBQUNvUixjQUFjLENBQUN0SjtRQUN4QyxPQUFPbEMsUUFBUXNGLEdBQUcsQ0FBQ1YsU0FBU04sSUFBSSxDQUFDLENBQUMrSDtZQUNoQyxNQUFNQyxhQUFhRCxRQUFRRSxHQUFHO1lBQzlCLE1BQU1aLFNBQVNXLFdBQVdFLE9BQU8sR0FBR0YsV0FBV0csUUFBUSxHQUFHO2dCQUFDSDthQUFXO1lBQ3RFLE1BQU14QixRQUFRdUIsT0FBTyxDQUFDLEVBQUUsQ0FBQ3ZCLEtBQUs7WUFDOUIsTUFBTTRCLGtCQUFrQixFQUFFO1lBQzFCLEtBQUssTUFBTWpCLFFBQVFFLE9BQVE7Z0JBQ3pCLE1BQU1nQixJQUFJLElBQUkxVywwQ0FBT0E7Z0JBQ3JCLE1BQU0yVyxJQUFJLElBQUkxVywwQ0FBT0E7Z0JBQ3JCLE1BQU0yVyxJQUFJLElBQUkxVyw2Q0FBVUE7Z0JBQ3hCLE1BQU0yVyxJQUFJLElBQUk1VywwQ0FBT0EsQ0FBQyxHQUFHLEdBQUc7Z0JBQzVCLE1BQU02VyxnQkFBZ0IsSUFBSTNXLGdEQUFhQSxDQUFDcVYsS0FBS3VCLFFBQVEsRUFBRXZCLEtBQUt3QixRQUFRLEVBQUVuQztnQkFDdEUsSUFBSyxJQUFJak0sSUFBSSxHQUFHQSxJQUFJaU0sT0FBT2pNLElBQUs7b0JBQzlCLElBQUlzTixXQUFXZSxXQUFXLEVBQUU7d0JBQzFCTixFQUFFTyxtQkFBbUIsQ0FBQ2hCLFdBQVdlLFdBQVcsRUFBRXJPO29CQUNoRDtvQkFDQSxJQUFJc04sV0FBV2lCLFFBQVEsRUFBRTt3QkFDdkJQLEVBQUVNLG1CQUFtQixDQUFDaEIsV0FBV2lCLFFBQVEsRUFBRXZPO29CQUM3QztvQkFDQSxJQUFJc04sV0FBV2tCLEtBQUssRUFBRTt3QkFDcEJQLEVBQUVLLG1CQUFtQixDQUFDaEIsV0FBV2tCLEtBQUssRUFBRXhPO29CQUMxQztvQkFDQWtPLGNBQWNPLFdBQVcsQ0FBQ3pPLEdBQUc4TixFQUFFWSxPQUFPLENBQUNYLEdBQUdDLEdBQUdDO2dCQUMvQztnQkFDQSxJQUFLLE1BQU1VLGlCQUFpQnJCLFdBQVk7b0JBQ3RDLElBQUlxQixrQkFBa0IsWUFBWTt3QkFDaEMsTUFBTUMsT0FBT3RCLFVBQVUsQ0FBQ3FCLGNBQWM7d0JBQ3RDVCxjQUFjVyxhQUFhLEdBQUcsSUFBSXJYLDJEQUF3QkEsQ0FBQ29YLEtBQUt0SSxLQUFLLEVBQUVzSSxLQUFLRSxRQUFRLEVBQUVGLEtBQUtHLFVBQVU7b0JBQ3ZHLE9BQU8sSUFBSUosa0JBQWtCLGlCQUFpQkEsa0JBQWtCLGNBQWNBLGtCQUFrQixTQUFTO3dCQUN2Ry9CLEtBQUt1QixRQUFRLENBQUNhLFlBQVksQ0FBQ0wsZUFBZXJCLFVBQVUsQ0FBQ3FCLGNBQWM7b0JBQ3JFO2dCQUNGO2dCQUNBbFgsMkNBQVFBLENBQUN3WCxTQUFTLENBQUNDLElBQUksQ0FBQ0MsSUFBSSxDQUFDakIsZUFBZXRCO2dCQUM1QyxJQUFJLENBQUNyUixNQUFNLENBQUM2VCxtQkFBbUIsQ0FBQ2xCO2dCQUNoQ0wsZ0JBQWdCalAsSUFBSSxDQUFDc1A7WUFDdkI7WUFDQSxJQUFJVCxXQUFXRSxPQUFPLEVBQUU7Z0JBQ3RCRixXQUFXNEIsS0FBSztnQkFDaEI1QixXQUFXL0wsR0FBRyxJQUFJbU07Z0JBQ2xCLE9BQU9KO1lBQ1Q7WUFDQSxPQUFPSSxlQUFlLENBQUMsRUFBRTtRQUMzQjtJQUNGO0FBQ0Y7QUFDQSxNQUFNdE8sZ0NBQWdDO0FBQ3RDLE1BQU0rUCxpQ0FBaUM7QUFDdkMsTUFBTUMsK0JBQStCO0lBQUVyUSxNQUFNO0lBQVlzUSxLQUFLO0FBQVE7QUFDdEUsTUFBTTlQO0lBQ0oxRSxZQUFZa0QsSUFBSSxDQUFFO1FBQ2hCLElBQUksQ0FBQ2lDLElBQUksR0FBR1gsV0FBV0MsZUFBZTtRQUN0QyxJQUFJLENBQUNFLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQzhQLElBQUksR0FBRztRQUNaLE1BQU1DLGFBQWEsSUFBSUMsU0FBU3pSLE1BQU0sR0FBR29SO1FBQ3pDLElBQUksQ0FBQ00sTUFBTSxHQUFHO1lBQ1p4USxPQUFPMUUsb0VBQVVBLENBQUMsSUFBSTJFLFdBQVduQixLQUFLb0IsS0FBSyxDQUFDLEdBQUc7WUFDL0M3RSxTQUFTaVYsV0FBV0csU0FBUyxDQUFDLEdBQUc7WUFDakM1UCxRQUFReVAsV0FBV0csU0FBUyxDQUFDLEdBQUc7UUFDbEM7UUFDQSxJQUFJLElBQUksQ0FBQ0QsTUFBTSxDQUFDeFEsS0FBSyxLQUFLRywrQkFBK0I7WUFDdkQsTUFBTSxJQUFJaEIsTUFBTTtRQUNsQixPQUFPLElBQUksSUFBSSxDQUFDcVIsTUFBTSxDQUFDblYsT0FBTyxHQUFHLEdBQUc7WUFDbEMsTUFBTSxJQUFJOEQsTUFBTTtRQUNsQjtRQUNBLE1BQU11UixzQkFBc0IsSUFBSSxDQUFDRixNQUFNLENBQUMzUCxNQUFNLEdBQUdxUDtRQUNqRCxNQUFNUyxZQUFZLElBQUlKLFNBQVN6UixNQUFNb1I7UUFDckMsSUFBSVUsYUFBYTtRQUNqQixNQUFPQSxhQUFhRixvQkFBcUI7WUFDdkMsTUFBTUcsY0FBY0YsVUFBVUYsU0FBUyxDQUFDRyxZQUFZO1lBQ3BEQSxjQUFjO1lBQ2QsTUFBTUUsWUFBWUgsVUFBVUYsU0FBUyxDQUFDRyxZQUFZO1lBQ2xEQSxjQUFjO1lBQ2QsSUFBSUUsY0FBY1gsNkJBQTZCclEsSUFBSSxFQUFFO2dCQUNuRCxNQUFNaVIsZUFBZSxJQUFJOVEsV0FBV25CLE1BQU1vUixpQ0FBaUNVLFlBQVlDO2dCQUN2RixJQUFJLENBQUN0USxPQUFPLEdBQUdqRixvRUFBVUEsQ0FBQ3lWO1lBQzVCLE9BQU8sSUFBSUQsY0FBY1gsNkJBQTZCQyxHQUFHLEVBQUU7Z0JBQ3pELE1BQU16RCxhQUFhdUQsaUNBQWlDVTtnQkFDcEQsSUFBSSxDQUFDUCxJQUFJLEdBQUd2UixLQUFLb0IsS0FBSyxDQUFDeU0sWUFBWUEsYUFBYWtFO1lBQ2xEO1lBQ0FELGNBQWNDO1FBQ2hCO1FBQ0EsSUFBSSxJQUFJLENBQUN0USxPQUFPLEtBQUssTUFBTTtZQUN6QixNQUFNLElBQUlwQixNQUFNO1FBQ2xCO0lBQ0Y7QUFDRjtBQUNBLE1BQU1tQztJQUNKMUYsWUFBWStELElBQUksRUFBRTdELFdBQVcsQ0FBRTtRQUM3QixJQUFJLENBQUNBLGFBQWE7WUFDaEIsTUFBTSxJQUFJcUQsTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQzRCLElBQUksR0FBR1gsV0FBV2lCLDBCQUEwQjtRQUNqRCxJQUFJLENBQUMxQixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDN0QsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNBLFdBQVcsQ0FBQ2tWLE9BQU87SUFDMUI7SUFDQUMsZ0JBQWdCdEQsU0FBUyxFQUFFeFIsTUFBTSxFQUFFO1FBQ2pDLE1BQU13RCxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNN0QsY0FBYyxJQUFJLENBQUNBLFdBQVc7UUFDcEMsTUFBTW9WLGtCQUFrQnZELFVBQVUvTixVQUFVLENBQUMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDLENBQUNxTCxVQUFVO1FBQ2xFLE1BQU0rRSxtQkFBbUJ4RCxVQUFVL04sVUFBVSxDQUFDLElBQUksQ0FBQ21CLElBQUksQ0FBQyxDQUFDbU4sVUFBVTtRQUNuRSxNQUFNa0Qsb0JBQW9CLENBQUM7UUFDM0IsTUFBTUMseUJBQXlCLENBQUM7UUFDaEMsTUFBTUMsbUJBQW1CLENBQUM7UUFDMUIsSUFBSyxNQUFNL0IsaUJBQWlCNEIsaUJBQWtCO1lBQzVDLE1BQU1JLHFCQUFxQkMsVUFBVSxDQUFDakMsY0FBYyxJQUFJQSxjQUFja0MsV0FBVztZQUNqRkwsaUJBQWlCLENBQUNHLG1CQUFtQixHQUFHSixnQkFBZ0IsQ0FBQzVCLGNBQWM7UUFDekU7UUFDQSxJQUFLLE1BQU1BLGlCQUFpQjVCLFVBQVVPLFVBQVUsQ0FBRTtZQUNoRCxNQUFNcUQscUJBQXFCQyxVQUFVLENBQUNqQyxjQUFjLElBQUlBLGNBQWNrQyxXQUFXO1lBQ2pGLElBQUlOLGdCQUFnQixDQUFDNUIsY0FBYyxLQUFLLEtBQUssR0FBRztnQkFDOUMsTUFBTW1DLGNBQWMvUixLQUFLZ1MsU0FBUyxDQUFDaEUsVUFBVU8sVUFBVSxDQUFDcUIsY0FBYyxDQUFDO2dCQUN2RSxNQUFNcUMsZ0JBQWdCQyxxQkFBcUIsQ0FBQ0gsWUFBWUUsYUFBYSxDQUFDO2dCQUN0RU4sZ0JBQWdCLENBQUNDLG1CQUFtQixHQUFHSyxjQUFjN1EsSUFBSTtnQkFDekRzUSxzQkFBc0IsQ0FBQ0UsbUJBQW1CLEdBQUdHLFlBQVkvQixVQUFVLEtBQUs7WUFDMUU7UUFDRjtRQUNBLE9BQU94VCxPQUFPOEosYUFBYSxDQUFDLGNBQWNpTCxpQkFBaUI3SyxJQUFJLENBQUMsU0FBUytGLFVBQVU7WUFDakYsT0FBTyxJQUFJckssUUFBUSxTQUFTQyxPQUFPLEVBQUVDLE1BQU07Z0JBQ3pDbkcsWUFBWWdXLGVBQWUsQ0FDekIxRixZQUNBLFNBQVMyQyxRQUFRO29CQUNmLElBQUssTUFBTVEsaUJBQWlCUixTQUFTYixVQUFVLENBQUU7d0JBQy9DLE1BQU02RCxZQUFZaEQsU0FBU2IsVUFBVSxDQUFDcUIsY0FBYzt3QkFDcEQsTUFBTUksYUFBYTBCLHNCQUFzQixDQUFDOUIsY0FBYzt3QkFDeEQsSUFBSUksZUFBZSxLQUFLLEdBQ3RCb0MsVUFBVXBDLFVBQVUsR0FBR0E7b0JBQzNCO29CQUNBM04sUUFBUStNO2dCQUNWLEdBQ0FxQyxtQkFDQUUsa0JBQ0E5VixzQkFDQXlHO1lBRUo7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxNQUFNVDtJQUNKNUYsYUFBYztRQUNaLElBQUksQ0FBQ21GLElBQUksR0FBR1gsV0FBV21CLHFCQUFxQjtJQUM5QztJQUNBeVEsY0FBY0MsT0FBTyxFQUFFQyxTQUFTLEVBQUU7UUFDaEMsSUFBSSxDQUFDQSxVQUFVQyxRQUFRLEtBQUssS0FBSyxLQUFLRCxVQUFVQyxRQUFRLEtBQUtGLFFBQVFHLE9BQU8sS0FBS0YsVUFBVUcsTUFBTSxLQUFLLEtBQUssS0FBS0gsVUFBVUksUUFBUSxLQUFLLEtBQUssS0FBS0osVUFBVS9KLEtBQUssS0FBSyxLQUFLLEdBQUc7WUFDM0ssT0FBTzhKO1FBQ1Q7UUFDQUEsVUFBVUEsUUFBUU0sS0FBSztRQUN2QixJQUFJTCxVQUFVQyxRQUFRLEtBQUssS0FBSyxHQUFHO1lBQ2pDRixRQUFRRyxPQUFPLEdBQUdGLFVBQVVDLFFBQVE7UUFDdEM7UUFDQSxJQUFJRCxVQUFVRyxNQUFNLEtBQUssS0FBSyxHQUFHO1lBQy9CSixRQUFRSSxNQUFNLENBQUNHLFNBQVMsQ0FBQ04sVUFBVUcsTUFBTTtRQUMzQztRQUNBLElBQUlILFVBQVVJLFFBQVEsS0FBSyxLQUFLLEdBQUc7WUFDakNMLFFBQVFLLFFBQVEsR0FBR0osVUFBVUksUUFBUTtRQUN2QztRQUNBLElBQUlKLFVBQVUvSixLQUFLLEtBQUssS0FBSyxHQUFHO1lBQzlCOEosUUFBUVEsTUFBTSxDQUFDRCxTQUFTLENBQUNOLFVBQVUvSixLQUFLO1FBQzFDO1FBQ0E4SixRQUFRUyxXQUFXLEdBQUc7UUFDdEIsT0FBT1Q7SUFDVDtBQUNGO0FBQ0EsTUFBTXZRO0lBQ0o5RixhQUFjO1FBQ1osSUFBSSxDQUFDbUYsSUFBSSxHQUFHWCxXQUFXcUIscUJBQXFCO0lBQzlDO0FBQ0Y7QUFDQSxNQUFNa1IsbUNBQW1DeFgsOENBQVdBO0lBQ2xEUyxZQUFZZ1gsa0JBQWtCLEVBQUVDLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxZQUFZLENBQUU7UUFDdEUsS0FBSyxDQUFDSCxvQkFBb0JDLGNBQWNDLFlBQVlDO0lBQ3REO0lBQ0FDLGlCQUFpQjlNLEtBQUssRUFBRTtRQUN0QixNQUFNbUgsU0FBUyxJQUFJLENBQUMwRixZQUFZLEVBQUVFLFNBQVMsSUFBSSxDQUFDSixZQUFZLEVBQUVLLFlBQVksSUFBSSxDQUFDQSxTQUFTLEVBQUViLFNBQVNuTSxRQUFRZ04sWUFBWSxJQUFJQTtRQUMzSCxJQUFLLElBQUl0UyxJQUFJLEdBQUdBLE1BQU1zUyxXQUFXdFMsSUFBSztZQUNwQ3lNLE1BQU0sQ0FBQ3pNLEVBQUUsR0FBR3FTLE1BQU0sQ0FBQ1osU0FBU3pSLEVBQUU7UUFDaEM7UUFDQSxPQUFPeU07SUFDVDtJQUNBOEYsYUFBYUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLENBQUMsRUFBRUMsRUFBRSxFQUFFO1FBQzFCLE1BQU1sRyxTQUFTLElBQUksQ0FBQzBGLFlBQVk7UUFDaEMsTUFBTUUsU0FBUyxJQUFJLENBQUNKLFlBQVk7UUFDaEMsTUFBTS9GLFNBQVMsSUFBSSxDQUFDb0csU0FBUztRQUM3QixNQUFNTSxVQUFVMUcsU0FBUztRQUN6QixNQUFNMkcsVUFBVTNHLFNBQVM7UUFDekIsTUFBTTRHLEtBQUtILEtBQUtGO1FBQ2hCLE1BQU0xRSxJQUFJLENBQUMyRSxJQUFJRCxFQUFDLElBQUtLO1FBQ3JCLE1BQU1DLEtBQUtoRixJQUFJQTtRQUNmLE1BQU1pRixNQUFNRCxLQUFLaEY7UUFDakIsTUFBTWtGLFVBQVVULEtBQUtLO1FBQ3JCLE1BQU1LLFVBQVVELFVBQVVKO1FBQzFCLE1BQU1NLEtBQUssQ0FBQyxJQUFJSCxNQUFNLElBQUlEO1FBQzFCLE1BQU1LLEtBQUtKLE1BQU1EO1FBQ2pCLE1BQU1NLEtBQUssSUFBSUY7UUFDZixNQUFNRyxLQUFLRixLQUFLTCxLQUFLaEY7UUFDckIsSUFBSyxJQUFJL04sSUFBSSxHQUFHQSxNQUFNa00sUUFBUWxNLElBQUs7WUFDakMsTUFBTXVULEtBQUtsQixNQUFNLENBQUNhLFVBQVVsVCxJQUFJa00sT0FBTztZQUN2QyxNQUFNc0gsS0FBS25CLE1BQU0sQ0FBQ2EsVUFBVWxULElBQUk0UyxRQUFRLEdBQUdFO1lBQzNDLE1BQU1XLEtBQUtwQixNQUFNLENBQUNZLFVBQVVqVCxJQUFJa00sT0FBTztZQUN2QyxNQUFNd0gsS0FBS3JCLE1BQU0sQ0FBQ1ksVUFBVWpULEVBQUUsR0FBRzhTO1lBQ2pDckcsTUFBTSxDQUFDek0sRUFBRSxHQUFHcVQsS0FBS0UsS0FBS0QsS0FBS0UsS0FBS0wsS0FBS00sS0FBS0wsS0FBS007UUFDakQ7UUFDQSxPQUFPakg7SUFDVDtBQUNGO0FBQ0EsTUFBTWtILEtBQUssYUFBYSxHQUFHLElBQUlyYyw2Q0FBVUE7QUFDekMsTUFBTXNjLDZDQUE2QzdCO0lBQ2pEUSxhQUFhQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFLEVBQUU7UUFDMUIsTUFBTWxHLFNBQVMsS0FBSyxDQUFDOEYsYUFBYUMsSUFBSUMsSUFBSUMsR0FBR0M7UUFDN0NnQixHQUFHL0IsU0FBUyxDQUFDbkYsUUFBUW9ILFNBQVMsR0FBR0MsT0FBTyxDQUFDckg7UUFDekMsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsTUFBTVEsa0JBQWtCO0lBQ3RCOEcsT0FBTztJQUNQLG9CQUFvQjtJQUNwQkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWnpILFdBQVc7SUFDWEMsZ0JBQWdCO0lBQ2hCQyxjQUFjO0lBQ2R3SCxlQUFlO0lBQ2ZDLGdCQUFnQjtBQUNsQjtBQUNBLE1BQU01RCx3QkFBd0I7SUFDNUIsTUFBTTZEO0lBQ04sTUFBTXpWO0lBQ04sTUFBTTBWO0lBQ04sTUFBTUM7SUFDTixNQUFNQztJQUNOLE1BQU1DO0FBQ1I7QUFDQSxNQUFNQyxnQkFBZ0I7SUFDcEIsTUFBTTFiLGdEQUFhQTtJQUNuQixNQUFNMUIsK0NBQVlBO0lBQ2xCLE1BQU0yQiw2REFBMEJBO0lBQ2hDLE1BQU1DLDREQUF5QkE7SUFDL0IsTUFBTUMsNERBQXlCQTtJQUMvQixNQUFNNUIsMkRBQXdCQTtBQUNoQztBQUNBLE1BQU1vZCxrQkFBa0I7SUFDdEIsT0FBT3ZiLHNEQUFtQkE7SUFDMUIsT0FBT0MseURBQXNCQTtJQUM3QixPQUFPN0IsaURBQWNBO0FBQ3ZCO0FBQ0EsTUFBTW9kLG1CQUFtQjtJQUN2QkMsUUFBUTtJQUNSQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsTUFBTTtBQUNSO0FBQ0EsTUFBTWhGLGFBQWE7SUFDakJpRixVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsU0FBUztJQUNULDJCQUEyQjtJQUMzQixnREFBZ0Q7SUFDaEQsZ0RBQWdEO0lBQ2hELEdBQUd0YiwyREFBT0EsSUFBSSxNQUFNO1FBQ2xCdWIsWUFBWTtRQUNaQyxZQUFZO1FBQ1pDLFlBQVk7UUFDWkMsWUFBWTtJQUNkLElBQUk7UUFDRkgsWUFBWTtRQUNaQyxZQUFZO0lBQ2QsQ0FBQztJQUNERyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsVUFBVTtBQUNaO0FBQ0EsTUFBTUMsa0JBQWtCO0lBQ3RCaFAsT0FBTztJQUNQaVAsYUFBYTtJQUNiOUUsVUFBVTtJQUNWK0UsU0FBUztBQUNYO0FBQ0EsTUFBTUMsZ0JBQWdCO0lBQ3BCQyxhQUFhLEtBQUs7SUFDbEIsMEZBQTBGO0lBQzFGLHVGQUF1RjtJQUN2RnRDLFFBQVE3YSxvREFBaUJBO0lBQ3pCb2QsTUFBTTdjLHNEQUFtQkE7QUFDM0I7QUFDQSxNQUFNOGMsY0FBYztJQUNsQkMsUUFBUTtJQUNSQyxNQUFNO0lBQ05DLE9BQU87QUFDVDtBQUNBLFNBQVNDLHNCQUFzQmxVLEtBQUs7SUFDbEMsSUFBSUEsS0FBSyxDQUFDLGtCQUFrQixLQUFLLEtBQUssR0FBRztRQUN2Q0EsS0FBSyxDQUFDLGtCQUFrQixHQUFHLElBQUkxSyx1REFBb0JBLENBQUM7WUFDbEQ2TCxPQUFPO1lBQ1BnVCxVQUFVO1lBQ1ZDLFdBQVc7WUFDWEMsV0FBVztZQUNYQyxhQUFhO1lBQ2JDLFdBQVc7WUFDWEMsTUFBTXZkLDRDQUFTQTtRQUNqQjtJQUNGO0lBQ0EsT0FBTytJLEtBQUssQ0FBQyxrQkFBa0I7QUFDakM7QUFDQSxTQUFTeVUsK0JBQStCQyxlQUFlLEVBQUU5VixNQUFNLEVBQUUrVixTQUFTO0lBQ3hFLElBQUssTUFBTXZYLFFBQVF1WCxVQUFVMVksVUFBVSxDQUFFO1FBQ3ZDLElBQUl5WSxlQUFlLENBQUN0WCxLQUFLLEtBQUssS0FBSyxHQUFHO1lBQ3BDd0IsT0FBT2dXLFFBQVEsQ0FBQ0MsY0FBYyxHQUFHalcsT0FBT2dXLFFBQVEsQ0FBQ0MsY0FBYyxJQUFJLENBQUM7WUFDcEVqVyxPQUFPZ1csUUFBUSxDQUFDQyxjQUFjLENBQUN6WCxLQUFLLEdBQUd1WCxVQUFVMVksVUFBVSxDQUFDbUIsS0FBSztRQUNuRTtJQUNGO0FBQ0Y7QUFDQSxTQUFTK0UsdUJBQXVCdkQsTUFBTSxFQUFFa1csT0FBTztJQUM3QyxJQUFJQSxRQUFRQyxNQUFNLEtBQUssS0FBSyxHQUFHO1FBQzdCLElBQUksT0FBT0QsUUFBUUMsTUFBTSxLQUFLLFVBQVU7WUFDdENDLE9BQU9DLE1BQU0sQ0FBQ3JXLE9BQU9nVyxRQUFRLEVBQUVFLFFBQVFDLE1BQU07UUFDL0MsT0FBTztZQUNMdmEsUUFBUXdELElBQUksQ0FBQyx3REFBd0Q4VyxRQUFRQyxNQUFNO1FBQ3JGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNHLGdCQUFnQjlKLFFBQVEsRUFBRStKLE9BQU8sRUFBRTNjLE1BQU07SUFDaEQsSUFBSTRjLG1CQUFtQjtJQUN2QixJQUFJQyxpQkFBaUI7SUFDckIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUssSUFBSXJZLElBQUksR0FBR3NZLEtBQUtKLFFBQVFqWSxNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztRQUNoRCxNQUFNc0UsU0FBUzRULE9BQU8sQ0FBQ2xZLEVBQUU7UUFDekIsSUFBSXNFLE9BQU91UixRQUFRLEtBQUssS0FBSyxHQUMzQnNDLG1CQUFtQjtRQUNyQixJQUFJN1QsT0FBT3dSLE1BQU0sS0FBSyxLQUFLLEdBQ3pCc0MsaUJBQWlCO1FBQ25CLElBQUk5VCxPQUFPOFIsT0FBTyxLQUFLLEtBQUssR0FDMUJpQyxnQkFBZ0I7UUFDbEIsSUFBSUYsb0JBQW9CQyxrQkFBa0JDLGVBQ3hDO0lBQ0o7SUFDQSxJQUFJLENBQUNGLG9CQUFvQixDQUFDQyxrQkFBa0IsQ0FBQ0MsZUFDM0MsT0FBT2xYLFFBQVFDLE9BQU8sQ0FBQytNO0lBQ3pCLE1BQU1vSywyQkFBMkIsRUFBRTtJQUNuQyxNQUFNQyx5QkFBeUIsRUFBRTtJQUNqQyxNQUFNQyx3QkFBd0IsRUFBRTtJQUNoQyxJQUFLLElBQUl6WSxJQUFJLEdBQUdzWSxLQUFLSixRQUFRalksTUFBTSxFQUFFRCxJQUFJc1ksSUFBSXRZLElBQUs7UUFDaEQsTUFBTXNFLFNBQVM0VCxPQUFPLENBQUNsWSxFQUFFO1FBQ3pCLElBQUltWSxrQkFBa0I7WUFDcEIsTUFBTU8sa0JBQWtCcFUsT0FBT3VSLFFBQVEsS0FBSyxLQUFLLElBQUl0YSxPQUFPOEosYUFBYSxDQUFDLFlBQVlmLE9BQU91UixRQUFRLElBQUkxSCxTQUFTYixVQUFVLENBQUMvSSxRQUFRO1lBQ3JJZ1UseUJBQXlCM1osSUFBSSxDQUFDOFo7UUFDaEM7UUFDQSxJQUFJTixnQkFBZ0I7WUFDbEIsTUFBTU0sa0JBQWtCcFUsT0FBT3dSLE1BQU0sS0FBSyxLQUFLLElBQUl2YSxPQUFPOEosYUFBYSxDQUFDLFlBQVlmLE9BQU93UixNQUFNLElBQUkzSCxTQUFTYixVQUFVLENBQUNxTCxNQUFNO1lBQy9ISCx1QkFBdUI1WixJQUFJLENBQUM4WjtRQUM5QjtRQUNBLElBQUlMLGVBQWU7WUFDakIsTUFBTUssa0JBQWtCcFUsT0FBTzhSLE9BQU8sS0FBSyxLQUFLLElBQUk3YSxPQUFPOEosYUFBYSxDQUFDLFlBQVlmLE9BQU84UixPQUFPLElBQUlqSSxTQUFTYixVQUFVLENBQUNwSixLQUFLO1lBQ2hJdVUsc0JBQXNCN1osSUFBSSxDQUFDOFo7UUFDN0I7SUFDRjtJQUNBLE9BQU92WCxRQUFRc0YsR0FBRyxDQUFDO1FBQ2pCdEYsUUFBUXNGLEdBQUcsQ0FBQzhSO1FBQ1pwWCxRQUFRc0YsR0FBRyxDQUFDK1I7UUFDWnJYLFFBQVFzRixHQUFHLENBQUNnUztLQUNiLEVBQUVoVCxJQUFJLENBQUMsU0FBU3NMLFNBQVM7UUFDeEIsTUFBTTZILGlCQUFpQjdILFNBQVMsQ0FBQyxFQUFFO1FBQ25DLE1BQU04SCxlQUFlOUgsU0FBUyxDQUFDLEVBQUU7UUFDakMsTUFBTStILGNBQWMvSCxTQUFTLENBQUMsRUFBRTtRQUNoQyxJQUFJb0gsa0JBQ0ZoSyxTQUFTNEssZUFBZSxDQUFDeFUsUUFBUSxHQUFHcVU7UUFDdEMsSUFBSVIsZ0JBQ0ZqSyxTQUFTNEssZUFBZSxDQUFDSixNQUFNLEdBQUdFO1FBQ3BDLElBQUlSLGVBQ0ZsSyxTQUFTNEssZUFBZSxDQUFDN1UsS0FBSyxHQUFHNFU7UUFDbkMzSyxTQUFTNkssb0JBQW9CLEdBQUc7UUFDaEMsT0FBTzdLO0lBQ1Q7QUFDRjtBQUNBLFNBQVM4SyxtQkFBbUJyTSxJQUFJLEVBQUVDLE9BQU87SUFDdkNELEtBQUtxTSxrQkFBa0I7SUFDdkIsSUFBSXBNLFFBQVE0SixPQUFPLEtBQUssS0FBSyxHQUFHO1FBQzlCLElBQUssSUFBSXpXLElBQUksR0FBR3NZLEtBQUt6TCxRQUFRNEosT0FBTyxDQUFDeFcsTUFBTSxFQUFFRCxJQUFJc1ksSUFBSXRZLElBQUs7WUFDeEQ0TSxLQUFLc00scUJBQXFCLENBQUNsWixFQUFFLEdBQUc2TSxRQUFRNEosT0FBTyxDQUFDelcsRUFBRTtRQUNwRDtJQUNGO0lBQ0EsSUFBSTZNLFFBQVFpTCxNQUFNLElBQUkzUixNQUFNQyxPQUFPLENBQUN5RyxRQUFRaUwsTUFBTSxDQUFDcUIsV0FBVyxHQUFHO1FBQy9ELE1BQU1BLGNBQWN0TSxRQUFRaUwsTUFBTSxDQUFDcUIsV0FBVztRQUM5QyxJQUFJdk0sS0FBS3NNLHFCQUFxQixDQUFDalosTUFBTSxLQUFLa1osWUFBWWxaLE1BQU0sRUFBRTtZQUM1RDJNLEtBQUt3TSxxQkFBcUIsR0FBRyxDQUFDO1lBQzlCLElBQUssSUFBSXBaLElBQUksR0FBR3NZLEtBQUthLFlBQVlsWixNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztnQkFDcEQ0TSxLQUFLd00scUJBQXFCLENBQUNELFdBQVcsQ0FBQ25aLEVBQUUsQ0FBQyxHQUFHQTtZQUMvQztRQUNGLE9BQU87WUFDTHpDLFFBQVF3RCxJQUFJLENBQUM7UUFDZjtJQUNGO0FBQ0Y7QUFDQSxTQUFTc1ksbUJBQW1CQyxZQUFZO0lBQ3RDLElBQUlDO0lBQ0osTUFBTUMsaUJBQWlCRixhQUFhdGEsVUFBVSxJQUFJc2EsYUFBYXRhLFVBQVUsQ0FBQ1EsV0FBV2lCLDBCQUEwQixDQUFDO0lBQ2hILElBQUkrWSxnQkFBZ0I7UUFDbEJELGNBQWMsV0FBV0MsZUFBZWhPLFVBQVUsR0FBRyxNQUFNZ08sZUFBZUMsT0FBTyxHQUFHLE1BQU1DLG9CQUFvQkYsZUFBZWxNLFVBQVU7SUFDekksT0FBTztRQUNMaU0sY0FBY0QsYUFBYUcsT0FBTyxHQUFHLE1BQU1DLG9CQUFvQkosYUFBYWhNLFVBQVUsSUFBSSxNQUFNZ00sYUFBYWpOLElBQUk7SUFDbkg7SUFDQSxJQUFJaU4sYUFBYXBCLE9BQU8sS0FBSyxLQUFLLEdBQUc7UUFDbkMsSUFBSyxJQUFJbFksSUFBSSxHQUFHc1ksS0FBS2dCLGFBQWFwQixPQUFPLENBQUNqWSxNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztZQUM3RHVaLGVBQWUsTUFBTUcsb0JBQW9CSixhQUFhcEIsT0FBTyxDQUFDbFksRUFBRTtRQUNsRTtJQUNGO0lBQ0EsT0FBT3VaO0FBQ1Q7QUFDQSxTQUFTRyxvQkFBb0JwTSxVQUFVO0lBQ3JDLElBQUlxTSxnQkFBZ0I7SUFDcEIsTUFBTUMsT0FBTzdCLE9BQU82QixJQUFJLENBQUN0TSxZQUFZdU0sSUFBSTtJQUN6QyxJQUFLLElBQUk3WixJQUFJLEdBQUdzWSxLQUFLc0IsS0FBSzNaLE1BQU0sRUFBRUQsSUFBSXNZLElBQUl0WSxJQUFLO1FBQzdDMlosaUJBQWlCQyxJQUFJLENBQUM1WixFQUFFLEdBQUcsTUFBTXNOLFVBQVUsQ0FBQ3NNLElBQUksQ0FBQzVaLEVBQUUsQ0FBQyxHQUFHO0lBQ3pEO0lBQ0EsT0FBTzJaO0FBQ1Q7QUFDQSxTQUFTRyw0QkFBNEI5ZSxXQUFXO0lBQzlDLE9BQVFBO1FBQ04sS0FBSzhaO1lBQ0gsT0FBTyxJQUFJO1FBQ2IsS0FBS3pWO1lBQ0gsT0FBTyxJQUFJO1FBQ2IsS0FBSzBWO1lBQ0gsT0FBTyxJQUFJO1FBQ2IsS0FBS0M7WUFDSCxPQUFPLElBQUk7UUFDYjtZQUNFLE1BQU0sSUFBSXpXLE1BQU07SUFDcEI7QUFDRjtBQUNBLFNBQVN3YixvQkFBb0JsUCxHQUFHO0lBQzlCLElBQUlBLElBQUltUCxNQUFNLENBQUMsb0JBQW9CLEtBQUtuUCxJQUFJbVAsTUFBTSxDQUFDLDBCQUEwQixHQUMzRSxPQUFPO0lBQ1QsSUFBSW5QLElBQUltUCxNQUFNLENBQUMsbUJBQW1CLEtBQUtuUCxJQUFJbVAsTUFBTSxDQUFDLDBCQUEwQixHQUMxRSxPQUFPO0lBQ1QsT0FBTztBQUNUO0FBQ0EsTUFBTUMsa0JBQWtCLGFBQWEsR0FBRyxJQUFJN2lCLDBDQUFPQTtBQUNuRCxNQUFNeUk7SUFDSjdFLFlBQVkrRCxPQUFPLENBQUMsQ0FBQyxFQUFFd0wsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUNuQyxJQUFJLENBQUN4TCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxVQUFVLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQ3NMLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUN4SCxLQUFLLEdBQUcsSUFBSXpCO1FBQ2pCLElBQUksQ0FBQzRZLFlBQVksR0FBRyxhQUFhLEdBQUcsSUFBSUM7UUFDeEMsSUFBSSxDQUFDQyxjQUFjLEdBQUcsQ0FBQztRQUN2QixJQUFJLENBQUNDLFNBQVMsR0FBRyxDQUFDO1FBQ2xCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1lBQUV0WCxNQUFNLENBQUM7WUFBR0MsTUFBTSxDQUFDO1FBQUU7UUFDdEMsSUFBSSxDQUFDc1gsV0FBVyxHQUFHO1lBQUV2WCxNQUFNLENBQUM7WUFBR0MsTUFBTSxDQUFDO1FBQUU7UUFDeEMsSUFBSSxDQUFDdVgsVUFBVSxHQUFHO1lBQUV4WCxNQUFNLENBQUM7WUFBR0MsTUFBTSxDQUFDO1FBQUU7UUFDdkMsSUFBSSxDQUFDd1gsV0FBVyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUcsQ0FBQztRQUNyQixJQUFJLENBQUNDLGFBQWEsR0FBRyxDQUFDO1FBQ3RCLElBQUlDLFdBQVc7UUFDZixJQUFJQyxZQUFZO1FBQ2hCLElBQUlDLGlCQUFpQixDQUFDO1FBQ3RCLElBQUksT0FBT0MsY0FBYyxlQUFlLE9BQU9BLFVBQVVDLFNBQVMsS0FBSyxhQUFhO1lBQ2xGSixXQUFXLGlDQUFpQ0ssSUFBSSxDQUFDRixVQUFVQyxTQUFTLE1BQU07WUFDMUVILFlBQVlFLFVBQVVDLFNBQVMsQ0FBQ3JjLE9BQU8sQ0FBQyxhQUFhLENBQUM7WUFDdERtYyxpQkFBaUJELFlBQVlFLFVBQVVDLFNBQVMsQ0FBQ0UsS0FBSyxDQUFDLHNCQUFzQixDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ3RGO1FBQ0EsSUFBSSxPQUFPQyxzQkFBc0IsZUFBZVAsWUFBWUMsYUFBYUMsaUJBQWlCLElBQUk7WUFDNUYsSUFBSSxDQUFDbFEsYUFBYSxHQUFHLElBQUlsVCxnREFBYUEsQ0FBQyxJQUFJLENBQUM2UyxPQUFPLENBQUN0UCxPQUFPO1FBQzdELE9BQU87WUFDTCxJQUFJLENBQUMyUCxhQUFhLEdBQUcsSUFBSWpULG9EQUFpQkEsQ0FBQyxJQUFJLENBQUM0UyxPQUFPLENBQUN0UCxPQUFPO1FBQ2pFO1FBQ0EsSUFBSSxDQUFDMlAsYUFBYSxDQUFDd1EsY0FBYyxDQUFDLElBQUksQ0FBQzdRLE9BQU8sQ0FBQ3pLLFdBQVc7UUFDMUQsSUFBSSxDQUFDOEssYUFBYSxDQUFDOU0sZ0JBQWdCLENBQUMsSUFBSSxDQUFDeU0sT0FBTyxDQUFDeE0sYUFBYTtRQUM5RCxJQUFJLENBQUNnQyxVQUFVLEdBQUcsSUFBSW5KLDZDQUFVQSxDQUFDLElBQUksQ0FBQzJULE9BQU8sQ0FBQ3RQLE9BQU87UUFDckQsSUFBSSxDQUFDOEUsVUFBVSxDQUFDbEMsZUFBZSxDQUFDO1FBQ2hDLElBQUksSUFBSSxDQUFDME0sT0FBTyxDQUFDekssV0FBVyxLQUFLLG1CQUFtQjtZQUNsRCxJQUFJLENBQUNDLFVBQVUsQ0FBQy9CLGtCQUFrQixDQUFDO1FBQ3JDO0lBQ0Y7SUFDQWdELGNBQWNoQyxVQUFVLEVBQUU7UUFDeEIsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3BCO0lBQ0FpQyxXQUFXaEMsT0FBTyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUNBZCxNQUFNeEIsTUFBTSxFQUFFRSxPQUFPLEVBQUU7UUFDckIsTUFBTXRCLFNBQVMsSUFBSTtRQUNuQixNQUFNd0QsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTUMsYUFBYSxJQUFJLENBQUNBLFVBQVU7UUFDbEMsSUFBSSxDQUFDK0QsS0FBSyxDQUFDbEIsU0FBUztRQUNwQixJQUFJLENBQUN3WSxTQUFTLEdBQUcsQ0FBQztRQUNsQixJQUFJLENBQUNnQixVQUFVLENBQUMsU0FBU0MsR0FBRztZQUMxQixPQUFPQSxJQUFJcFksU0FBUyxJQUFJb1ksSUFBSXBZLFNBQVM7UUFDdkM7UUFDQS9CLFFBQVFzRixHQUFHLENBQ1QsSUFBSSxDQUFDNFUsVUFBVSxDQUFDLFNBQVNDLEdBQUc7WUFDMUIsT0FBT0EsSUFBSUMsVUFBVSxJQUFJRCxJQUFJQyxVQUFVO1FBQ3pDLElBQ0E5VixJQUFJLENBQUM7WUFDTCxPQUFPdEUsUUFBUXNGLEdBQUcsQ0FBQztnQkFDakJsTCxPQUFPaWdCLGVBQWUsQ0FBQztnQkFDdkJqZ0IsT0FBT2lnQixlQUFlLENBQUM7Z0JBQ3ZCamdCLE9BQU9pZ0IsZUFBZSxDQUFDO2FBQ3hCO1FBQ0gsR0FBRy9WLElBQUksQ0FBQyxTQUFTZ1csWUFBWTtZQUMzQixNQUFNaFAsU0FBUztnQkFDYmlQLE9BQU9ELFlBQVksQ0FBQyxFQUFFLENBQUMxYyxLQUFLMmMsS0FBSyxJQUFJLEVBQUU7Z0JBQ3ZDQyxRQUFRRixZQUFZLENBQUMsRUFBRTtnQkFDdkJHLFlBQVlILFlBQVksQ0FBQyxFQUFFO2dCQUMzQkksU0FBU0osWUFBWSxDQUFDLEVBQUU7Z0JBQ3hCN2IsT0FBT2IsS0FBS2EsS0FBSztnQkFDakJyRTtnQkFDQW9jLFVBQVUsQ0FBQztZQUNiO1lBQ0FILCtCQUErQnhZLFlBQVl5TixRQUFRMU47WUFDbkRtRyx1QkFBdUJ1SCxRQUFRMU47WUFDL0IsT0FBT29DLFFBQVFzRixHQUFHLENBQ2hCbEwsT0FBTzhmLFVBQVUsQ0FBQyxTQUFTQyxHQUFHO2dCQUM1QixPQUFPQSxJQUFJUSxTQUFTLElBQUlSLElBQUlRLFNBQVMsQ0FBQ3JQO1lBQ3hDLElBQ0FoSCxJQUFJLENBQUM7Z0JBQ0wsS0FBSyxNQUFNaVcsU0FBU2pQLE9BQU9rUCxNQUFNLENBQUU7b0JBQ2pDRCxNQUFNSyxpQkFBaUI7Z0JBQ3pCO2dCQUNBcGYsT0FBTzhQO1lBQ1Q7UUFDRixHQUFHdVAsS0FBSyxDQUFDbmY7SUFDWDtJQUNBOztHQUVDLEdBQ0RxRyxZQUFZO1FBQ1YsTUFBTUMsV0FBVyxJQUFJLENBQUNwRSxJQUFJLENBQUNxRSxLQUFLLElBQUksRUFBRTtRQUN0QyxNQUFNNlksV0FBVyxJQUFJLENBQUNsZCxJQUFJLENBQUNtZCxLQUFLLElBQUksRUFBRTtRQUN0QyxNQUFNQyxXQUFXLElBQUksQ0FBQ3BkLElBQUksQ0FBQytOLE1BQU0sSUFBSSxFQUFFO1FBQ3ZDLElBQUssSUFBSXNQLFlBQVksR0FBR0MsYUFBYUosU0FBU2hjLE1BQU0sRUFBRW1jLFlBQVlDLFlBQVlELFlBQWE7WUFDekYsTUFBTUUsU0FBU0wsUUFBUSxDQUFDRyxVQUFVLENBQUNFLE1BQU07WUFDekMsSUFBSyxJQUFJdGMsSUFBSSxHQUFHc1ksS0FBS2dFLE9BQU9yYyxNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztnQkFDL0NtRCxRQUFRLENBQUNtWixNQUFNLENBQUN0YyxFQUFFLENBQUMsQ0FBQ3VjLE1BQU0sR0FBRztZQUMvQjtRQUNGO1FBQ0EsSUFBSyxJQUFJbFosWUFBWSxHQUFHQyxhQUFhSCxTQUFTbEQsTUFBTSxFQUFFb0QsWUFBWUMsWUFBWUQsWUFBYTtZQUN6RixNQUFNRSxVQUFVSixRQUFRLENBQUNFLFVBQVU7WUFDbkMsSUFBSUUsUUFBUXFKLElBQUksS0FBSyxLQUFLLEdBQUc7Z0JBQzNCLElBQUksQ0FBQ25KLFdBQVcsQ0FBQyxJQUFJLENBQUM2VyxTQUFTLEVBQUUvVyxRQUFRcUosSUFBSTtnQkFDN0MsSUFBSXJKLFFBQVFpWixJQUFJLEtBQUssS0FBSyxHQUFHO29CQUMzQkwsUUFBUSxDQUFDNVksUUFBUXFKLElBQUksQ0FBQyxDQUFDNlAsYUFBYSxHQUFHO2dCQUN6QztZQUNGO1lBQ0EsSUFBSWxaLFFBQVFtWixNQUFNLEtBQUssS0FBSyxHQUFHO2dCQUM3QixJQUFJLENBQUNqWixXQUFXLENBQUMsSUFBSSxDQUFDOFcsV0FBVyxFQUFFaFgsUUFBUW1aLE1BQU07WUFDbkQ7UUFDRjtJQUNGO0lBQ0E7Ozs7Ozs7O0dBUUMsR0FDRGpaLFlBQVlWLEtBQUssRUFBRXVDLEtBQUssRUFBRTtRQUN4QixJQUFJQSxVQUFVLEtBQUssR0FDakI7UUFDRixJQUFJdkMsTUFBTUMsSUFBSSxDQUFDc0MsTUFBTSxLQUFLLEtBQUssR0FBRztZQUNoQ3ZDLE1BQU1DLElBQUksQ0FBQ3NDLE1BQU0sR0FBR3ZDLE1BQU1FLElBQUksQ0FBQ3FDLE1BQU0sR0FBRztRQUMxQztRQUNBdkMsTUFBTUMsSUFBSSxDQUFDc0MsTUFBTTtJQUNuQjtJQUNBLHVFQUF1RSxHQUN2RUksWUFBWTNDLEtBQUssRUFBRXVDLEtBQUssRUFBRTNELE1BQU0sRUFBRTtRQUNoQyxJQUFJb0IsTUFBTUMsSUFBSSxDQUFDc0MsTUFBTSxJQUFJLEdBQ3ZCLE9BQU8zRDtRQUNULE1BQU1nYixNQUFNaGIsT0FBT2dRLEtBQUs7UUFDeEIsTUFBTWlMLGlCQUFpQixDQUFDQyxVQUFVbEw7WUFDaEMsTUFBTW1MLFdBQVcsSUFBSSxDQUFDNUMsWUFBWSxDQUFDMVksR0FBRyxDQUFDcWI7WUFDdkMsSUFBSUMsWUFBWSxNQUFNO2dCQUNwQixJQUFJLENBQUM1QyxZQUFZLENBQUMxVixHQUFHLENBQUNtTixPQUFPbUw7WUFDL0I7WUFDQSxLQUFLLE1BQU0sQ0FBQzljLEdBQUcrYyxNQUFNLElBQUlGLFNBQVNqUCxRQUFRLENBQUNvUCxPQUFPLEdBQUk7Z0JBQ3BESixlQUFlRyxPQUFPcEwsTUFBTS9ELFFBQVEsQ0FBQzVOLEVBQUU7WUFDekM7UUFDRjtRQUNBNGMsZUFBZWpiLFFBQVFnYjtRQUN2QkEsSUFBSXhjLElBQUksSUFBSSxlQUFlNEMsTUFBTUUsSUFBSSxDQUFDcUMsTUFBTTtRQUM1QyxPQUFPcVg7SUFDVDtJQUNBTSxXQUFXQyxJQUFJLEVBQUU7UUFDZixNQUFNbGUsYUFBYStZLE9BQU8xRixNQUFNLENBQUMsSUFBSSxDQUFDcFQsT0FBTztRQUM3Q0QsV0FBV0osSUFBSSxDQUFDLElBQUk7UUFDcEIsSUFBSyxJQUFJb0IsSUFBSSxHQUFHQSxJQUFJaEIsV0FBV2lCLE1BQU0sRUFBRUQsSUFBSztZQUMxQyxNQUFNeU0sU0FBU3lRLEtBQUtsZSxVQUFVLENBQUNnQixFQUFFO1lBQ2pDLElBQUl5TSxRQUNGLE9BQU9BO1FBQ1g7UUFDQSxPQUFPO0lBQ1Q7SUFDQTRPLFdBQVc2QixJQUFJLEVBQUU7UUFDZixNQUFNbGUsYUFBYStZLE9BQU8xRixNQUFNLENBQUMsSUFBSSxDQUFDcFQsT0FBTztRQUM3Q0QsV0FBV21lLE9BQU8sQ0FBQyxJQUFJO1FBQ3ZCLE1BQU1wWCxVQUFVLEVBQUU7UUFDbEIsSUFBSyxJQUFJL0YsSUFBSSxHQUFHQSxJQUFJaEIsV0FBV2lCLE1BQU0sRUFBRUQsSUFBSztZQUMxQyxNQUFNeU0sU0FBU3lRLEtBQUtsZSxVQUFVLENBQUNnQixFQUFFO1lBQ2pDLElBQUl5TSxRQUNGMUcsUUFBUW5ILElBQUksQ0FBQzZOO1FBQ2pCO1FBQ0EsT0FBTzFHO0lBQ1Q7SUFDQTs7Ozs7R0FLQyxHQUNEVixjQUFjaEIsSUFBSSxFQUFFaUIsS0FBSyxFQUFFO1FBQ3pCLE1BQU0xQixXQUFXUyxPQUFPLE1BQU1pQjtRQUM5QixJQUFJekIsYUFBYSxJQUFJLENBQUNkLEtBQUssQ0FBQ3ZCLEdBQUcsQ0FBQ29DO1FBQ2hDLElBQUksQ0FBQ0MsWUFBWTtZQUNmLE9BQVFRO2dCQUNOLEtBQUs7b0JBQ0hSLGFBQWEsSUFBSSxDQUFDdVosU0FBUyxDQUFDOVg7b0JBQzVCO2dCQUNGLEtBQUs7b0JBQ0h6QixhQUFhLElBQUksQ0FBQ29aLFVBQVUsQ0FBQyxTQUFTM0IsR0FBRzt3QkFDdkMsT0FBT0EsSUFBSStCLFFBQVEsSUFBSS9CLElBQUkrQixRQUFRLENBQUMvWDtvQkFDdEM7b0JBQ0E7Z0JBQ0YsS0FBSztvQkFDSHpCLGFBQWEsSUFBSSxDQUFDb1osVUFBVSxDQUFDLFNBQVMzQixHQUFHO3dCQUN2QyxPQUFPQSxJQUFJZ0MsUUFBUSxJQUFJaEMsSUFBSWdDLFFBQVEsQ0FBQ2hZO29CQUN0QztvQkFDQTtnQkFDRixLQUFLO29CQUNIekIsYUFBYSxJQUFJLENBQUMwWixZQUFZLENBQUNqWTtvQkFDL0I7Z0JBQ0YsS0FBSztvQkFDSHpCLGFBQWEsSUFBSSxDQUFDb1osVUFBVSxDQUFDLFNBQVMzQixHQUFHO3dCQUN2QyxPQUFPQSxJQUFJL1AsY0FBYyxJQUFJK1AsSUFBSS9QLGNBQWMsQ0FBQ2pHO29CQUNsRDtvQkFDQTtnQkFDRixLQUFLO29CQUNIekIsYUFBYSxJQUFJLENBQUMyWixVQUFVLENBQUNsWTtvQkFDN0I7Z0JBQ0YsS0FBSztvQkFDSHpCLGFBQWEsSUFBSSxDQUFDb1osVUFBVSxDQUFDLFNBQVMzQixHQUFHO3dCQUN2QyxPQUFPQSxJQUFJbUMsWUFBWSxJQUFJbkMsSUFBSW1DLFlBQVksQ0FBQ25ZO29CQUM5QztvQkFDQTtnQkFDRixLQUFLO29CQUNIekIsYUFBYSxJQUFJLENBQUNvWixVQUFVLENBQUMsU0FBUzNCLEdBQUc7d0JBQ3ZDLE9BQU9BLElBQUluUixXQUFXLElBQUltUixJQUFJblIsV0FBVyxDQUFDN0U7b0JBQzVDO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0h6QixhQUFhLElBQUksQ0FBQzZaLFFBQVEsQ0FBQ3BZO29CQUMzQjtnQkFDRixLQUFLO29CQUNIekIsYUFBYSxJQUFJLENBQUNvWixVQUFVLENBQUMsU0FBUzNCLEdBQUc7d0JBQ3ZDLE9BQU9BLElBQUlxQyxhQUFhLElBQUlyQyxJQUFJcUMsYUFBYSxDQUFDclk7b0JBQ2hEO29CQUNBO2dCQUNGLEtBQUs7b0JBQ0h6QixhQUFhLElBQUksQ0FBQytaLFVBQVUsQ0FBQ3RZO29CQUM3QjtnQkFDRjtvQkFDRXpCLGFBQWEsSUFBSSxDQUFDb1osVUFBVSxDQUFDLFNBQVMzQixHQUFHO3dCQUN2QyxPQUFPQSxPQUFPLElBQUksSUFBSUEsSUFBSWpXLGFBQWEsSUFBSWlXLElBQUlqVyxhQUFhLENBQUNoQixNQUFNaUI7b0JBQ3JFO29CQUNBLElBQUksQ0FBQ3pCLFlBQVk7d0JBQ2YsTUFBTSxJQUFJdEYsTUFBTSxtQkFBbUI4RjtvQkFDckM7b0JBQ0E7WUFDSjtZQUNBLElBQUksQ0FBQ3RCLEtBQUssQ0FBQ3JCLEdBQUcsQ0FBQ2tDLFVBQVVDO1FBQzNCO1FBQ0EsT0FBT0E7SUFDVDtJQUNBOzs7O0dBSUMsR0FDRDJYLGdCQUFnQm5YLElBQUksRUFBRTtRQUNwQixJQUFJb1gsZUFBZSxJQUFJLENBQUMxWSxLQUFLLENBQUN2QixHQUFHLENBQUM2QztRQUNsQyxJQUFJLENBQUNvWCxjQUFjO1lBQ2pCLE1BQU1sZ0IsU0FBUyxJQUFJO1lBQ25CLE1BQU1zaUIsT0FBTyxJQUFJLENBQUM5ZSxJQUFJLENBQUNzRixPQUFRQSxDQUFBQSxTQUFTLFNBQVMsT0FBTyxHQUFFLEVBQUcsSUFBSSxFQUFFO1lBQ25Fb1gsZUFBZXRhLFFBQVFzRixHQUFHLENBQ3hCb1gsS0FBS0MsR0FBRyxDQUFDLFNBQVNDLEdBQUcsRUFBRXpZLEtBQUs7Z0JBQzFCLE9BQU8vSixPQUFPOEosYUFBYSxDQUFDaEIsTUFBTWlCO1lBQ3BDO1lBRUYsSUFBSSxDQUFDdkMsS0FBSyxDQUFDckIsR0FBRyxDQUFDMkMsTUFBTW9YO1FBQ3ZCO1FBQ0EsT0FBT0E7SUFDVDtJQUNBOzs7O0dBSUMsR0FDRCtCLFdBQVdRLFdBQVcsRUFBRTtRQUN0QixNQUFNQyxZQUFZLElBQUksQ0FBQ2xmLElBQUksQ0FBQ21mLE9BQU8sQ0FBQ0YsWUFBWTtRQUNoRCxNQUFNcmdCLFNBQVMsSUFBSSxDQUFDb0MsVUFBVTtRQUM5QixJQUFJa2UsVUFBVTVaLElBQUksSUFBSTRaLFVBQVU1WixJQUFJLEtBQUssZUFBZTtZQUN0RCxNQUFNLElBQUk5RixNQUFNLHVCQUF1QjBmLFVBQVU1WixJQUFJLEdBQUc7UUFDMUQ7UUFDQSxJQUFJNFosVUFBVXBULEdBQUcsS0FBSyxLQUFLLEtBQUttVCxnQkFBZ0IsR0FBRztZQUNqRCxPQUFPN2MsUUFBUUMsT0FBTyxDQUFDLElBQUksQ0FBQ3BDLFVBQVUsQ0FBQ1EsV0FBV0MsZUFBZSxDQUFDLENBQUNnUSxJQUFJO1FBQ3pFO1FBQ0EsTUFBTWxGLFVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBQzVCLE9BQU8sSUFBSXBKLFFBQVEsU0FBU0MsT0FBTyxFQUFFQyxNQUFNO1lBQ3pDMUQsT0FBT2xCLElBQUksQ0FBQzlGLDhDQUFXQSxDQUFDd0csVUFBVSxDQUFDOGdCLFVBQVVwVCxHQUFHLEVBQUVOLFFBQVF2TixJQUFJLEdBQUdvRSxTQUFTLEtBQUssR0FBRztnQkFDaEZDLE9BQU8sSUFBSTlDLE1BQU0sOENBQThDMGYsVUFBVXBULEdBQUcsR0FBRztZQUNqRjtRQUNGO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0RVLGVBQWUrRSxlQUFlLEVBQUU7UUFDOUIsTUFBTTZOLGdCQUFnQixJQUFJLENBQUNwZixJQUFJLENBQUMwTSxXQUFXLENBQUM2RSxnQkFBZ0I7UUFDNUQsT0FBTyxJQUFJLENBQUNqTCxhQUFhLENBQUMsVUFBVThZLGNBQWN4UyxNQUFNLEVBQUVsRyxJQUFJLENBQUMsU0FBU2tHLE1BQU07WUFDNUUsTUFBTUssYUFBYW1TLGNBQWNuUyxVQUFVLElBQUk7WUFDL0MsTUFBTUQsYUFBYW9TLGNBQWNwUyxVQUFVLElBQUk7WUFDL0MsT0FBT0osT0FBT3JNLEtBQUssQ0FBQ3lNLFlBQVlBLGFBQWFDO1FBQy9DO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0R1UixhQUFhYSxhQUFhLEVBQUU7UUFDMUIsTUFBTTdpQixTQUFTLElBQUk7UUFDbkIsTUFBTXdELE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU0rUixjQUFjLElBQUksQ0FBQy9SLElBQUksQ0FBQ2dTLFNBQVMsQ0FBQ3FOLGNBQWM7UUFDdEQsSUFBSXROLFlBQVl0RixVQUFVLEtBQUssS0FBSyxLQUFLc0YsWUFBWXVOLE1BQU0sS0FBSyxLQUFLLEdBQUc7WUFDdEUsTUFBTXZQLFdBQVd1RyxnQkFBZ0IsQ0FBQ3ZFLFlBQVl6TSxJQUFJLENBQUM7WUFDbkQsTUFBTWlhLGFBQWFyTixxQkFBcUIsQ0FBQ0gsWUFBWUUsYUFBYSxDQUFDO1lBQ25FLE1BQU1qQyxhQUFhK0IsWUFBWS9CLFVBQVUsS0FBSztZQUM5QyxNQUFNekksUUFBUSxJQUFJZ1ksV0FBV3hOLFlBQVk3RSxLQUFLLEdBQUc2QztZQUNqRCxPQUFPM04sUUFBUUMsT0FBTyxDQUFDLElBQUl4SixrREFBZUEsQ0FBQzBPLE9BQU93SSxVQUFVQztRQUM5RDtRQUNBLE1BQU13UCxxQkFBcUIsRUFBRTtRQUM3QixJQUFJek4sWUFBWXRGLFVBQVUsS0FBSyxLQUFLLEdBQUc7WUFDckMrUyxtQkFBbUIzZixJQUFJLENBQUMsSUFBSSxDQUFDeUcsYUFBYSxDQUFDLGNBQWN5TCxZQUFZdEYsVUFBVTtRQUNqRixPQUFPO1lBQ0wrUyxtQkFBbUIzZixJQUFJLENBQUM7UUFDMUI7UUFDQSxJQUFJa1MsWUFBWXVOLE1BQU0sS0FBSyxLQUFLLEdBQUc7WUFDakNFLG1CQUFtQjNmLElBQUksQ0FBQyxJQUFJLENBQUN5RyxhQUFhLENBQUMsY0FBY3lMLFlBQVl1TixNQUFNLENBQUM1RSxPQUFPLENBQUNqTyxVQUFVO1lBQzlGK1MsbUJBQW1CM2YsSUFBSSxDQUFDLElBQUksQ0FBQ3lHLGFBQWEsQ0FBQyxjQUFjeUwsWUFBWXVOLE1BQU0sQ0FBQ2hNLE1BQU0sQ0FBQzdHLFVBQVU7UUFDL0Y7UUFDQSxPQUFPckssUUFBUXNGLEdBQUcsQ0FBQzhYLG9CQUFvQjlZLElBQUksQ0FBQyxTQUFTZ0csV0FBVztZQUM5RCxNQUFNRCxhQUFhQyxXQUFXLENBQUMsRUFBRTtZQUNqQyxNQUFNcUQsV0FBV3VHLGdCQUFnQixDQUFDdkUsWUFBWXpNLElBQUksQ0FBQztZQUNuRCxNQUFNaWEsYUFBYXJOLHFCQUFxQixDQUFDSCxZQUFZRSxhQUFhLENBQUM7WUFDbkUsTUFBTXdOLGVBQWVGLFdBQVdHLGlCQUFpQjtZQUNqRCxNQUFNQyxZQUFZRixlQUFlMVA7WUFDakMsTUFBTS9DLGFBQWErRSxZQUFZL0UsVUFBVSxJQUFJO1lBQzdDLE1BQU1JLGFBQWEyRSxZQUFZdEYsVUFBVSxLQUFLLEtBQUssSUFBSXpNLEtBQUswTSxXQUFXLENBQUNxRixZQUFZdEYsVUFBVSxDQUFDLENBQUNXLFVBQVUsR0FBRyxLQUFLO1lBQ2xILE1BQU00QyxhQUFhK0IsWUFBWS9CLFVBQVUsS0FBSztZQUM5QyxJQUFJekksT0FBT3FZO1lBQ1gsSUFBSXhTLGNBQWNBLGVBQWV1UyxXQUFXO2dCQUMxQyxNQUFNRSxVQUFVL1osS0FBS2dhLEtBQUssQ0FBQzlTLGFBQWFJO2dCQUN4QyxNQUFNMlMsYUFBYSx1QkFBdUJoTyxZQUFZdEYsVUFBVSxHQUFHLE1BQU1zRixZQUFZRSxhQUFhLEdBQUcsTUFBTTROLFVBQVUsTUFBTTlOLFlBQVk3RSxLQUFLO2dCQUM1SSxJQUFJOFMsS0FBS3hqQixPQUFPd0gsS0FBSyxDQUFDdkIsR0FBRyxDQUFDc2Q7Z0JBQzFCLElBQUksQ0FBQ0MsSUFBSTtvQkFDUHpZLFFBQVEsSUFBSWdZLFdBQVc5UyxZQUFZb1QsVUFBVXpTLFlBQVkyRSxZQUFZN0UsS0FBSyxHQUFHRSxhQUFhcVM7b0JBQzFGTyxLQUFLLElBQUlsbkIsb0RBQWlCQSxDQUFDeU8sT0FBTzZGLGFBQWFxUztvQkFDL0NqakIsT0FBT3dILEtBQUssQ0FBQ3JCLEdBQUcsQ0FBQ29kLFlBQVlDO2dCQUMvQjtnQkFDQUosa0JBQWtCLElBQUk3bUIsNkRBQTBCQSxDQUM5Q2luQixJQUNBalEsVUFDQS9DLGFBQWFJLGFBQWFxUyxjQUMxQnpQO1lBRUosT0FBTztnQkFDTCxJQUFJdkQsZUFBZSxNQUFNO29CQUN2QmxGLFFBQVEsSUFBSWdZLFdBQVd4TixZQUFZN0UsS0FBSyxHQUFHNkM7Z0JBQzdDLE9BQU87b0JBQ0x4SSxRQUFRLElBQUlnWSxXQUFXOVMsWUFBWU8sWUFBWStFLFlBQVk3RSxLQUFLLEdBQUc2QztnQkFDckU7Z0JBQ0E2UCxrQkFBa0IsSUFBSS9tQixrREFBZUEsQ0FBQzBPLE9BQU93SSxVQUFVQztZQUN6RDtZQUNBLElBQUkrQixZQUFZdU4sTUFBTSxLQUFLLEtBQUssR0FBRztnQkFDakMsTUFBTVcsa0JBQWtCM0osaUJBQWlCQyxNQUFNO2dCQUMvQyxNQUFNMkosb0JBQW9CaE8scUJBQXFCLENBQUNILFlBQVl1TixNQUFNLENBQUM1RSxPQUFPLENBQUN6SSxhQUFhLENBQUM7Z0JBQ3pGLE1BQU1rTyxvQkFBb0JwTyxZQUFZdU4sTUFBTSxDQUFDNUUsT0FBTyxDQUFDMU4sVUFBVSxJQUFJO2dCQUNuRSxNQUFNb1QsbUJBQW1Cck8sWUFBWXVOLE1BQU0sQ0FBQ2hNLE1BQU0sQ0FBQ3RHLFVBQVUsSUFBSTtnQkFDakUsTUFBTXFULGdCQUFnQixJQUFJSCxrQkFDeEJ4VCxXQUFXLENBQUMsRUFBRSxFQUNkeVQsbUJBQ0FwTyxZQUFZdU4sTUFBTSxDQUFDcFMsS0FBSyxHQUFHK1M7Z0JBRTdCLE1BQU1LLGVBQWUsSUFBSWYsV0FBVzdTLFdBQVcsQ0FBQyxFQUFFLEVBQUUwVCxrQkFBa0JyTyxZQUFZdU4sTUFBTSxDQUFDcFMsS0FBSyxHQUFHNkM7Z0JBQ2pHLElBQUl0RCxlQUFlLE1BQU07b0JBQ3ZCbVQsa0JBQWtCLElBQUkvbUIsa0RBQWVBLENBQ25DK21CLGdCQUFnQnJZLEtBQUssQ0FBQ2hILEtBQUssSUFDM0JxZixnQkFBZ0I3UCxRQUFRLEVBQ3hCNlAsZ0JBQWdCNVAsVUFBVTtnQkFFOUI7Z0JBQ0EsSUFBSyxJQUFJL08sSUFBSSxHQUFHc1ksS0FBSzhHLGNBQWNuZixNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztvQkFDdEQsTUFBTXNGLFFBQVE4WixhQUFhLENBQUNwZixFQUFFO29CQUM5QjJlLGdCQUFnQlcsSUFBSSxDQUFDaGEsT0FBTytaLFlBQVksQ0FBQ3JmLElBQUk4TyxTQUFTO29CQUN0RCxJQUFJQSxZQUFZLEdBQ2Q2UCxnQkFBZ0JZLElBQUksQ0FBQ2phLE9BQU8rWixZQUFZLENBQUNyZixJQUFJOE8sV0FBVyxFQUFFO29CQUM1RCxJQUFJQSxZQUFZLEdBQ2Q2UCxnQkFBZ0JhLElBQUksQ0FBQ2xhLE9BQU8rWixZQUFZLENBQUNyZixJQUFJOE8sV0FBVyxFQUFFO29CQUM1RCxJQUFJQSxZQUFZLEdBQ2Q2UCxnQkFBZ0JjLElBQUksQ0FBQ25hLE9BQU8rWixZQUFZLENBQUNyZixJQUFJOE8sV0FBVyxFQUFFO29CQUM1RCxJQUFJQSxZQUFZLEdBQ2QsTUFBTSxJQUFJdlEsTUFBTTtnQkFDcEI7WUFDRjtZQUNBLE9BQU9vZ0I7UUFDVDtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNEeFUsWUFBWUMsWUFBWSxFQUFFO1FBQ3hCLE1BQU1yTCxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNd0wsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsTUFBTUYsYUFBYXRMLEtBQUt1TCxRQUFRLENBQUNGLGFBQWE7UUFDOUMsTUFBTXNWLGNBQWNyVixXQUFXSSxNQUFNO1FBQ3JDLE1BQU1rVixZQUFZNWdCLEtBQUs0TCxNQUFNLENBQUMrVSxZQUFZO1FBQzFDLElBQUkvaEIsU0FBUyxJQUFJLENBQUNpTixhQUFhO1FBQy9CLElBQUkrVSxVQUFVOVUsR0FBRyxFQUFFO1lBQ2pCLE1BQU1DLFVBQVVQLFFBQVF0UCxPQUFPLENBQUM4UCxVQUFVLENBQUM0VSxVQUFVOVUsR0FBRztZQUN4RCxJQUFJQyxZQUFZLE1BQ2RuTixTQUFTbU47UUFDYjtRQUNBLE9BQU8sSUFBSSxDQUFDTixnQkFBZ0IsQ0FBQ0osY0FBY3NWLGFBQWEvaEI7SUFDMUQ7SUFDQTZNLGlCQUFpQkosWUFBWSxFQUFFc1YsV0FBVyxFQUFFL2hCLE1BQU0sRUFBRTtRQUNsRCxNQUFNcEMsU0FBUyxJQUFJO1FBQ25CLE1BQU13RCxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNc0wsYUFBYXRMLEtBQUt1TCxRQUFRLENBQUNGLGFBQWE7UUFDOUMsTUFBTXVWLFlBQVk1Z0IsS0FBSzRMLE1BQU0sQ0FBQytVLFlBQVk7UUFDMUMsTUFBTTliLFdBQVcsQ0FBQytiLFVBQVU5VSxHQUFHLElBQUk4VSxVQUFVblUsVUFBVSxJQUFJLE1BQU1uQixXQUFXdVYsT0FBTztRQUNuRixJQUFJLElBQUksQ0FBQ2xGLFlBQVksQ0FBQzlXLFNBQVMsRUFBRTtZQUMvQixPQUFPLElBQUksQ0FBQzhXLFlBQVksQ0FBQzlXLFNBQVM7UUFDcEM7UUFDQSxNQUFNaWMsVUFBVSxJQUFJLENBQUNDLGVBQWUsQ0FBQ0osYUFBYS9oQixRQUFROEgsSUFBSSxDQUFDLFNBQVM0TCxPQUFPO1lBQzdFQSxRQUFRME8sS0FBSyxHQUFHO1lBQ2hCMU8sUUFBUWxSLElBQUksR0FBR2tLLFdBQVdsSyxJQUFJLElBQUl3ZixVQUFVeGYsSUFBSSxJQUFJO1lBQ3BELElBQUlrUixRQUFRbFIsSUFBSSxLQUFLLE1BQU0sT0FBT3dmLFVBQVU5VSxHQUFHLEtBQUssWUFBWThVLFVBQVU5VSxHQUFHLENBQUNtVixVQUFVLENBQUMsbUJBQW1CLE9BQU87Z0JBQ2pIM08sUUFBUWxSLElBQUksR0FBR3dmLFVBQVU5VSxHQUFHO1lBQzlCO1lBQ0EsTUFBTW9WLFdBQVdsaEIsS0FBS2toQixRQUFRLElBQUksQ0FBQztZQUNuQyxNQUFNTCxVQUFVSyxRQUFRLENBQUM1VixXQUFXdVYsT0FBTyxDQUFDLElBQUksQ0FBQztZQUNqRHZPLFFBQVE2TyxTQUFTLEdBQUcvSyxhQUFhLENBQUN5SyxRQUFRTSxTQUFTLENBQUMsSUFBSW5vQiwrQ0FBWUE7WUFDcEVzWixRQUFROE8sU0FBUyxHQUFHaEwsYUFBYSxDQUFDeUssUUFBUU8sU0FBUyxDQUFDLElBQUlub0IsMkRBQXdCQTtZQUNoRnFaLFFBQVErTyxLQUFLLEdBQUdoTCxlQUFlLENBQUN3SyxRQUFRUSxLQUFLLENBQUMsSUFBSW5vQixpREFBY0E7WUFDaEVvWixRQUFRZ1AsS0FBSyxHQUFHakwsZUFBZSxDQUFDd0ssUUFBUVMsS0FBSyxDQUFDLElBQUlwb0IsaURBQWNBO1lBQ2hFc0QsT0FBTzJlLFlBQVksQ0FBQzFWLEdBQUcsQ0FBQzZNLFNBQVM7Z0JBQUUvRyxVQUFVRjtZQUFhO1lBQzFELE9BQU9pSDtRQUNULEdBQUcySyxLQUFLLENBQUM7WUFDUCxPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUN0QixZQUFZLENBQUM5VyxTQUFTLEdBQUdpYztRQUM5QixPQUFPQTtJQUNUO0lBQ0FDLGdCQUFnQkosV0FBVyxFQUFFL2hCLE1BQU0sRUFBRTtRQUNuQyxNQUFNcEMsU0FBUyxJQUFJO1FBQ25CLE1BQU13RCxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNd0wsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsSUFBSSxJQUFJLENBQUNrUSxXQUFXLENBQUNpRixZQUFZLEtBQUssS0FBSyxHQUFHO1lBQzVDLE9BQU8sSUFBSSxDQUFDakYsV0FBVyxDQUFDaUYsWUFBWSxDQUFDamEsSUFBSSxDQUFDLENBQUM0TCxVQUFZQSxRQUFRTSxLQUFLO1FBQ3RFO1FBQ0EsTUFBTWdPLFlBQVk1Z0IsS0FBSzRMLE1BQU0sQ0FBQytVLFlBQVk7UUFDMUMsTUFBTVksTUFBTUMsS0FBS0QsR0FBRyxJQUFJQyxLQUFLQyxTQUFTO1FBQ3RDLElBQUlDLFlBQVlkLFVBQVU5VSxHQUFHLElBQUk7UUFDakMsSUFBSTZWLGNBQWM7UUFDbEIsSUFBSWYsVUFBVW5VLFVBQVUsS0FBSyxLQUFLLEdBQUc7WUFDbkNpVixZQUFZbGxCLE9BQU84SixhQUFhLENBQUMsY0FBY3NhLFVBQVVuVSxVQUFVLEVBQUUvRixJQUFJLENBQUMsU0FBUytGLFVBQVU7Z0JBQzNGa1YsY0FBYztnQkFDZCxNQUFNQyxPQUFPLElBQUlDLEtBQUs7b0JBQUNwVjtpQkFBVyxFQUFFO29CQUFFbkgsTUFBTXNiLFVBQVVrQixRQUFRO2dCQUFDO2dCQUMvREosWUFBWUgsSUFBSVEsZUFBZSxDQUFDSDtnQkFDaEMsT0FBT0Y7WUFDVDtRQUNGLE9BQU8sSUFBSWQsVUFBVTlVLEdBQUcsS0FBSyxLQUFLLEdBQUc7WUFDbkMsTUFBTSxJQUFJdE0sTUFBTSw2QkFBNkJtaEIsY0FBYztRQUM3RDtRQUNBLE1BQU1HLFVBQVUxZSxRQUFRQyxPQUFPLENBQUNxZixXQUFXaGIsSUFBSSxDQUFDLFNBQVNzYixVQUFVO1lBQ2pFLE9BQU8sSUFBSTVmLFFBQVEsU0FBU0MsT0FBTyxFQUFFQyxNQUFNO2dCQUN6QyxJQUFJMUUsU0FBU3lFO2dCQUNiLElBQUl6RCxPQUFPcWpCLG1CQUFtQixLQUFLLE1BQU07b0JBQ3ZDcmtCLFNBQVMsU0FBU3NrQixXQUFXO3dCQUMzQixNQUFNNVAsVUFBVSxJQUFJcFgsMENBQU9BLENBQUNnbkI7d0JBQzVCNVAsUUFBUVMsV0FBVyxHQUFHO3dCQUN0QjFRLFFBQVFpUTtvQkFDVjtnQkFDRjtnQkFDQTFULE9BQU9sQixJQUFJLENBQUM5Riw4Q0FBV0EsQ0FBQ3dHLFVBQVUsQ0FBQzRqQixZQUFZeFcsUUFBUXZOLElBQUksR0FBR0wsUUFBUSxLQUFLLEdBQUcwRTtZQUNoRjtRQUNGLEdBQUdvRSxJQUFJLENBQUMsU0FBUzRMLE9BQU87WUFDdEIsSUFBSXFQLGdCQUFnQixNQUFNO2dCQUN4QkosSUFBSVksZUFBZSxDQUFDVDtZQUN0QjtZQUNBdmIsdUJBQXVCbU0sU0FBU3NPO1lBQ2hDdE8sUUFBUXNHLFFBQVEsQ0FBQ2tKLFFBQVEsR0FBR2xCLFVBQVVrQixRQUFRLElBQUk5RyxvQkFBb0I0RixVQUFVOVUsR0FBRztZQUNuRixPQUFPd0c7UUFDVCxHQUFHMkssS0FBSyxDQUFDLFNBQVN4ZSxLQUFLO1lBQ3JCRCxRQUFRQyxLQUFLLENBQUMsMkNBQTJDaWpCO1lBQ3pELE1BQU1qakI7UUFDUjtRQUNBLElBQUksQ0FBQ2lkLFdBQVcsQ0FBQ2lGLFlBQVksR0FBR0c7UUFDaEMsT0FBT0E7SUFDVDtJQUNBOzs7Ozs7R0FNQyxHQUNEclosY0FBY1gsY0FBYyxFQUFFc2IsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsRUFBRTtRQUN6RCxNQUFNOWxCLFNBQVMsSUFBSTtRQUNuQixPQUFPLElBQUksQ0FBQzhKLGFBQWEsQ0FBQyxXQUFXK2IsT0FBTzliLEtBQUssRUFBRUcsSUFBSSxDQUFDLFNBQVM0TCxPQUFPO1lBQ3RFLElBQUksQ0FBQ0EsU0FDSCxPQUFPO1lBQ1QsSUFBSStQLE9BQU83UCxRQUFRLEtBQUssS0FBSyxLQUFLNlAsT0FBTzdQLFFBQVEsR0FBRyxHQUFHO2dCQUNyREYsVUFBVUEsUUFBUU0sS0FBSztnQkFDdkJOLFFBQVFHLE9BQU8sR0FBRzRQLE9BQU83UCxRQUFRO1lBQ25DO1lBQ0EsSUFBSWhXLE9BQU95RCxVQUFVLENBQUNRLFdBQVdtQixxQkFBcUIsQ0FBQyxFQUFFO2dCQUN2RCxNQUFNMlEsWUFBWThQLE9BQU9waUIsVUFBVSxLQUFLLEtBQUssSUFBSW9pQixPQUFPcGlCLFVBQVUsQ0FBQ1EsV0FBV21CLHFCQUFxQixDQUFDLEdBQUcsS0FBSztnQkFDNUcsSUFBSTJRLFdBQVc7b0JBQ2IsTUFBTWdRLGdCQUFnQi9sQixPQUFPMmUsWUFBWSxDQUFDMVksR0FBRyxDQUFDNlA7b0JBQzlDQSxVQUFVOVYsT0FBT3lELFVBQVUsQ0FBQ1EsV0FBV21CLHFCQUFxQixDQUFDLENBQUN5USxhQUFhLENBQUNDLFNBQVNDO29CQUNyRi9WLE9BQU8yZSxZQUFZLENBQUMxVixHQUFHLENBQUM2TSxTQUFTaVE7Z0JBQ25DO1lBQ0Y7WUFDQSxJQUFJRCxlQUFlLEtBQUssR0FBRztnQkFDekIsSUFBSSxPQUFPQSxlQUFlLFVBQ3hCQSxhQUFhQSxlQUFleG1CLGVBQWVGLGlCQUFpQkM7Z0JBQzlELElBQUksZ0JBQWdCeVcsU0FDbEJBLFFBQVFnUSxVQUFVLEdBQUdBO3FCQUVyQmhRLFFBQVFrUSxRQUFRLEdBQUdGLGVBQWUxbUIsaUJBQWlCRSxlQUFlQztZQUN0RTtZQUNBK0ssY0FBYyxDQUFDc2IsUUFBUSxHQUFHOVA7WUFDMUIsT0FBT0E7UUFDVDtJQUNGO0lBQ0E7Ozs7Ozs7R0FPQyxHQUNEakMsb0JBQW9CeEMsSUFBSSxFQUFFO1FBQ3hCLE1BQU11QixXQUFXdkIsS0FBS3VCLFFBQVE7UUFDOUIsSUFBSUMsV0FBV3hCLEtBQUt3QixRQUFRO1FBQzVCLE1BQU1vVCx3QkFBd0JyVCxTQUFTYixVQUFVLENBQUNtVSxPQUFPLEtBQUssS0FBSztRQUNuRSxNQUFNQyxrQkFBa0J2VCxTQUFTYixVQUFVLENBQUNwSixLQUFLLEtBQUssS0FBSztRQUMzRCxNQUFNeWQsaUJBQWlCeFQsU0FBU2IsVUFBVSxDQUFDcUwsTUFBTSxLQUFLLEtBQUs7UUFDM0QsSUFBSS9MLEtBQUtnVixRQUFRLEVBQUU7WUFDakIsTUFBTWhlLFdBQVcsb0JBQW9Cd0ssU0FBU3lULElBQUk7WUFDbEQsSUFBSUMsaUJBQWlCLElBQUksQ0FBQy9lLEtBQUssQ0FBQ3ZCLEdBQUcsQ0FBQ29DO1lBQ3BDLElBQUksQ0FBQ2tlLGdCQUFnQjtnQkFDbkJBLGlCQUFpQixJQUFJNXBCLGlEQUFjQTtnQkFDbkNDLDJDQUFRQSxDQUFDOFcsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksQ0FBQzJTLGdCQUFnQjFUO2dCQUM3QzBULGVBQWU1ZCxLQUFLLENBQUNnTCxJQUFJLENBQUNkLFNBQVNsSyxLQUFLO2dCQUN4QzRkLGVBQWVoRSxHQUFHLEdBQUcxUCxTQUFTMFAsR0FBRztnQkFDakNnRSxlQUFlQyxlQUFlLEdBQUc7Z0JBQ2pDLElBQUksQ0FBQ2hmLEtBQUssQ0FBQ3JCLEdBQUcsQ0FBQ2tDLFVBQVVrZTtZQUMzQjtZQUNBMVQsV0FBVzBUO1FBQ2IsT0FBTyxJQUFJbFYsS0FBS29WLE1BQU0sRUFBRTtZQUN0QixNQUFNcGUsV0FBVyx1QkFBdUJ3SyxTQUFTeVQsSUFBSTtZQUNyRCxJQUFJSSxlQUFlLElBQUksQ0FBQ2xmLEtBQUssQ0FBQ3ZCLEdBQUcsQ0FBQ29DO1lBQ2xDLElBQUksQ0FBQ3FlLGNBQWM7Z0JBQ2pCQSxlQUFlLElBQUk3cEIsb0RBQWlCQTtnQkFDcENELDJDQUFRQSxDQUFDOFcsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksQ0FBQzhTLGNBQWM3VDtnQkFDM0M2VCxhQUFhL2QsS0FBSyxDQUFDZ0wsSUFBSSxDQUFDZCxTQUFTbEssS0FBSztnQkFDdEMrZCxhQUFhbkUsR0FBRyxHQUFHMVAsU0FBUzBQLEdBQUc7Z0JBQy9CLElBQUksQ0FBQy9hLEtBQUssQ0FBQ3JCLEdBQUcsQ0FBQ2tDLFVBQVVxZTtZQUMzQjtZQUNBN1QsV0FBVzZUO1FBQ2I7UUFDQSxJQUFJVCx5QkFBeUJFLG1CQUFtQkMsZ0JBQWdCO1lBQzlELElBQUkvZCxXQUFXLG9CQUFvQndLLFNBQVN5VCxJQUFJLEdBQUc7WUFDbkQsSUFBSUwsdUJBQ0Y1ZCxZQUFZO1lBQ2QsSUFBSThkLGlCQUNGOWQsWUFBWTtZQUNkLElBQUkrZCxnQkFDRi9kLFlBQVk7WUFDZCxJQUFJc2UsaUJBQWlCLElBQUksQ0FBQ25mLEtBQUssQ0FBQ3ZCLEdBQUcsQ0FBQ29DO1lBQ3BDLElBQUksQ0FBQ3NlLGdCQUFnQjtnQkFDbkJBLGlCQUFpQjlULFNBQVN1RCxLQUFLO2dCQUMvQixJQUFJK1AsaUJBQ0ZRLGVBQWVDLFlBQVksR0FBRztnQkFDaEMsSUFBSVIsZ0JBQ0ZPLGVBQWVFLFdBQVcsR0FBRztnQkFDL0IsSUFBSVosdUJBQXVCO29CQUN6QixJQUFJVSxlQUFlRyxXQUFXLEVBQzVCSCxlQUFlRyxXQUFXLENBQUNDLENBQUMsSUFBSSxDQUFDO29CQUNuQyxJQUFJSixlQUFlMWEsb0JBQW9CLEVBQ3JDMGEsZUFBZTFhLG9CQUFvQixDQUFDOGEsQ0FBQyxJQUFJLENBQUM7Z0JBQzlDO2dCQUNBLElBQUksQ0FBQ3ZmLEtBQUssQ0FBQ3JCLEdBQUcsQ0FBQ2tDLFVBQVVzZTtnQkFDekIsSUFBSSxDQUFDaEksWUFBWSxDQUFDMVYsR0FBRyxDQUFDMGQsZ0JBQWdCLElBQUksQ0FBQ2hJLFlBQVksQ0FBQzFZLEdBQUcsQ0FBQzRNO1lBQzlEO1lBQ0FBLFdBQVc4VDtRQUNiO1FBQ0F0VixLQUFLd0IsUUFBUSxHQUFHQTtJQUNsQjtJQUNBekksa0JBQWtCO1FBQ2hCLE9BQU90Tix1REFBb0JBO0lBQzdCO0lBQ0E7Ozs7R0FJQyxHQUNEb2xCLGFBQWE5VyxhQUFhLEVBQUU7UUFDMUIsTUFBTXBMLFNBQVMsSUFBSTtRQUNuQixNQUFNd0QsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTUMsYUFBYSxJQUFJLENBQUNBLFVBQVU7UUFDbEMsTUFBTThHLGNBQWMvRyxLQUFLNkgsU0FBUyxDQUFDRCxjQUFjO1FBQ2pELElBQUk0YjtRQUNKLE1BQU0xYyxpQkFBaUIsQ0FBQztRQUN4QixNQUFNMmMscUJBQXFCMWMsWUFBWTlHLFVBQVUsSUFBSSxDQUFDO1FBQ3RELE1BQU0rRyxVQUFVLEVBQUU7UUFDbEIsSUFBSXljLGtCQUFrQixDQUFDaGpCLFdBQVdlLG1CQUFtQixDQUFDLEVBQUU7WUFDdEQsTUFBTWtpQixlQUFlempCLFVBQVUsQ0FBQ1EsV0FBV2UsbUJBQW1CLENBQUM7WUFDL0RnaUIsZUFBZUUsYUFBYTljLGVBQWU7WUFDM0NJLFFBQVFuSCxJQUFJLENBQUM2akIsYUFBYTdjLFlBQVksQ0FBQ0MsZ0JBQWdCQyxhQUFhdks7UUFDdEUsT0FBTztZQUNMLE1BQU0wSyxvQkFBb0JILFlBQVlJLG9CQUFvQixJQUFJLENBQUM7WUFDL0RMLGVBQWUzQixLQUFLLEdBQUcsSUFBSXJOLHdDQUFLQSxDQUFDLEdBQUcsR0FBRztZQUN2Q2dQLGVBQWVHLE9BQU8sR0FBRztZQUN6QixJQUFJRyxNQUFNQyxPQUFPLENBQUNILGtCQUFrQkksZUFBZSxHQUFHO2dCQUNwRCxNQUFNQyxRQUFRTCxrQkFBa0JJLGVBQWU7Z0JBQy9DUixlQUFlM0IsS0FBSyxDQUFDQyxNQUFNLENBQUNtQyxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFMUw7Z0JBQzFEaUwsZUFBZUcsT0FBTyxHQUFHTSxLQUFLLENBQUMsRUFBRTtZQUNuQztZQUNBLElBQUlMLGtCQUFrQk0sZ0JBQWdCLEtBQUssS0FBSyxHQUFHO2dCQUNqRFIsUUFBUW5ILElBQUksQ0FBQ3JELE9BQU9pTCxhQUFhLENBQUNYLGdCQUFnQixPQUFPSSxrQkFBa0JNLGdCQUFnQixFQUFFNUw7WUFDL0Y7WUFDQWtMLGVBQWVzUixTQUFTLEdBQUdsUixrQkFBa0J5YyxjQUFjLEtBQUssS0FBSyxJQUFJemMsa0JBQWtCeWMsY0FBYyxHQUFHO1lBQzVHN2MsZUFBZXVSLFNBQVMsR0FBR25SLGtCQUFrQjBjLGVBQWUsS0FBSyxLQUFLLElBQUkxYyxrQkFBa0IwYyxlQUFlLEdBQUc7WUFDOUcsSUFBSTFjLGtCQUFrQjJjLHdCQUF3QixLQUFLLEtBQUssR0FBRztnQkFDekQ3YyxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLGdCQUFnQkksa0JBQWtCMmMsd0JBQXdCO2dCQUM1RzdjLFFBQVFuSCxJQUFJLENBQUNyRCxPQUFPaUwsYUFBYSxDQUFDWCxnQkFBZ0IsZ0JBQWdCSSxrQkFBa0IyYyx3QkFBd0I7WUFDOUc7WUFDQUwsZUFBZSxJQUFJLENBQUN0RixVQUFVLENBQUMsU0FBUzNCLEdBQUc7Z0JBQ3pDLE9BQU9BLElBQUkzVixlQUFlLElBQUkyVixJQUFJM1YsZUFBZSxDQUFDZ0I7WUFDcEQ7WUFDQVosUUFBUW5ILElBQUksQ0FDVnVDLFFBQVFzRixHQUFHLENBQ1QsSUFBSSxDQUFDNFUsVUFBVSxDQUFDLFNBQVNDLEdBQUc7Z0JBQzFCLE9BQU9BLElBQUk1VSxvQkFBb0IsSUFBSTRVLElBQUk1VSxvQkFBb0IsQ0FBQ0MsZUFBZWQ7WUFDN0U7UUFHTjtRQUNBLElBQUlDLFlBQVkrYyxXQUFXLEtBQUssTUFBTTtZQUNwQ2hkLGVBQWUwUixJQUFJLEdBQUdqZiw2Q0FBVUE7UUFDbEM7UUFDQSxNQUFNd3FCLFlBQVloZCxZQUFZZ2QsU0FBUyxJQUFJak0sWUFBWUMsTUFBTTtRQUM3RCxJQUFJZ00sY0FBY2pNLFlBQVlHLEtBQUssRUFBRTtZQUNuQ25SLGVBQWV3UixXQUFXLEdBQUc7WUFDN0J4UixlQUFla2QsVUFBVSxHQUFHO1FBQzlCLE9BQU87WUFDTGxkLGVBQWV3UixXQUFXLEdBQUc7WUFDN0IsSUFBSXlMLGNBQWNqTSxZQUFZRSxJQUFJLEVBQUU7Z0JBQ2xDbFIsZUFBZW1kLFNBQVMsR0FBR2xkLFlBQVltZCxXQUFXLEtBQUssS0FBSyxJQUFJbmQsWUFBWW1kLFdBQVcsR0FBRztZQUM1RjtRQUNGO1FBQ0EsSUFBSW5kLFlBQVlvZCxhQUFhLEtBQUssS0FBSyxLQUFLWCxpQkFBaUJ0ckIsb0RBQWlCQSxFQUFFO1lBQzlFOE8sUUFBUW5ILElBQUksQ0FBQ3JELE9BQU9pTCxhQUFhLENBQUNYLGdCQUFnQixhQUFhQyxZQUFZb2QsYUFBYTtZQUN4RnJkLGVBQWV3YyxXQUFXLEdBQUcsSUFBSWxyQiwwQ0FBT0EsQ0FBQyxHQUFHO1lBQzVDLElBQUkyTyxZQUFZb2QsYUFBYSxDQUFDM2IsS0FBSyxLQUFLLEtBQUssR0FBRztnQkFDOUMsTUFBTUEsUUFBUXpCLFlBQVlvZCxhQUFhLENBQUMzYixLQUFLO2dCQUM3QzFCLGVBQWV3YyxXQUFXLENBQUM3ZCxHQUFHLENBQUMrQyxPQUFPQTtZQUN4QztRQUNGO1FBQ0EsSUFBSXpCLFlBQVlxZCxnQkFBZ0IsS0FBSyxLQUFLLEtBQUtaLGlCQUFpQnRyQixvREFBaUJBLEVBQUU7WUFDakY4TyxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT2lMLGFBQWEsQ0FBQ1gsZ0JBQWdCLFNBQVNDLFlBQVlxZCxnQkFBZ0I7WUFDdkYsSUFBSXJkLFlBQVlxZCxnQkFBZ0IsQ0FBQ0MsUUFBUSxLQUFLLEtBQUssR0FBRztnQkFDcER2ZCxlQUFld2QsY0FBYyxHQUFHdmQsWUFBWXFkLGdCQUFnQixDQUFDQyxRQUFRO1lBQ3ZFO1FBQ0Y7UUFDQSxJQUFJdGQsWUFBWXdkLGNBQWMsS0FBSyxLQUFLLEtBQUtmLGlCQUFpQnRyQixvREFBaUJBLEVBQUU7WUFDL0UsTUFBTXFzQixpQkFBaUJ4ZCxZQUFZd2QsY0FBYztZQUNqRHpkLGVBQWVxUixRQUFRLEdBQUcsSUFBSXJnQix3Q0FBS0EsR0FBR3NOLE1BQU0sQ0FDMUNtZixjQUFjLENBQUMsRUFBRSxFQUNqQkEsY0FBYyxDQUFDLEVBQUUsRUFDakJBLGNBQWMsQ0FBQyxFQUFFLEVBQ2pCMW9CO1FBRUo7UUFDQSxJQUFJa0wsWUFBWXlkLGVBQWUsS0FBSyxLQUFLLEtBQUtoQixpQkFBaUJ0ckIsb0RBQWlCQSxFQUFFO1lBQ2hGOE8sUUFBUW5ILElBQUksQ0FBQ3JELE9BQU9pTCxhQUFhLENBQUNYLGdCQUFnQixlQUFlQyxZQUFZeWQsZUFBZSxFQUFFNW9CO1FBQ2hHO1FBQ0EsT0FBT3dHLFFBQVFzRixHQUFHLENBQUNWLFNBQVNOLElBQUksQ0FBQztZQUMvQixNQUFNMkksV0FBVyxJQUFJbVUsYUFBYTFjO1lBQ2xDLElBQUlDLFlBQVkzRixJQUFJLEVBQ2xCaU8sU0FBU2pPLElBQUksR0FBRzJGLFlBQVkzRixJQUFJO1lBQ2xDK0UsdUJBQXVCa0osVUFBVXRJO1lBQ2pDdkssT0FBTzJlLFlBQVksQ0FBQzFWLEdBQUcsQ0FBQzRKLFVBQVU7Z0JBQUV4SCxXQUFXRDtZQUFjO1lBQzdELElBQUliLFlBQVk5RyxVQUFVLEVBQ3hCd1ksK0JBQStCeFksWUFBWW9QLFVBQVV0STtZQUN2RCxPQUFPc0k7UUFDVDtJQUNGO0lBQ0EsK0VBQStFLEdBQy9FaEosaUJBQWlCb2UsWUFBWSxFQUFFO1FBQzdCLE1BQU1DLGdCQUFnQmxyQixrREFBZUEsQ0FBQ21yQixnQkFBZ0IsQ0FBQ0YsZ0JBQWdCO1FBQ3ZFLElBQUlDLGlCQUFpQixJQUFJLENBQUM5SSxhQUFhLEVBQUU7WUFDdkMsT0FBTzhJLGdCQUFnQixNQUFNLEVBQUUsSUFBSSxDQUFDOUksYUFBYSxDQUFDOEksY0FBYztRQUNsRSxPQUFPO1lBQ0wsSUFBSSxDQUFDOUksYUFBYSxDQUFDOEksY0FBYyxHQUFHO1lBQ3BDLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBOzs7Ozs7O0dBT0MsR0FDREUsZUFBZTNXLFVBQVUsRUFBRTtRQUN6QixNQUFNelIsU0FBUyxJQUFJO1FBQ25CLE1BQU15RCxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQyxNQUFNK0QsUUFBUSxJQUFJLENBQUNxWCxjQUFjO1FBQ2pDLFNBQVN3SixxQkFBcUI3VyxTQUFTO1lBQ3JDLE9BQU8vTixVQUFVLENBQUNRLFdBQVdpQiwwQkFBMEIsQ0FBQyxDQUFDNFAsZUFBZSxDQUFDdEQsV0FBV3hSLFFBQVFrSyxJQUFJLENBQUMsU0FBUzBJLFFBQVE7Z0JBQ2hILE9BQU8wVix1QkFBdUIxVixVQUFVcEIsV0FBV3hSO1lBQ3JEO1FBQ0Y7UUFDQSxNQUFNd0ssVUFBVSxFQUFFO1FBQ2xCLElBQUssSUFBSS9GLElBQUksR0FBR3NZLEtBQUt0TCxXQUFXL00sTUFBTSxFQUFFRCxJQUFJc1ksSUFBSXRZLElBQUs7WUFDbkQsTUFBTStNLFlBQVlDLFVBQVUsQ0FBQ2hOLEVBQUU7WUFDL0IsTUFBTTRELFdBQVd5VixtQkFBbUJ0TTtZQUNwQyxNQUFNK1csU0FBUy9nQixLQUFLLENBQUNhLFNBQVM7WUFDOUIsSUFBSWtnQixRQUFRO2dCQUNWL2QsUUFBUW5ILElBQUksQ0FBQ2tsQixPQUFPakUsT0FBTztZQUM3QixPQUFPO2dCQUNMLElBQUlrRTtnQkFDSixJQUFJaFgsVUFBVS9OLFVBQVUsSUFBSStOLFVBQVUvTixVQUFVLENBQUNRLFdBQVdpQiwwQkFBMEIsQ0FBQyxFQUFFO29CQUN2RnNqQixrQkFBa0JILHFCQUFxQjdXO2dCQUN6QyxPQUFPO29CQUNMZ1gsa0JBQWtCRix1QkFBdUIsSUFBSXJyQixpREFBY0EsSUFBSXVVLFdBQVd4UjtnQkFDNUU7Z0JBQ0F3SCxLQUFLLENBQUNhLFNBQVMsR0FBRztvQkFBRW1KO29CQUFXOFMsU0FBU2tFO2dCQUFnQjtnQkFDeERoZSxRQUFRbkgsSUFBSSxDQUFDbWxCO1lBQ2Y7UUFDRjtRQUNBLE9BQU81aUIsUUFBUXNGLEdBQUcsQ0FBQ1Y7SUFDckI7SUFDQTs7OztHQUlDLEdBQ0R1WCxTQUFTMEcsU0FBUyxFQUFFO1FBQ2xCLE1BQU16b0IsU0FBUyxJQUFJO1FBQ25CLE1BQU13RCxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNQyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQyxNQUFNNk4sVUFBVTlOLEtBQUsrTixNQUFNLENBQUNrWCxVQUFVO1FBQ3RDLE1BQU1oWCxhQUFhSCxRQUFRRyxVQUFVO1FBQ3JDLE1BQU1qSCxVQUFVLEVBQUU7UUFDbEIsSUFBSyxJQUFJL0YsSUFBSSxHQUFHc1ksS0FBS3RMLFdBQVcvTSxNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztZQUNuRCxNQUFNb08sV0FBV3BCLFVBQVUsQ0FBQ2hOLEVBQUUsQ0FBQ29PLFFBQVEsS0FBSyxLQUFLLElBQUk2SSxzQkFBc0IsSUFBSSxDQUFDbFUsS0FBSyxJQUFJLElBQUksQ0FBQ3NDLGFBQWEsQ0FBQyxZQUFZMkgsVUFBVSxDQUFDaE4sRUFBRSxDQUFDb08sUUFBUTtZQUM5SXJJLFFBQVFuSCxJQUFJLENBQUN3UDtRQUNmO1FBQ0FySSxRQUFRbkgsSUFBSSxDQUFDckQsT0FBT29vQixjQUFjLENBQUMzVztRQUNuQyxPQUFPN0wsUUFBUXNGLEdBQUcsQ0FBQ1YsU0FBU04sSUFBSSxDQUFDLFNBQVMrSCxPQUFPO1lBQy9DLE1BQU01RyxZQUFZNEcsUUFBUWxPLEtBQUssQ0FBQyxHQUFHa08sUUFBUXZOLE1BQU0sR0FBRztZQUNwRCxNQUFNZ2tCLGFBQWF6VyxPQUFPLENBQUNBLFFBQVF2TixNQUFNLEdBQUcsRUFBRTtZQUM5QyxNQUFNNk0sU0FBUyxFQUFFO1lBQ2pCLElBQUssSUFBSTlNLElBQUksR0FBR3NZLEtBQUsyTCxXQUFXaGtCLE1BQU0sRUFBRUQsSUFBSXNZLElBQUl0WSxJQUFLO2dCQUNuRCxNQUFNbU8sV0FBVzhWLFVBQVUsQ0FBQ2prQixFQUFFO2dCQUM5QixNQUFNK00sWUFBWUMsVUFBVSxDQUFDaE4sRUFBRTtnQkFDL0IsSUFBSTRNO2dCQUNKLE1BQU13QixXQUFXeEgsU0FBUyxDQUFDNUcsRUFBRTtnQkFDN0IsSUFBSStNLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCQyxTQUFTLElBQUlILFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCRSxjQUFjLElBQUlKLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCRyxZQUFZLElBQUlMLFVBQVVWLElBQUksS0FBSyxLQUFLLEdBQUc7b0JBQ3JMTyxPQUFPQyxRQUFRNFAsYUFBYSxLQUFLLE9BQU8sSUFBSWhrQiw4Q0FBV0EsQ0FBQzBWLFVBQVVDLFlBQVksSUFBSTFWLHVDQUFJQSxDQUFDeVYsVUFBVUM7b0JBQ2pHLElBQUl4QixLQUFLNlAsYUFBYSxLQUFLLE1BQU07d0JBQy9CN1AsS0FBS3NYLG9CQUFvQjtvQkFDM0I7b0JBQ0EsSUFBSW5YLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCRSxjQUFjLEVBQUU7d0JBQ3JEUCxLQUFLdUIsUUFBUSxHQUFHM1Qsa0ZBQW1CQSxDQUFDb1MsS0FBS3VCLFFBQVEsRUFBRXhWLHdEQUFxQkE7b0JBQzFFLE9BQU8sSUFBSW9VLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCRyxZQUFZLEVBQUU7d0JBQzFEUixLQUFLdUIsUUFBUSxHQUFHM1Qsa0ZBQW1CQSxDQUFDb1MsS0FBS3VCLFFBQVEsRUFBRXZWLHNEQUFtQkE7b0JBQ3hFO2dCQUNGLE9BQU8sSUFBSW1VLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCd0gsS0FBSyxFQUFFO29CQUNuRDdILE9BQU8sSUFBSS9ULCtDQUFZQSxDQUFDc1YsVUFBVUM7Z0JBQ3BDLE9BQU8sSUFBSXJCLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCMEgsVUFBVSxFQUFFO29CQUN4RC9ILE9BQU8sSUFBSTlULHVDQUFJQSxDQUFDcVYsVUFBVUM7Z0JBQzVCLE9BQU8sSUFBSXJCLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCeUgsU0FBUyxFQUFFO29CQUN2RDlILE9BQU8sSUFBSTdULDJDQUFRQSxDQUFDb1YsVUFBVUM7Z0JBQ2hDLE9BQU8sSUFBSXJCLFVBQVVWLElBQUksS0FBS1ksZ0JBQWdCdUgsTUFBTSxFQUFFO29CQUNwRDVILE9BQU8sSUFBSTVULHlDQUFNQSxDQUFDbVYsVUFBVUM7Z0JBQzlCLE9BQU87b0JBQ0wsTUFBTSxJQUFJN1AsTUFBTSxtREFBbUR3TyxVQUFVVixJQUFJO2dCQUNuRjtnQkFDQSxJQUFJMEwsT0FBTzZCLElBQUksQ0FBQ2hOLEtBQUt1QixRQUFRLENBQUM0SyxlQUFlLEVBQUU5WSxNQUFNLEdBQUcsR0FBRztvQkFDekRnWixtQkFBbUJyTSxNQUFNQztnQkFDM0I7Z0JBQ0FELEtBQUt6TSxJQUFJLEdBQUc1RSxPQUFPNkosZ0JBQWdCLENBQUN5SCxRQUFRMU0sSUFBSSxJQUFJLFVBQVU2akI7Z0JBQzlEOWUsdUJBQXVCMEgsTUFBTUM7Z0JBQzdCLElBQUlFLFVBQVUvTixVQUFVLEVBQ3RCd1ksK0JBQStCeFksWUFBWTROLE1BQU1HO2dCQUNuRHhSLE9BQU82VCxtQkFBbUIsQ0FBQ3hDO2dCQUMzQkUsT0FBT2xPLElBQUksQ0FBQ2dPO1lBQ2Q7WUFDQSxJQUFLLElBQUk1TSxJQUFJLEdBQUdzWSxLQUFLeEwsT0FBTzdNLE1BQU0sRUFBRUQsSUFBSXNZLElBQUl0WSxJQUFLO2dCQUMvQ3pFLE9BQU8yZSxZQUFZLENBQUMxVixHQUFHLENBQUNzSSxNQUFNLENBQUM5TSxFQUFFLEVBQUU7b0JBQ2pDOE0sUUFBUWtYO29CQUNSaFgsWUFBWWhOO2dCQUNkO1lBQ0Y7WUFDQSxJQUFJOE0sT0FBTzdNLE1BQU0sS0FBSyxHQUFHO2dCQUN2QixJQUFJNE0sUUFBUTdOLFVBQVUsRUFDcEJ3WSwrQkFBK0J4WSxZQUFZOE4sTUFBTSxDQUFDLEVBQUUsRUFBRUQ7Z0JBQ3hELE9BQU9DLE1BQU0sQ0FBQyxFQUFFO1lBQ2xCO1lBQ0EsTUFBTXFYLFFBQVEsSUFBSWxyQix3Q0FBS0E7WUFDdkIsSUFBSTRULFFBQVE3TixVQUFVLEVBQ3BCd1ksK0JBQStCeFksWUFBWW1sQixPQUFPdFg7WUFDcER0UixPQUFPMmUsWUFBWSxDQUFDMVYsR0FBRyxDQUFDMmYsT0FBTztnQkFBRXJYLFFBQVFrWDtZQUFVO1lBQ25ELElBQUssSUFBSWhrQixJQUFJLEdBQUdzWSxLQUFLeEwsT0FBTzdNLE1BQU0sRUFBRUQsSUFBSXNZLElBQUl0WSxJQUFLO2dCQUMvQ21rQixNQUFNemlCLEdBQUcsQ0FBQ29MLE1BQU0sQ0FBQzlNLEVBQUU7WUFDckI7WUFDQSxPQUFPbWtCO1FBQ1Q7SUFDRjtJQUNBOzs7O0dBSUMsR0FDRHZHLFdBQVd3RyxXQUFXLEVBQUU7UUFDdEIsSUFBSTFIO1FBQ0osTUFBTTJILFlBQVksSUFBSSxDQUFDdGxCLElBQUksQ0FBQzhjLE9BQU8sQ0FBQ3VJLFlBQVk7UUFDaEQsTUFBTUUsU0FBU0QsU0FBUyxDQUFDQSxVQUFVaGdCLElBQUksQ0FBQztRQUN4QyxJQUFJLENBQUNpZ0IsUUFBUTtZQUNYL21CLFFBQVF3RCxJQUFJLENBQUM7WUFDYjtRQUNGO1FBQ0EsSUFBSXNqQixVQUFVaGdCLElBQUksS0FBSyxlQUFlO1lBQ3BDcVksU0FBUyxJQUFJeGpCLG9EQUFpQkEsQ0FDNUJDLDRDQUFTQSxDQUFDb3JCLFFBQVEsQ0FBQ0QsT0FBT0UsSUFBSSxHQUM5QkYsT0FBT0csV0FBVyxJQUFJLEdBQ3RCSCxPQUFPSSxLQUFLLElBQUksR0FDaEJKLE9BQU9LLElBQUksSUFBSTtRQUVuQixPQUFPLElBQUlOLFVBQVVoZ0IsSUFBSSxLQUFLLGdCQUFnQjtZQUM1Q3FZLFNBQVMsSUFBSXRqQixxREFBa0JBLENBQUMsQ0FBQ2tyQixPQUFPTSxJQUFJLEVBQUVOLE9BQU9NLElBQUksRUFBRU4sT0FBT08sSUFBSSxFQUFFLENBQUNQLE9BQU9PLElBQUksRUFBRVAsT0FBT0ksS0FBSyxFQUFFSixPQUFPSyxJQUFJO1FBQ2pIO1FBQ0EsSUFBSU4sVUFBVWxrQixJQUFJLEVBQ2hCdWMsT0FBT3ZjLElBQUksR0FBRyxJQUFJLENBQUNpRixnQkFBZ0IsQ0FBQ2lmLFVBQVVsa0IsSUFBSTtRQUNwRCtFLHVCQUF1QndYLFFBQVEySDtRQUMvQixPQUFPbGpCLFFBQVFDLE9BQU8sQ0FBQ3NiO0lBQ3pCO0lBQ0E7Ozs7R0FJQyxHQUNEZ0IsU0FBU3RCLFNBQVMsRUFBRTtRQUNsQixNQUFNMEksVUFBVSxJQUFJLENBQUMvbEIsSUFBSSxDQUFDbWQsS0FBSyxDQUFDRSxVQUFVO1FBQzFDLE1BQU1yVyxVQUFVLEVBQUU7UUFDbEIsSUFBSyxJQUFJL0YsSUFBSSxHQUFHc1ksS0FBS3dNLFFBQVF4SSxNQUFNLENBQUNyYyxNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztZQUN2RCtGLFFBQVFuSCxJQUFJLENBQUMsSUFBSSxDQUFDbW1CLGdCQUFnQixDQUFDRCxRQUFReEksTUFBTSxDQUFDdGMsRUFBRTtRQUN0RDtRQUNBLElBQUk4a0IsUUFBUUUsbUJBQW1CLEtBQUssS0FBSyxHQUFHO1lBQzFDamYsUUFBUW5ILElBQUksQ0FBQyxJQUFJLENBQUN5RyxhQUFhLENBQUMsWUFBWXlmLFFBQVFFLG1CQUFtQjtRQUN6RSxPQUFPO1lBQ0xqZixRQUFRbkgsSUFBSSxDQUFDO1FBQ2Y7UUFDQSxPQUFPdUMsUUFBUXNGLEdBQUcsQ0FBQ1YsU0FBU04sSUFBSSxDQUFDLFNBQVMrSCxPQUFPO1lBQy9DLE1BQU13WCxzQkFBc0J4WCxRQUFRRSxHQUFHO1lBQ3ZDLE1BQU11WCxhQUFhelg7WUFDbkIsTUFBTTBYLFFBQVEsRUFBRTtZQUNoQixNQUFNQyxlQUFlLEVBQUU7WUFDdkIsSUFBSyxJQUFJbmxCLElBQUksR0FBR3NZLEtBQUsyTSxXQUFXaGxCLE1BQU0sRUFBRUQsSUFBSXNZLElBQUl0WSxJQUFLO2dCQUNuRCxNQUFNb2xCLFlBQVlILFVBQVUsQ0FBQ2psQixFQUFFO2dCQUMvQixJQUFJb2xCLFdBQVc7b0JBQ2JGLE1BQU10bUIsSUFBSSxDQUFDd21CO29CQUNYLE1BQU1DLE1BQU0sSUFBSWp1QiwwQ0FBT0E7b0JBQ3ZCLElBQUk0dEIsd0JBQXdCLE1BQU07d0JBQ2hDSyxJQUFJelQsU0FBUyxDQUFDb1Qsb0JBQW9CMWUsS0FBSyxFQUFFdEcsSUFBSTtvQkFDL0M7b0JBQ0FtbEIsYUFBYXZtQixJQUFJLENBQUN5bUI7Z0JBQ3BCLE9BQU87b0JBQ0w5bkIsUUFBUXdELElBQUksQ0FBQyxvREFBb0QrakIsUUFBUXhJLE1BQU0sQ0FBQ3RjLEVBQUU7Z0JBQ3BGO1lBQ0Y7WUFDQSxPQUFPLElBQUkzRywyQ0FBUUEsQ0FBQzZyQixPQUFPQztRQUM3QjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNEeEgsY0FBYzJILGNBQWMsRUFBRTtRQUM1QixNQUFNdm1CLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU14RCxTQUFTLElBQUk7UUFDbkIsTUFBTWdxQixlQUFleG1CLEtBQUs2YyxVQUFVLENBQUMwSixlQUFlO1FBQ3BELE1BQU1FLGdCQUFnQkQsYUFBYXBsQixJQUFJLEdBQUdvbEIsYUFBYXBsQixJQUFJLEdBQUcsZUFBZW1sQjtRQUM3RSxNQUFNRyxlQUFlLEVBQUU7UUFDdkIsTUFBTUMsd0JBQXdCLEVBQUU7UUFDaEMsTUFBTUMseUJBQXlCLEVBQUU7UUFDakMsTUFBTUMsa0JBQWtCLEVBQUU7UUFDMUIsTUFBTUMsaUJBQWlCLEVBQUU7UUFDekIsSUFBSyxJQUFJN2xCLElBQUksR0FBR3NZLEtBQUtpTixhQUFhTyxRQUFRLENBQUM3bEIsTUFBTSxFQUFFRCxJQUFJc1ksSUFBSXRZLElBQUs7WUFDOUQsTUFBTXdSLFVBQVUrVCxhQUFhTyxRQUFRLENBQUM5bEIsRUFBRTtZQUN4QyxNQUFNNGYsVUFBVTJGLGFBQWF0RixRQUFRLENBQUN6TyxRQUFRb08sT0FBTyxDQUFDO1lBQ3RELE1BQU10YixTQUFTa04sUUFBUWxOLE1BQU07WUFDN0IsTUFBTW5FLE9BQU9tRSxPQUFPeWhCLElBQUk7WUFDeEIsTUFBTUMsUUFBUVQsYUFBYVUsVUFBVSxLQUFLLEtBQUssSUFBSVYsYUFBYVUsVUFBVSxDQUFDckcsUUFBUW9HLEtBQUssQ0FBQyxHQUFHcEcsUUFBUW9HLEtBQUs7WUFDekcsTUFBTUUsU0FBU1gsYUFBYVUsVUFBVSxLQUFLLEtBQUssSUFBSVYsYUFBYVUsVUFBVSxDQUFDckcsUUFBUXNHLE1BQU0sQ0FBQyxHQUFHdEcsUUFBUXNHLE1BQU07WUFDNUcsSUFBSTVoQixPQUFPeWhCLElBQUksS0FBSyxLQUFLLEdBQ3ZCO1lBQ0ZOLGFBQWE3bUIsSUFBSSxDQUFDLElBQUksQ0FBQ3lHLGFBQWEsQ0FBQyxRQUFRbEY7WUFDN0N1bEIsc0JBQXNCOW1CLElBQUksQ0FBQyxJQUFJLENBQUN5RyxhQUFhLENBQUMsWUFBWTJnQjtZQUMxREwsdUJBQXVCL21CLElBQUksQ0FBQyxJQUFJLENBQUN5RyxhQUFhLENBQUMsWUFBWTZnQjtZQUMzRE4sZ0JBQWdCaG5CLElBQUksQ0FBQ2doQjtZQUNyQmlHLGVBQWVqbkIsSUFBSSxDQUFDMEY7UUFDdEI7UUFDQSxPQUFPbkQsUUFBUXNGLEdBQUcsQ0FBQztZQUNqQnRGLFFBQVFzRixHQUFHLENBQUNnZjtZQUNadGtCLFFBQVFzRixHQUFHLENBQUNpZjtZQUNadmtCLFFBQVFzRixHQUFHLENBQUNrZjtZQUNaeGtCLFFBQVFzRixHQUFHLENBQUNtZjtZQUNaemtCLFFBQVFzRixHQUFHLENBQUNvZjtTQUNiLEVBQUVwZ0IsSUFBSSxDQUFDLFNBQVNnVyxZQUFZO1lBQzNCLE1BQU1yWSxRQUFRcVksWUFBWSxDQUFDLEVBQUU7WUFDN0IsTUFBTTBLLGlCQUFpQjFLLFlBQVksQ0FBQyxFQUFFO1lBQ3RDLE1BQU0ySyxrQkFBa0IzSyxZQUFZLENBQUMsRUFBRTtZQUN2QyxNQUFNd0UsV0FBV3hFLFlBQVksQ0FBQyxFQUFFO1lBQ2hDLE1BQU12RCxVQUFVdUQsWUFBWSxDQUFDLEVBQUU7WUFDL0IsTUFBTTRLLFNBQVMsRUFBRTtZQUNqQixJQUFLLElBQUlybUIsSUFBSSxHQUFHc1ksS0FBS2xWLE1BQU1uRCxNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztnQkFDOUMsTUFBTStsQixPQUFPM2lCLEtBQUssQ0FBQ3BELEVBQUU7Z0JBQ3JCLE1BQU1zbUIsZ0JBQWdCSCxjQUFjLENBQUNubUIsRUFBRTtnQkFDdkMsTUFBTXVtQixpQkFBaUJILGVBQWUsQ0FBQ3BtQixFQUFFO2dCQUN6QyxNQUFNNGYsVUFBVUssUUFBUSxDQUFDamdCLEVBQUU7Z0JBQzNCLE1BQU1zRSxTQUFTNFQsT0FBTyxDQUFDbFksRUFBRTtnQkFDekIsSUFBSStsQixTQUFTLEtBQUssR0FDaEI7Z0JBQ0YsSUFBSUEsS0FBS1MsWUFBWSxFQUFFO29CQUNyQlQsS0FBS1MsWUFBWTtnQkFDbkI7Z0JBQ0EsTUFBTUMsZ0JBQWdCbHJCLE9BQU9tckIsc0JBQXNCLENBQUNYLE1BQU1PLGVBQWVDLGdCQUFnQjNHLFNBQVN0YjtnQkFDbEcsSUFBSW1pQixlQUFlO29CQUNqQixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUYsY0FBY3htQixNQUFNLEVBQUUwbUIsSUFBSzt3QkFDN0NOLE9BQU96bkIsSUFBSSxDQUFDNm5CLGFBQWEsQ0FBQ0UsRUFBRTtvQkFDOUI7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU8sSUFBSXJ0QixnREFBYUEsQ0FBQ2tzQixlQUFlLEtBQUssR0FBR2E7UUFDbEQ7SUFDRjtJQUNBMVosZUFBZXRKLFNBQVMsRUFBRTtRQUN4QixNQUFNdEUsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTXhELFNBQVMsSUFBSTtRQUNuQixNQUFNZ0ksVUFBVXhFLEtBQUtxRSxLQUFLLENBQUNDLFVBQVU7UUFDckMsSUFBSUUsUUFBUXFKLElBQUksS0FBSyxLQUFLLEdBQ3hCLE9BQU87UUFDVCxPQUFPclIsT0FBTzhKLGFBQWEsQ0FBQyxRQUFROUIsUUFBUXFKLElBQUksRUFBRW5ILElBQUksQ0FBQyxTQUFTbUgsSUFBSTtZQUNsRSxNQUFNbVosT0FBT3hxQixPQUFPbUssV0FBVyxDQUFDbkssT0FBTytlLFNBQVMsRUFBRS9XLFFBQVFxSixJQUFJLEVBQUVBO1lBQ2hFLElBQUlySixRQUFRa1QsT0FBTyxLQUFLLEtBQUssR0FBRztnQkFDOUJzUCxLQUFLYSxRQUFRLENBQUMsU0FBU0MsQ0FBQztvQkFDdEIsSUFBSSxDQUFDQSxFQUFFQyxNQUFNLEVBQ1g7b0JBQ0YsSUFBSyxJQUFJOW1CLElBQUksR0FBR3NZLEtBQUsvVSxRQUFRa1QsT0FBTyxDQUFDeFcsTUFBTSxFQUFFRCxJQUFJc1ksSUFBSXRZLElBQUs7d0JBQ3hENm1CLEVBQUUzTixxQkFBcUIsQ0FBQ2xaLEVBQUUsR0FBR3VELFFBQVFrVCxPQUFPLENBQUN6VyxFQUFFO29CQUNqRDtnQkFDRjtZQUNGO1lBQ0EsT0FBTytsQjtRQUNUO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0QxSSxTQUFTaGEsU0FBUyxFQUFFO1FBQ2xCLE1BQU10RSxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNeEQsU0FBUyxJQUFJO1FBQ25CLE1BQU1nSSxVQUFVeEUsS0FBS3FFLEtBQUssQ0FBQ0MsVUFBVTtRQUNyQyxNQUFNMGpCLGNBQWN4ckIsT0FBT3dwQixnQkFBZ0IsQ0FBQzFoQjtRQUM1QyxNQUFNMmpCLGVBQWUsRUFBRTtRQUN2QixNQUFNQyxjQUFjMWpCLFFBQVFxSyxRQUFRLElBQUksRUFBRTtRQUMxQyxJQUFLLElBQUk1TixJQUFJLEdBQUdzWSxLQUFLMk8sWUFBWWhuQixNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztZQUNwRGduQixhQUFhcG9CLElBQUksQ0FBQ3JELE9BQU84SixhQUFhLENBQUMsUUFBUTRoQixXQUFXLENBQUNqbkIsRUFBRTtRQUMvRDtRQUNBLE1BQU1rbkIsa0JBQWtCM2pCLFFBQVFpWixJQUFJLEtBQUssS0FBSyxJQUFJcmIsUUFBUUMsT0FBTyxDQUFDLFFBQVE3RixPQUFPOEosYUFBYSxDQUFDLFFBQVE5QixRQUFRaVosSUFBSTtRQUNuSCxPQUFPcmIsUUFBUXNGLEdBQUcsQ0FBQztZQUFDc2dCO1lBQWE1bEIsUUFBUXNGLEdBQUcsQ0FBQ3VnQjtZQUFlRTtTQUFnQixFQUFFemhCLElBQUksQ0FBQyxTQUFTK0gsT0FBTztZQUNqRyxNQUFNdVksT0FBT3ZZLE9BQU8sQ0FBQyxFQUFFO1lBQ3ZCLE1BQU1JLFdBQVdKLE9BQU8sQ0FBQyxFQUFFO1lBQzNCLE1BQU0yWixXQUFXM1osT0FBTyxDQUFDLEVBQUU7WUFDM0IsSUFBSTJaLGFBQWEsTUFBTTtnQkFDckJwQixLQUFLYSxRQUFRLENBQUMsU0FBU2hhLElBQUk7b0JBQ3pCLElBQUksQ0FBQ0EsS0FBSzZQLGFBQWEsRUFDckI7b0JBQ0Y3UCxLQUFLd2EsSUFBSSxDQUFDRCxVQUFVbE47Z0JBQ3RCO1lBQ0Y7WUFDQSxJQUFLLElBQUlqYSxJQUFJLEdBQUdzWSxLQUFLMUssU0FBUzNOLE1BQU0sRUFBRUQsSUFBSXNZLElBQUl0WSxJQUFLO2dCQUNqRCtsQixLQUFLcmtCLEdBQUcsQ0FBQ2tNLFFBQVEsQ0FBQzVOLEVBQUU7WUFDdEI7WUFDQSxPQUFPK2xCO1FBQ1Q7SUFDRjtJQUNBLDRDQUE0QztJQUM1Qyw2RUFBNkU7SUFDN0VoQixpQkFBaUIxaEIsU0FBUyxFQUFFO1FBQzFCLE1BQU10RSxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNQyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQyxNQUFNekQsU0FBUyxJQUFJO1FBQ25CLElBQUksSUFBSSxDQUFDOGUsU0FBUyxDQUFDaFgsVUFBVSxLQUFLLEtBQUssR0FBRztZQUN4QyxPQUFPLElBQUksQ0FBQ2dYLFNBQVMsQ0FBQ2hYLFVBQVU7UUFDbEM7UUFDQSxNQUFNRSxVQUFVeEUsS0FBS3FFLEtBQUssQ0FBQ0MsVUFBVTtRQUNyQyxNQUFNZ2tCLFdBQVc5akIsUUFBUXBELElBQUksR0FBRzVFLE9BQU82SixnQkFBZ0IsQ0FBQzdCLFFBQVFwRCxJQUFJLElBQUk7UUFDeEUsTUFBTTRGLFVBQVUsRUFBRTtRQUNsQixNQUFNdWhCLGNBQWMvckIsT0FBTzBoQixVQUFVLENBQUMsU0FBUzNCLEdBQUc7WUFDaEQsT0FBT0EsSUFBSTNPLGNBQWMsSUFBSTJPLElBQUkzTyxjQUFjLENBQUN0SjtRQUNsRDtRQUNBLElBQUlpa0IsYUFBYTtZQUNmdmhCLFFBQVFuSCxJQUFJLENBQUMwb0I7UUFDZjtRQUNBLElBQUkvakIsUUFBUW1aLE1BQU0sS0FBSyxLQUFLLEdBQUc7WUFDN0IzVyxRQUFRbkgsSUFBSSxDQUNWckQsT0FBTzhKLGFBQWEsQ0FBQyxVQUFVOUIsUUFBUW1aLE1BQU0sRUFBRWpYLElBQUksQ0FBQyxTQUFTaVgsTUFBTTtnQkFDakUsT0FBT25oQixPQUFPbUssV0FBVyxDQUFDbkssT0FBT2dmLFdBQVcsRUFBRWhYLFFBQVFtWixNQUFNLEVBQUVBO1lBQ2hFO1FBRUo7UUFDQW5oQixPQUFPOGYsVUFBVSxDQUFDLFNBQVNDLEdBQUc7WUFDNUIsT0FBT0EsSUFBSS9WLG9CQUFvQixJQUFJK1YsSUFBSS9WLG9CQUFvQixDQUFDbEM7UUFDOUQsR0FBR2trQixPQUFPLENBQUMsU0FBUzFILE9BQU87WUFDekI5WixRQUFRbkgsSUFBSSxDQUFDaWhCO1FBQ2Y7UUFDQSxJQUFJLENBQUN4RixTQUFTLENBQUNoWCxVQUFVLEdBQUdsQyxRQUFRc0YsR0FBRyxDQUFDVixTQUFTTixJQUFJLENBQUMsU0FBU2xFLE9BQU87WUFDcEUsSUFBSXdrQjtZQUNKLElBQUl4aUIsUUFBUWdaLE1BQU0sS0FBSyxNQUFNO2dCQUMzQndKLE9BQU8sSUFBSXhzQix1Q0FBSUE7WUFDakIsT0FBTyxJQUFJZ0ksUUFBUXRCLE1BQU0sR0FBRyxHQUFHO2dCQUM3QjhsQixPQUFPLElBQUk5c0Isd0NBQUtBO1lBQ2xCLE9BQU8sSUFBSXNJLFFBQVF0QixNQUFNLEtBQUssR0FBRztnQkFDL0I4bEIsT0FBT3hrQixPQUFPLENBQUMsRUFBRTtZQUNuQixPQUFPO2dCQUNMd2tCLE9BQU8sSUFBSXR1QiwyQ0FBUUE7WUFDckI7WUFDQSxJQUFJc3VCLFNBQVN4a0IsT0FBTyxDQUFDLEVBQUUsRUFBRTtnQkFDdkIsSUFBSyxJQUFJdkIsSUFBSSxHQUFHc1ksS0FBSy9XLFFBQVF0QixNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztvQkFDaEQrbEIsS0FBS3JrQixHQUFHLENBQUNILE9BQU8sQ0FBQ3ZCLEVBQUU7Z0JBQ3JCO1lBQ0Y7WUFDQSxJQUFJdUQsUUFBUXBELElBQUksRUFBRTtnQkFDaEI0bEIsS0FBS3BPLFFBQVEsQ0FBQ3hYLElBQUksR0FBR29ELFFBQVFwRCxJQUFJO2dCQUNqQzRsQixLQUFLNWxCLElBQUksR0FBR2tuQjtZQUNkO1lBQ0FuaUIsdUJBQXVCNmdCLE1BQU14aUI7WUFDN0IsSUFBSUEsUUFBUXZFLFVBQVUsRUFDcEJ3WSwrQkFBK0J4WSxZQUFZK21CLE1BQU14aUI7WUFDbkQsSUFBSUEsUUFBUWlrQixNQUFNLEtBQUssS0FBSyxHQUFHO2dCQUM3QixNQUFNQSxTQUFTLElBQUlwd0IsMENBQU9BO2dCQUMxQm93QixPQUFPNVYsU0FBUyxDQUFDck8sUUFBUWlrQixNQUFNO2dCQUMvQnpCLEtBQUswQixZQUFZLENBQUNEO1lBQ3BCLE9BQU87Z0JBQ0wsSUFBSWprQixRQUFRaVQsV0FBVyxLQUFLLEtBQUssR0FBRztvQkFDbEN1UCxLQUFLeGhCLFFBQVEsQ0FBQ3FOLFNBQVMsQ0FBQ3JPLFFBQVFpVCxXQUFXO2dCQUM3QztnQkFDQSxJQUFJalQsUUFBUW1PLFFBQVEsS0FBSyxLQUFLLEdBQUc7b0JBQy9CcVUsS0FBSzJCLFVBQVUsQ0FBQzlWLFNBQVMsQ0FBQ3JPLFFBQVFtTyxRQUFRO2dCQUM1QztnQkFDQSxJQUFJbk8sUUFBUWdFLEtBQUssS0FBSyxLQUFLLEdBQUc7b0JBQzVCd2UsS0FBS3hlLEtBQUssQ0FBQ3FLLFNBQVMsQ0FBQ3JPLFFBQVFnRSxLQUFLO2dCQUNwQztZQUNGO1lBQ0EsSUFBSSxDQUFDaE0sT0FBTzJlLFlBQVksQ0FBQ3lOLEdBQUcsQ0FBQzVCLE9BQU87Z0JBQ2xDeHFCLE9BQU8yZSxZQUFZLENBQUMxVixHQUFHLENBQUN1aEIsTUFBTSxDQUFDO1lBQ2pDO1lBQ0F4cUIsT0FBTzJlLFlBQVksQ0FBQzFZLEdBQUcsQ0FBQ3VrQixNQUFNM2lCLEtBQUssR0FBR0M7WUFDdEMsT0FBTzBpQjtRQUNUO1FBQ0EsT0FBTyxJQUFJLENBQUMxTCxTQUFTLENBQUNoWCxVQUFVO0lBQ2xDO0lBQ0E7Ozs7R0FJQyxHQUNEK1osVUFBVXdLLFVBQVUsRUFBRTtRQUNwQixNQUFNNW9CLGFBQWEsSUFBSSxDQUFDQSxVQUFVO1FBQ2xDLE1BQU02b0IsV0FBVyxJQUFJLENBQUM5b0IsSUFBSSxDQUFDNGMsTUFBTSxDQUFDaU0sV0FBVztRQUM3QyxNQUFNcnNCLFNBQVMsSUFBSTtRQUNuQixNQUFNbWdCLFFBQVEsSUFBSXppQix3Q0FBS0E7UUFDdkIsSUFBSTR1QixTQUFTMW5CLElBQUksRUFDZnViLE1BQU12YixJQUFJLEdBQUc1RSxPQUFPNkosZ0JBQWdCLENBQUN5aUIsU0FBUzFuQixJQUFJO1FBQ3BEK0UsdUJBQXVCd1csT0FBT21NO1FBQzlCLElBQUlBLFNBQVM3b0IsVUFBVSxFQUNyQndZLCtCQUErQnhZLFlBQVkwYyxPQUFPbU07UUFDcEQsTUFBTUMsVUFBVUQsU0FBU3prQixLQUFLLElBQUksRUFBRTtRQUNwQyxNQUFNMkMsVUFBVSxFQUFFO1FBQ2xCLElBQUssSUFBSS9GLElBQUksR0FBR3NZLEtBQUt3UCxRQUFRN25CLE1BQU0sRUFBRUQsSUFBSXNZLElBQUl0WSxJQUFLO1lBQ2hEK0YsUUFBUW5ILElBQUksQ0FBQ3JELE9BQU84SixhQUFhLENBQUMsUUFBUXlpQixPQUFPLENBQUM5bkIsRUFBRTtRQUN0RDtRQUNBLE9BQU9tQixRQUFRc0YsR0FBRyxDQUFDVixTQUFTTixJQUFJLENBQUMsU0FBU3JDLEtBQUs7WUFDN0MsSUFBSyxJQUFJcEQsSUFBSSxHQUFHc1ksS0FBS2xWLE1BQU1uRCxNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztnQkFDOUMwYixNQUFNaGEsR0FBRyxDQUFDMEIsS0FBSyxDQUFDcEQsRUFBRTtZQUNwQjtZQUNBLE1BQU0rbkIscUJBQXFCLENBQUNoQztnQkFDMUIsTUFBTWlDLHNCQUFzQixhQUFhLEdBQUcsSUFBSTdOO2dCQUNoRCxLQUFLLE1BQU0sQ0FBQzFZLEtBQUt3bUIsTUFBTSxJQUFJMXNCLE9BQU8yZSxZQUFZLENBQUU7b0JBQzlDLElBQUl6WSxlQUFldEosMkNBQVFBLElBQUlzSixlQUFleEgsMENBQU9BLEVBQUU7d0JBQ3JEK3RCLG9CQUFvQnhqQixHQUFHLENBQUMvQyxLQUFLd21CO29CQUMvQjtnQkFDRjtnQkFDQWxDLEtBQUthLFFBQVEsQ0FBQyxDQUFDc0I7b0JBQ2IsTUFBTXBMLFdBQVd2aEIsT0FBTzJlLFlBQVksQ0FBQzFZLEdBQUcsQ0FBQzBtQjtvQkFDekMsSUFBSXBMLFlBQVksTUFBTTt3QkFDcEJrTCxvQkFBb0J4akIsR0FBRyxDQUFDMGpCLE9BQU9wTDtvQkFDakM7Z0JBQ0Y7Z0JBQ0EsT0FBT2tMO1lBQ1Q7WUFDQXpzQixPQUFPMmUsWUFBWSxHQUFHNk4sbUJBQW1Cck07WUFDekMsT0FBT0E7UUFDVDtJQUNGO0lBQ0FnTCx1QkFBdUJYLElBQUksRUFBRU8sYUFBYSxFQUFFQyxjQUFjLEVBQUUzRyxPQUFPLEVBQUV0YixNQUFNLEVBQUU7UUFDM0UsTUFBTStoQixTQUFTLEVBQUU7UUFDakIsTUFBTThCLGFBQWFwQyxLQUFLNWxCLElBQUksR0FBRzRsQixLQUFLNWxCLElBQUksR0FBRzRsQixLQUFLbEUsSUFBSTtRQUNwRCxNQUFNMUksY0FBYyxFQUFFO1FBQ3RCLElBQUk1QyxlQUFlLENBQUNqUyxPQUFPdEgsSUFBSSxDQUFDLEtBQUt1WixnQkFBZ0JFLE9BQU8sRUFBRTtZQUM1RHNQLEtBQUthLFFBQVEsQ0FBQyxTQUFTamxCLE1BQU07Z0JBQzNCLElBQUlBLE9BQU91WCxxQkFBcUIsRUFBRTtvQkFDaENDLFlBQVl2YSxJQUFJLENBQUMrQyxPQUFPeEIsSUFBSSxHQUFHd0IsT0FBT3hCLElBQUksR0FBR3dCLE9BQU9rZ0IsSUFBSTtnQkFDMUQ7WUFDRjtRQUNGLE9BQU87WUFDTDFJLFlBQVl2YSxJQUFJLENBQUN1cEI7UUFDbkI7UUFDQSxJQUFJQztRQUNKLE9BQVE3UixlQUFlLENBQUNqUyxPQUFPdEgsSUFBSSxDQUFDO1lBQ2xDLEtBQUt1WixnQkFBZ0JFLE9BQU87Z0JBQzFCMlIscUJBQXFCanVCLHNEQUFtQkE7Z0JBQ3hDO1lBQ0YsS0FBS29jLGdCQUFnQjdFLFFBQVE7Z0JBQzNCMFcscUJBQXFCaHVCLDBEQUF1QkE7Z0JBQzVDO1lBQ0YsS0FBS21jLGdCQUFnQmhTLFFBQVE7WUFDN0IsS0FBS2dTLGdCQUFnQmhQLEtBQUs7Z0JBQ3hCNmdCLHFCQUFxQmx1QixzREFBbUJBO2dCQUN4QztZQUNGO2dCQUNFLE9BQVFxc0IsZUFBZXpYLFFBQVE7b0JBQzdCLEtBQUs7d0JBQ0hzWixxQkFBcUJqdUIsc0RBQW1CQTt3QkFDeEM7b0JBQ0YsS0FBSztvQkFDTCxLQUFLO29CQUNMO3dCQUNFaXVCLHFCQUFxQmx1QixzREFBbUJBO3dCQUN4QztnQkFDSjtnQkFDQTtRQUNKO1FBQ0EsTUFBTW11QixnQkFBZ0J6SSxRQUFReUksYUFBYSxLQUFLLEtBQUssSUFBSTNSLGFBQWEsQ0FBQ2tKLFFBQVF5SSxhQUFhLENBQUMsR0FBRzd1QixvREFBaUJBO1FBQ2pILE1BQU04dUIsY0FBYyxJQUFJLENBQUNDLHFCQUFxQixDQUFDaEM7UUFDL0MsSUFBSyxJQUFJaUMsSUFBSSxHQUFHQyxLQUFLdFAsWUFBWWxaLE1BQU0sRUFBRXVvQixJQUFJQyxJQUFJRCxJQUFLO1lBQ3BELE1BQU1FLFFBQVEsSUFBSU4sbUJBQ2hCalAsV0FBVyxDQUFDcVAsRUFBRSxHQUFHLE1BQU1qUyxlQUFlLENBQUNqUyxPQUFPdEgsSUFBSSxDQUFDLEVBQ25Ec3BCLGNBQWNoZ0IsS0FBSyxFQUNuQmdpQixhQUNBRDtZQUVGLElBQUl6SSxRQUFReUksYUFBYSxLQUFLLGVBQWU7Z0JBQzNDLElBQUksQ0FBQ00sa0NBQWtDLENBQUNEO1lBQzFDO1lBQ0FyQyxPQUFPem5CLElBQUksQ0FBQzhwQjtRQUNkO1FBQ0EsT0FBT3JDO0lBQ1Q7SUFDQWtDLHNCQUFzQmhiLFFBQVEsRUFBRTtRQUM5QixJQUFJK2EsY0FBYy9hLFNBQVNqSCxLQUFLO1FBQ2hDLElBQUlpSCxTQUFTd0IsVUFBVSxFQUFFO1lBQ3ZCLE1BQU14SCxRQUFRdVMsNEJBQTRCd08sWUFBWXR0QixXQUFXO1lBQ2pFLE1BQU00dEIsU0FBUyxJQUFJMVQsYUFBYW9ULFlBQVlyb0IsTUFBTTtZQUNsRCxJQUFLLElBQUl1b0IsSUFBSSxHQUFHQyxLQUFLSCxZQUFZcm9CLE1BQU0sRUFBRXVvQixJQUFJQyxJQUFJRCxJQUFLO2dCQUNwREksTUFBTSxDQUFDSixFQUFFLEdBQUdGLFdBQVcsQ0FBQ0UsRUFBRSxHQUFHamhCO1lBQy9CO1lBQ0ErZ0IsY0FBY007UUFDaEI7UUFDQSxPQUFPTjtJQUNUO0lBQ0FLLG1DQUFtQ0QsS0FBSyxFQUFFO1FBQ3hDQSxNQUFNRyxpQkFBaUIsR0FBRyxTQUFTQyx3Q0FBd0NyYyxNQUFNO1lBQy9FLE1BQU1zYyxrQkFBa0IsSUFBSSxZQUFZM3VCLDBEQUF1QkEsR0FBR3daLHVDQUF1QzdCO1lBQ3pHLE9BQU8sSUFBSWdYLGdCQUFnQixJQUFJLENBQUNDLEtBQUssRUFBRSxJQUFJLENBQUMzVyxNQUFNLEVBQUUsSUFBSSxDQUFDNFcsWUFBWSxLQUFLLEdBQUd4YztRQUMvRTtRQUNBaWMsTUFBTUcsaUJBQWlCLENBQUNLLHlDQUF5QyxHQUFHO0lBQ3RFO0FBQ0Y7QUFDQSxTQUFTQyxjQUFjaGIsUUFBUSxFQUFFbUwsWUFBWSxFQUFFL2QsTUFBTTtJQUNuRCxNQUFNK1IsYUFBYWdNLGFBQWFoTSxVQUFVO0lBQzFDLE1BQU04YixNQUFNLElBQUkvdUIsdUNBQUlBO0lBQ3BCLElBQUlpVCxXQUFXdUksUUFBUSxLQUFLLEtBQUssR0FBRztRQUNsQyxNQUFNdEksV0FBV2hTLE9BQU93RCxJQUFJLENBQUNnUyxTQUFTLENBQUN6RCxXQUFXdUksUUFBUSxDQUFDO1FBQzNELE1BQU13VCxNQUFNOWIsU0FBUzhiLEdBQUc7UUFDeEIsTUFBTUMsTUFBTS9iLFNBQVMrYixHQUFHO1FBQ3hCLElBQUlELFFBQVEsS0FBSyxLQUFLQyxRQUFRLEtBQUssR0FBRztZQUNwQ0YsSUFBSTVrQixHQUFHLENBQUMsSUFBSW5OLDBDQUFPQSxDQUFDZ3lCLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSWh5QiwwQ0FBT0EsQ0FBQ2l5QixHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRTtZQUMvRSxJQUFJL2IsU0FBU3dCLFVBQVUsRUFBRTtnQkFDdkIsTUFBTXdhLFdBQVd6UCw0QkFBNEI3SSxxQkFBcUIsQ0FBQzFELFNBQVN5RCxhQUFhLENBQUM7Z0JBQzFGb1ksSUFBSUMsR0FBRyxDQUFDRyxjQUFjLENBQUNEO2dCQUN2QkgsSUFBSUUsR0FBRyxDQUFDRSxjQUFjLENBQUNEO1lBQ3pCO1FBQ0YsT0FBTztZQUNMaHNCLFFBQVF3RCxJQUFJLENBQUM7WUFDYjtRQUNGO0lBQ0YsT0FBTztRQUNMO0lBQ0Y7SUFDQSxNQUFNbVgsVUFBVW9CLGFBQWFwQixPQUFPO0lBQ3BDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCLE1BQU11UixrQkFBa0IsSUFBSXB5QiwwQ0FBT0E7UUFDbkMsTUFBTXF5QixTQUFTLElBQUlyeUIsMENBQU9BO1FBQzFCLElBQUssSUFBSTJJLElBQUksR0FBR3NZLEtBQUtKLFFBQVFqWSxNQUFNLEVBQUVELElBQUlzWSxJQUFJdFksSUFBSztZQUNoRCxNQUFNc0UsU0FBUzRULE9BQU8sQ0FBQ2xZLEVBQUU7WUFDekIsSUFBSXNFLE9BQU91UixRQUFRLEtBQUssS0FBSyxHQUFHO2dCQUM5QixNQUFNdEksV0FBV2hTLE9BQU93RCxJQUFJLENBQUNnUyxTQUFTLENBQUN6TSxPQUFPdVIsUUFBUSxDQUFDO2dCQUN2RCxNQUFNd1QsTUFBTTliLFNBQVM4YixHQUFHO2dCQUN4QixNQUFNQyxNQUFNL2IsU0FBUytiLEdBQUc7Z0JBQ3hCLElBQUlELFFBQVEsS0FBSyxLQUFLQyxRQUFRLEtBQUssR0FBRztvQkFDcENJLE9BQU9wSyxJQUFJLENBQUN6YSxLQUFLeWtCLEdBQUcsQ0FBQ3prQixLQUFLOGtCLEdBQUcsQ0FBQ04sR0FBRyxDQUFDLEVBQUUsR0FBR3hrQixLQUFLOGtCLEdBQUcsQ0FBQ0wsR0FBRyxDQUFDLEVBQUU7b0JBQ3RESSxPQUFPbkssSUFBSSxDQUFDMWEsS0FBS3lrQixHQUFHLENBQUN6a0IsS0FBSzhrQixHQUFHLENBQUNOLEdBQUcsQ0FBQyxFQUFFLEdBQUd4a0IsS0FBSzhrQixHQUFHLENBQUNMLEdBQUcsQ0FBQyxFQUFFO29CQUN0REksT0FBT2xLLElBQUksQ0FBQzNhLEtBQUt5a0IsR0FBRyxDQUFDemtCLEtBQUs4a0IsR0FBRyxDQUFDTixHQUFHLENBQUMsRUFBRSxHQUFHeGtCLEtBQUs4a0IsR0FBRyxDQUFDTCxHQUFHLENBQUMsRUFBRTtvQkFDdEQsSUFBSS9iLFNBQVN3QixVQUFVLEVBQUU7d0JBQ3ZCLE1BQU13YSxXQUFXelAsNEJBQTRCN0kscUJBQXFCLENBQUMxRCxTQUFTeUQsYUFBYSxDQUFDO3dCQUMxRjBZLE9BQU9GLGNBQWMsQ0FBQ0Q7b0JBQ3hCO29CQUNBRSxnQkFBZ0JILEdBQUcsQ0FBQ0k7Z0JBQ3RCLE9BQU87b0JBQ0xuc0IsUUFBUXdELElBQUksQ0FBQztnQkFDZjtZQUNGO1FBQ0Y7UUFDQXFvQixJQUFJUSxjQUFjLENBQUNIO0lBQ3JCO0lBQ0F0YixTQUFTMGIsV0FBVyxHQUFHVDtJQUN2QixNQUFNVSxTQUFTLElBQUl4dkIseUNBQU1BO0lBQ3pCOHVCLElBQUlXLFNBQVMsQ0FBQ0QsT0FBT0UsTUFBTTtJQUMzQkYsT0FBT0csTUFBTSxHQUFHYixJQUFJQyxHQUFHLENBQUNhLFVBQVUsQ0FBQ2QsSUFBSUUsR0FBRyxJQUFJO0lBQzlDbmIsU0FBU2djLGNBQWMsR0FBR0w7QUFDNUI7QUFDQSxTQUFTakcsdUJBQXVCMVYsUUFBUSxFQUFFbUwsWUFBWSxFQUFFL2QsTUFBTTtJQUM1RCxNQUFNK1IsYUFBYWdNLGFBQWFoTSxVQUFVO0lBQzFDLE1BQU12SCxVQUFVLEVBQUU7SUFDbEIsU0FBU3FrQix3QkFBd0JoTSxhQUFhLEVBQUV6UCxhQUFhO1FBQzNELE9BQU9wVCxPQUFPOEosYUFBYSxDQUFDLFlBQVkrWSxlQUFlM1ksSUFBSSxDQUFDLFNBQVM4SCxRQUFRO1lBQzNFWSxTQUFTYSxZQUFZLENBQUNMLGVBQWVwQjtRQUN2QztJQUNGO0lBQ0EsSUFBSyxNQUFNOGMscUJBQXFCL2MsV0FBWTtRQUMxQyxNQUFNcUQscUJBQXFCQyxVQUFVLENBQUN5WixrQkFBa0IsSUFBSUEsa0JBQWtCeFosV0FBVztRQUN6RixJQUFJRixzQkFBc0J4QyxTQUFTYixVQUFVLEVBQzNDO1FBQ0Z2SCxRQUFRbkgsSUFBSSxDQUFDd3JCLHdCQUF3QjljLFVBQVUsQ0FBQytjLGtCQUFrQixFQUFFMVo7SUFDdEU7SUFDQSxJQUFJMkksYUFBYUcsT0FBTyxLQUFLLEtBQUssS0FBSyxDQUFDdEwsU0FBUzdJLEtBQUssRUFBRTtRQUN0RCxNQUFNaUksV0FBV2hTLE9BQU84SixhQUFhLENBQUMsWUFBWWlVLGFBQWFHLE9BQU8sRUFBRWhVLElBQUksQ0FBQyxTQUFTNmtCLFNBQVM7WUFDN0ZuYyxTQUFTb2MsUUFBUSxDQUFDRDtRQUNwQjtRQUNBdmtCLFFBQVFuSCxJQUFJLENBQUMyTztJQUNmO0lBQ0FySSx1QkFBdUJpSixVQUFVbUw7SUFDakM2UCxjQUFjaGIsVUFBVW1MLGNBQWMvZDtJQUN0QyxPQUFPNEYsUUFBUXNGLEdBQUcsQ0FBQ1YsU0FBU04sSUFBSSxDQUFDO1FBQy9CLE9BQU82VCxhQUFhcEIsT0FBTyxLQUFLLEtBQUssSUFBSUQsZ0JBQWdCOUosVUFBVW1MLGFBQWFwQixPQUFPLEVBQUUzYyxVQUFVNFM7SUFDckc7QUFDRjtBQUdFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcz9iZmMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvYWRlciwgTG9hZGVyVXRpbHMsIEZpbGVMb2FkZXIsIENvbG9yLCBTcG90TGlnaHQsIFBvaW50TGlnaHQsIERpcmVjdGlvbmFsTGlnaHQsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoUGh5c2ljYWxNYXRlcmlhbCwgVmVjdG9yMiwgTWF0cml4NCwgVmVjdG9yMywgUXVhdGVybmlvbiwgSW5zdGFuY2VkTWVzaCwgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLCBPYmplY3QzRCwgVGV4dHVyZUxvYWRlciwgSW1hZ2VCaXRtYXBMb2FkZXIsIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgUmVwZWF0V3JhcHBpbmcsIFBvaW50c01hdGVyaWFsLCBNYXRlcmlhbCwgTGluZUJhc2ljTWF0ZXJpYWwsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBEb3VibGVTaWRlLCBQcm9wZXJ0eUJpbmRpbmcsIEJ1ZmZlckdlb21ldHJ5LCBTa2lubmVkTWVzaCwgTWVzaCwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBMaW5lU2VnbWVudHMsIExpbmUsIExpbmVMb29wLCBQb2ludHMsIEdyb3VwLCBQZXJzcGVjdGl2ZUNhbWVyYSwgTWF0aFV0aWxzLCBPcnRob2dyYXBoaWNDYW1lcmEsIFNrZWxldG9uLCBBbmltYXRpb25DbGlwLCBCb25lLCBJbnRlcnBvbGF0ZUxpbmVhciwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIENsYW1wVG9FZGdlV3JhcHBpbmcsIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsIEludGVycG9sYXRlRGlzY3JldGUsIEZyb250U2lkZSwgVGV4dHVyZSwgVmVjdG9yS2V5ZnJhbWVUcmFjaywgTnVtYmVyS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIEJveDMsIFNwaGVyZSwgSW50ZXJwb2xhbnQgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHRvVHJpYW5nbGVzRHJhd01vZGUgfSBmcm9tIFwiLi4vdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fcG9seWZpbGwvY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVUZXh0IH0gZnJvbSBcIi4uL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qc1wiO1xuY29uc3QgU1JHQkNvbG9yU3BhY2UgPSBcInNyZ2JcIjtcbmNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbmNvbnN0IExpbmVhckVuY29kaW5nID0gM2UzO1xuY2xhc3MgR0xURkxvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmt0eDJMb2FkZXIgPSBudWxsO1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBudWxsO1xuICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNEaXNwZXJzaW9uRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0J1bXBFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTGlnaHRzRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1lc2hvcHRDb21wcmVzc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNoR3B1SW5zdGFuY2luZyhwYXJzZXIpO1xuICAgIH0pO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgbGV0IHJlc291cmNlUGF0aDtcbiAgICBpZiAodGhpcy5yZXNvdXJjZVBhdGggIT09IFwiXCIpIHtcbiAgICAgIHJlc291cmNlUGF0aCA9IHRoaXMucmVzb3VyY2VQYXRoO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wYXRoICE9PSBcIlwiKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVVybCA9IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHVybCk7XG4gICAgICByZXNvdXJjZVBhdGggPSBMb2FkZXJVdGlscy5yZXNvbHZlVVJMKHJlbGF0aXZlVXJsLCB0aGlzLnBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvdXJjZVBhdGggPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuICAgIH1cbiAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgY29uc3QgX29uRXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzY29wZS5wYXJzZShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZXNvdXJjZVBhdGgsXG4gICAgICAgICAgICBmdW5jdGlvbihnbHRmKSB7XG4gICAgICAgICAgICAgIG9uTG9hZChnbHRmKTtcbiAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX29uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgX29uRXJyb3JcbiAgICApO1xuICB9XG4gIHNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKSB7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldEREU0xvYWRlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IFwiTVNGVF90ZXh0dXJlX2Rkc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gXCJLSFJfdGV4dHVyZV9iYXNpc3VcIi4nKTtcbiAgfVxuICBzZXRLVFgyTG9hZGVyKGt0eDJMb2FkZXIpIHtcbiAgICB0aGlzLmt0eDJMb2FkZXIgPSBrdHgyTG9hZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldE1lc2hvcHREZWNvZGVyKG1lc2hvcHREZWNvZGVyKSB7XG4gICAgdGhpcy5tZXNob3B0RGVjb2RlciA9IG1lc2hvcHREZWNvZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVucmVnaXN0ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjaykgIT09IC0xKSB7XG4gICAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcy5zcGxpY2UodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwYXJzZShkYXRhLCBwYXRoLCBvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICBsZXQganNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0ge307XG4gICAgY29uc3QgcGx1Z2lucyA9IHt9O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGNvbnN0IG1hZ2ljID0gZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKDAsIDQpKSk7XG4gICAgICBpZiAobWFnaWMgPT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0gPSBuZXcgR0xURkJpbmFyeUV4dGVuc2lvbihkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXS5jb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAganNvbiA9IGRhdGE7XG4gICAgfVxuICAgIGlmIChqc29uLmFzc2V0ID09PSB2b2lkIDAgfHwganNvbi5hc3NldC52ZXJzaW9uWzBdIDwgMikge1xuICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgIG9uRXJyb3IobmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgYXNzZXQuIGdsVEYgdmVyc2lvbnMgPj0yLjAgYXJlIHN1cHBvcnRlZC5cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgR0xURlBhcnNlcihqc29uLCB7XG4gICAgICBwYXRoOiBwYXRoIHx8IHRoaXMucmVzb3VyY2VQYXRoIHx8IFwiXCIsXG4gICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcbiAgICAgIHJlcXVlc3RIZWFkZXI6IHRoaXMucmVxdWVzdEhlYWRlcixcbiAgICAgIG1hbmFnZXI6IHRoaXMubWFuYWdlcixcbiAgICAgIGt0eDJMb2FkZXI6IHRoaXMua3R4MkxvYWRlcixcbiAgICAgIG1lc2hvcHREZWNvZGVyOiB0aGlzLm1lc2hvcHREZWNvZGVyXG4gICAgfSk7XG4gICAgcGFyc2VyLmZpbGVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5DYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luQ2FsbGJhY2tzW2ldKHBhcnNlcik7XG4gICAgICBpZiAoIXBsdWdpbi5uYW1lKVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSW52YWxpZCBwbHVnaW4gZm91bmQ6IG1pc3NpbmcgbmFtZVwiKTtcbiAgICAgIHBsdWdpbnNbcGx1Z2luLm5hbWVdID0gcGx1Z2luO1xuICAgICAgZXh0ZW5zaW9uc1twbHVnaW4ubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoanNvbi5leHRlbnNpb25zVXNlZCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmV4dGVuc2lvbnNVc2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBqc29uLmV4dGVuc2lvbnNVc2VkW2ldO1xuICAgICAgICBjb25zdCBleHRlbnNpb25zUmVxdWlyZWQgPSBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCB8fCBbXTtcbiAgICAgICAgc3dpdGNoIChleHRlbnNpb25OYW1lKSB7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ6XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24oanNvbiwgdGhpcy5kcmFjb0xvYWRlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoZXh0ZW5zaW9uTmFtZSkgPj0gMCAmJiBwbHVnaW5zW2V4dGVuc2lvbk5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnNlci5zZXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICAgIHBhcnNlci5zZXRQbHVnaW5zKHBsdWdpbnMpO1xuICAgIHBhcnNlci5wYXJzZShvbkxvYWQsIG9uRXJyb3IpO1xuICB9XG4gIHBhcnNlQXN5bmMoZGF0YSwgcGF0aCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBzY29wZS5wYXJzZShkYXRhLCBwYXRoLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBHTFRGUmVnaXN0cnkoKSB7XG4gIGxldCBvYmplY3RzID0ge307XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgb2JqZWN0KSB7XG4gICAgICBvYmplY3RzW2tleV0gPSBvYmplY3Q7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgZGVsZXRlIG9iamVjdHNba2V5XTtcbiAgICB9LFxuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICBvYmplY3RzID0ge307XG4gICAgfVxuICB9O1xufVxuY29uc3QgRVhURU5TSU9OUyA9IHtcbiAgS0hSX0JJTkFSWV9HTFRGOiBcIktIUl9iaW5hcnlfZ2xURlwiLFxuICBLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjogXCJLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvblwiLFxuICBLSFJfTElHSFRTX1BVTkNUVUFMOiBcIktIUl9saWdodHNfcHVuY3R1YWxcIixcbiAgS0hSX01BVEVSSUFMU19DTEVBUkNPQVQ6IFwiS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcIixcbiAgS0hSX01BVEVSSUFMU19ESVNQRVJTSU9OOiBcIktIUl9tYXRlcmlhbHNfZGlzcGVyc2lvblwiLFxuICBLSFJfTUFURVJJQUxTX0lPUjogXCJLSFJfbWF0ZXJpYWxzX2lvclwiLFxuICBLSFJfTUFURVJJQUxTX1NIRUVOOiBcIktIUl9tYXRlcmlhbHNfc2hlZW5cIixcbiAgS0hSX01BVEVSSUFMU19TUEVDVUxBUjogXCJLSFJfbWF0ZXJpYWxzX3NwZWN1bGFyXCIsXG4gIEtIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OOiBcIktIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uXCIsXG4gIEtIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0U6IFwiS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZVwiLFxuICBLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk6IFwiS0hSX21hdGVyaWFsc19hbmlzb3Ryb3B5XCIsXG4gIEtIUl9NQVRFUklBTFNfVU5MSVQ6IFwiS0hSX21hdGVyaWFsc191bmxpdFwiLFxuICBLSFJfTUFURVJJQUxTX1ZPTFVNRTogXCJLSFJfbWF0ZXJpYWxzX3ZvbHVtZVwiLFxuICBLSFJfVEVYVFVSRV9CQVNJU1U6IFwiS0hSX3RleHR1cmVfYmFzaXN1XCIsXG4gIEtIUl9URVhUVVJFX1RSQU5TRk9STTogXCJLSFJfdGV4dHVyZV90cmFuc2Zvcm1cIixcbiAgS0hSX01FU0hfUVVBTlRJWkFUSU9OOiBcIktIUl9tZXNoX3F1YW50aXphdGlvblwiLFxuICBLSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIOiBcIktIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGhcIixcbiAgRVhUX01BVEVSSUFMU19CVU1QOiBcIkVYVF9tYXRlcmlhbHNfYnVtcFwiLFxuICBFWFRfVEVYVFVSRV9XRUJQOiBcIkVYVF90ZXh0dXJlX3dlYnBcIixcbiAgRVhUX1RFWFRVUkVfQVZJRjogXCJFWFRfdGV4dHVyZV9hdmlmXCIsXG4gIEVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OOiBcIkVYVF9tZXNob3B0X2NvbXByZXNzaW9uXCIsXG4gIEVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HOiBcIkVYVF9tZXNoX2dwdV9pbnN0YW5jaW5nXCJcbn07XG5jbGFzcyBHTFRGTGlnaHRzRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTElHSFRTX1BVTkNUVUFMO1xuICAgIHRoaXMuY2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICB9XG4gIF9tYXJrRGVmcygpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBub2RlRGVmcyA9IHRoaXMucGFyc2VyLmpzb24ubm9kZXMgfHwgW107XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcnNlci5fYWRkTm9kZVJlZih0aGlzLmNhY2hlLCBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9sb2FkTGlnaHQobGlnaHRJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJsaWdodDpcIiArIGxpZ2h0SW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSBwYXJzZXIuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoZGVwZW5kZW5jeSlcbiAgICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zICYmIGpzb24uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0RGVmcyA9IGV4dGVuc2lvbnMubGlnaHRzIHx8IFtdO1xuICAgIGNvbnN0IGxpZ2h0RGVmID0gbGlnaHREZWZzW2xpZ2h0SW5kZXhdO1xuICAgIGxldCBsaWdodE5vZGU7XG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoMTY3NzcyMTUpO1xuICAgIGlmIChsaWdodERlZi5jb2xvciAhPT0gdm9pZCAwKVxuICAgICAgY29sb3Iuc2V0UkdCKGxpZ2h0RGVmLmNvbG9yWzBdLCBsaWdodERlZi5jb2xvclsxXSwgbGlnaHREZWYuY29sb3JbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICBjb25zdCByYW5nZSA9IGxpZ2h0RGVmLnJhbmdlICE9PSB2b2lkIDAgPyBsaWdodERlZi5yYW5nZSA6IDA7XG4gICAgc3dpdGNoIChsaWdodERlZi50eXBlKSB7XG4gICAgICBjYXNlIFwiZGlyZWN0aW9uYWxcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBQb2ludExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLmRpc3RhbmNlID0gcmFuZ2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNwb3RcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IFNwb3RMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBsaWdodERlZi5zcG90ID0gbGlnaHREZWYuc3BvdCB8fCB7fTtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgOiAwO1xuICAgICAgICBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSAhPT0gdm9pZCAwID8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA6IE1hdGguUEkgLyA0O1xuICAgICAgICBsaWdodE5vZGUuYW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUucGVudW1icmEgPSAxIC0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAvIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG4gICAgICAgIGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KDAsIDAsIC0xKTtcbiAgICAgICAgbGlnaHROb2RlLmFkZChsaWdodE5vZGUudGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbmV4cGVjdGVkIGxpZ2h0IHR5cGU6IFwiICsgbGlnaHREZWYudHlwZSk7XG4gICAgfVxuICAgIGxpZ2h0Tm9kZS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgbGlnaHROb2RlLmRlY2F5ID0gMjtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGxpZ2h0Tm9kZSwgbGlnaHREZWYpO1xuICAgIGlmIChsaWdodERlZi5pbnRlbnNpdHkgIT09IHZvaWQgMClcbiAgICAgIGxpZ2h0Tm9kZS5pbnRlbnNpdHkgPSBsaWdodERlZi5pbnRlbnNpdHk7XG4gICAgbGlnaHROb2RlLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShsaWdodERlZi5uYW1lIHx8IFwibGlnaHRfXCIgKyBsaWdodEluZGV4KTtcbiAgICBkZXBlbmRlbmN5ID0gUHJvbWlzZS5yZXNvbHZlKGxpZ2h0Tm9kZSk7XG4gICAgcGFyc2VyLmNhY2hlLmFkZChjYWNoZUtleSwgZGVwZW5kZW5jeSk7XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGlmICh0eXBlICE9PSBcImxpZ2h0XCIpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRMaWdodChpbmRleCk7XG4gIH1cbiAgY3JlYXRlTm9kZUF0dGFjaG1lbnQobm9kZUluZGV4KSB7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IGxpZ2h0RGVmID0gbm9kZURlZi5leHRlbnNpb25zICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0SW5kZXggPSBsaWdodERlZi5saWdodDtcbiAgICBpZiAobGlnaHRJbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRMaWdodChsaWdodEluZGV4KS50aGVuKGZ1bmN0aW9uKGxpZ2h0KSB7XG4gICAgICByZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKHNlbGYyLmNhY2hlLCBsaWdodEluZGV4LCBsaWdodCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUoKSB7XG4gICAgcmV0dXJuIE1lc2hCYXNpY01hdGVyaWFsO1xuICB9XG4gIGV4dGVuZFBhcmFtcyhtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlcikge1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMTtcbiAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzO1xuICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3Iuc2V0UkdCKGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WzNdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUsIFNSR0JDb2xvclNwYWNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBlbWlzc2l2ZVN0cmVuZ3RoID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmVtaXNzaXZlU3RyZW5ndGg7XG4gICAgaWYgKGVtaXNzaXZlU3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBlbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQ0xFQVJDT0FUO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdCA9IGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0TWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdFJvdWdobmVzcyA9IGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0Um91Z2huZXNzTWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0Tm9ybWFsTWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlKSk7XG4gICAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0Rpc3BlcnNpb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfRElTUEVSU0lPTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmRpc3BlcnNpb24gPSBleHRlbnNpb24uZGlzcGVyc2lvbiAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmRpc3BlcnNpb24gOiAwO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2UgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJpcmlkZXNjZW5jZU1hcFwiLCBleHRlbnNpb24uaXJpZGVzY2VuY2VUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VJb3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VJT1IgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VJb3I7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID09PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSBbMTAwLCA0MDBdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzBdID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVsxXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VUaGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NIRUVOO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvciA9IG5ldyBDb2xvcigwLCAwLCAwKTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IDA7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW4gPSAxO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgY29sb3JGYWN0b3IgPSBleHRlbnNpb24uc2hlZW5Db2xvckZhY3RvcjtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3Iuc2V0UkdCKGNvbG9yRmFjdG9yWzBdLCBjb2xvckZhY3RvclsxXSwgY29sb3JGYWN0b3JbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc0ZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlbkNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Db2xvck1hcFwiLCBleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUsIFNSR0JDb2xvclNwYWNlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzaGVlblJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT047XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNtaXNzaW9uID0gZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0cmFuc21pc3Npb25NYXBcIiwgZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1ZPTFVNRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy50aGlja25lc3MgPSBleHRlbnNpb24udGhpY2tuZXNzRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24udGhpY2tuZXNzRmFjdG9yIDogMDtcbiAgICBpZiAoZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInRoaWNrbmVzc01hcFwiLCBleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkRpc3RhbmNlID0gZXh0ZW5zaW9uLmF0dGVudWF0aW9uRGlzdGFuY2UgfHwgSW5maW5pdHk7XG4gICAgY29uc3QgY29sb3JBcnJheSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkNvbG9yIHx8IFsxLCAxLCAxXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkNvbG9yID0gbmV3IENvbG9yKCkuc2V0UkdCKFxuICAgICAgY29sb3JBcnJheVswXSxcbiAgICAgIGNvbG9yQXJyYXlbMV0sXG4gICAgICBjb2xvckFycmF5WzJdLFxuICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2VcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JT1I7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5pb3IgPSBleHRlbnNpb24uaW9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uaW9yIDogMS41O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NQRUNVTEFSO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFySW50ZW5zaXR5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uc3BlY3VsYXJGYWN0b3IgOiAxO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckludGVuc2l0eU1hcFwiLCBleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uc3BlY3VsYXJDb2xvckZhY3RvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJDb2xvciA9IG5ldyBDb2xvcigpLnNldFJHQihjb2xvckFycmF5WzBdLCBjb2xvckFycmF5WzFdLCBjb2xvckFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgaWYgKGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNwZWN1bGFyQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0J1bXBFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NQVRFUklBTFNfQlVNUDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5idW1wU2NhbGUgPSBleHRlbnNpb24uYnVtcEZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmJ1bXBGYWN0b3IgOiAxO1xuICAgIGlmIChleHRlbnNpb24uYnVtcFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImJ1bXBNYXBcIiwgZXh0ZW5zaW9uLmJ1bXBUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQU5JU09UUk9QWTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlTdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5hbmlzb3Ryb3B5ID0gZXh0ZW5zaW9uLmFuaXNvdHJvcHlTdHJlbmd0aDtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weVJvdGF0aW9uID0gZXh0ZW5zaW9uLmFuaXNvdHJvcHlSb3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5VGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiYW5pc290cm9weU1hcFwiLCBleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfQkFTSVNVO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGNvbnN0IGxvYWRlciA9IHBhcnNlci5vcHRpb25zLmt0eDJMb2FkZXI7XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKHRoaXMubmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRLVFgyTG9hZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIEtUWDIgdGV4dHVyZXNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9XRUJQO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICBjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1tleHRlbnNpb24uc291cmNlXTtcbiAgICBsZXQgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZS51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24oaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogV2ViUCByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIGRldGVjdFN1cHBvcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUFcIjtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUoaW1hZ2UuaGVpZ2h0ID09PSAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9BVklGO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICBjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1tleHRlbnNpb24uc291cmNlXTtcbiAgICBsZXQgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZS51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24oaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQVZJRiByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIGRldGVjdFN1cHBvcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2UvYXZpZjtiYXNlNjQsQUFBQUlHWjBlWEJoZG1sbUFBQUFBR0YyYVdadGFXWXhiV2xoWmsxQk1VSUFBQUR5YldWMFlRQUFBQUFBQUFBb2FHUnNjZ0FBQUFBQUFBQUFjR2xqZEFBQUFBQUFBQUFBQUFBQUFHeHBZbUYyYVdZQUFBQUFEbkJwZEcwQUFBQUFBQUVBQUFBZWFXeHZZd0FBQUFCRUFBQUJBQUVBQUFBQkFBQUJHZ0FBQUJjQUFBQW9hV2x1WmdBQUFBQUFBUUFBQUJwcGJtWmxBZ0FBQUFBQkFBQmhkakF4UTI5c2IzSUFBQUFBYW1sd2NuQUFBQUJMYVhCamJ3QUFBQlJwYzNCbEFBQUFBQUFBQUFFQUFBQUJBQUFBRUhCcGVHa0FBQUFBQXdnSUNBQUFBQXhoZGpGRGdRQU1BQUFBQUJOamIyeHlibU5zZUFBQ0FBSUFCb0FBQUFBWGFYQnRZUUFBQUFBQUFBQUJBQUVFQVFLREJBQUFBQjl0WkdGMEVnQUtDQmdBQm9nUUVEUWdNZ2tRQUFBQUI4ZFNMZkk9XCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNob3B0Q29tcHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB9XG4gIGxvYWRCdWZmZXJWaWV3KGluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG4gICAgY29uc3QgYnVmZmVyVmlldyA9IGpzb24uYnVmZmVyVmlld3NbaW5kZXhdO1xuICAgIGlmIChidWZmZXJWaWV3LmV4dGVuc2lvbnMgJiYgYnVmZmVyVmlldy5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkRlZiA9IGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBleHRlbnNpb25EZWYuYnVmZmVyKTtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSB0aGlzLnBhcnNlci5vcHRpb25zLm1lc2hvcHREZWNvZGVyO1xuICAgICAgaWYgKCFkZWNvZGVyIHx8ICFkZWNvZGVyLnN1cHBvcnRlZCkge1xuICAgICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRNZXNob3B0RGVjb2RlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBjb21wcmVzc2VkIGZpbGVzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBleHRlbnNpb25EZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gZXh0ZW5zaW9uRGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgICAgY29uc3QgY291bnQgPSBleHRlbnNpb25EZWYuY291bnQ7XG4gICAgICAgIGNvbnN0IHN0cmlkZSA9IGV4dGVuc2lvbkRlZi5ieXRlU3RyaWRlO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBuZXcgVWludDhBcnJheShyZXMsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICBpZiAoZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMoY291bnQsIHN0cmlkZSwgc291cmNlLCBleHRlbnNpb25EZWYubW9kZSwgZXh0ZW5zaW9uRGVmLmZpbHRlcikudGhlbihmdW5jdGlvbihyZXMyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzMi5idWZmZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIucmVhZHkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihjb3VudCAqIHN0cmlkZSk7XG4gICAgICAgICAgICBkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXIoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCksXG4gICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uRGVmLm1vZGUsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5maWx0ZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHTFRGTWVzaEdwdUluc3RhbmNpbmcge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB9XG4gIGNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKCFub2RlRGVmLmV4dGVuc2lvbnMgfHwgIW5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IG5vZGVEZWYubWVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzW25vZGVEZWYubWVzaF07XG4gICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgbWVzaERlZi5wcmltaXRpdmVzKSB7XG4gICAgICBpZiAocHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCAmJiBwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiAmJiBwcmltaXRpdmUubW9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb25EZWYgPSBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzRGVmID0gZXh0ZW5zaW9uRGVmLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzRGVmKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBhdHRyaWJ1dGVzRGVmW2tleV0pLnRoZW4oKGFjY2Vzc29yKSA9PiB7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gYWNjZXNzb3I7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwZW5kaW5nLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZW5kaW5nLnB1c2godGhpcy5wYXJzZXIuY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVPYmplY3QgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgY29uc3QgbWVzaGVzID0gbm9kZU9iamVjdC5pc0dyb3VwID8gbm9kZU9iamVjdC5jaGlsZHJlbiA6IFtub2RlT2JqZWN0XTtcbiAgICAgIGNvbnN0IGNvdW50ID0gcmVzdWx0c1swXS5jb3VudDtcbiAgICAgIGNvbnN0IGluc3RhbmNlZE1lc2hlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBtZXNoIG9mIG1lc2hlcykge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgICBjb25zdCBzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlZE1lc2ggPSBuZXcgSW5zdGFuY2VkTWVzaChtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdGVyaWFsLCBjb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlRSQU5TTEFUSU9OKSB7XG4gICAgICAgICAgICBwLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5UUkFOU0xBVElPTiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlJPVEFUSU9OKSB7XG4gICAgICAgICAgICBxLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5ST1RBVElPTiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlNDQUxFKSB7XG4gICAgICAgICAgICBzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5TQ0FMRSwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQoaSwgbS5jb21wb3NlKHAsIHEsIHMpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcIl9DT0xPUl8wXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgaW5zdGFuY2VkTWVzaC5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShhdHRyLmFycmF5LCBhdHRyLml0ZW1TaXplLCBhdHRyLm5vcm1hbGl6ZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZSAhPT0gXCJUUkFOU0xBVElPTlwiICYmIGF0dHJpYnV0ZU5hbWUgIT09IFwiUk9UQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlNDQUxFXCIpIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKGluc3RhbmNlZE1lc2gsIG1lc2gpO1xuICAgICAgICB0aGlzLnBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKGluc3RhbmNlZE1lc2gpO1xuICAgICAgICBpbnN0YW5jZWRNZXNoZXMucHVzaChpbnN0YW5jZWRNZXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlT2JqZWN0LmlzR3JvdXApIHtcbiAgICAgICAgbm9kZU9iamVjdC5jbGVhcigpO1xuICAgICAgICBub2RlT2JqZWN0LmFkZCguLi5pbnN0YW5jZWRNZXNoZXMpO1xuICAgICAgICByZXR1cm4gbm9kZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0YW5jZWRNZXNoZXNbMF07XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDID0gXCJnbFRGXCI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggPSAxMjtcbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMgPSB7IEpTT046IDEzMTM4MjE1MTQsIEJJTjogNTEzMDU2MiB9O1xuY2xhc3MgR0xURkJpbmFyeUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURjtcbiAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgY29uc3QgaGVhZGVyVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCAwLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIHRoaXMuaGVhZGVyID0ge1xuICAgICAgbWFnaWM6IGRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpLFxuICAgICAgdmVyc2lvbjogaGVhZGVyVmlldy5nZXRVaW50MzIoNCwgdHJ1ZSksXG4gICAgICBsZW5ndGg6IGhlYWRlclZpZXcuZ2V0VWludDMyKDgsIHRydWUpXG4gICAgfTtcbiAgICBpZiAodGhpcy5oZWFkZXIubWFnaWMgIT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBnbFRGLUJpbmFyeSBoZWFkZXIuXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oZWFkZXIudmVyc2lvbiA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IExlZ2FjeSBiaW5hcnkgZmlsZSBkZXRlY3RlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rQ29udGVudHNMZW5ndGggPSB0aGlzLmhlYWRlci5sZW5ndGggLSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEg7XG4gICAgY29uc3QgY2h1bmtWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCk7XG4gICAgbGV0IGNodW5rSW5kZXggPSAwO1xuICAgIHdoaWxlIChjaHVua0luZGV4IDwgY2h1bmtDb250ZW50c0xlbmd0aCkge1xuICAgICAgY29uc3QgY2h1bmtMZW5ndGggPSBjaHVua1ZpZXcuZ2V0VWludDMyKGNodW5rSW5kZXgsIHRydWUpO1xuICAgICAgY2h1bmtJbmRleCArPSA0O1xuICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGlmIChjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuSlNPTikge1xuICAgICAgICBjb25zdCBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4LCBjaHVua0xlbmd0aCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGRlY29kZVRleHQoY29udGVudEFycmF5KTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkJJTikge1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleDtcbiAgICAgICAgdGhpcy5ib2R5ID0gZGF0YS5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgY2h1bmtMZW5ndGgpO1xuICAgICAgfVxuICAgICAgY2h1bmtJbmRleCArPSBjaHVua0xlbmd0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSlNPTiBjb250ZW50IG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3Rvcihqc29uLCBkcmFjb0xvYWRlcikge1xuICAgIGlmICghZHJhY29Mb2FkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IE5vIERSQUNPTG9hZGVyIGluc3RhbmNlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjtcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyLnByZWxvYWQoKTtcbiAgfVxuICBkZWNvZGVQcmltaXRpdmUocHJpbWl0aXZlLCBwYXJzZXIpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGRyYWNvTG9hZGVyID0gdGhpcy5kcmFjb0xvYWRlcjtcbiAgICBjb25zdCBidWZmZXJWaWV3SW5kZXggPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmJ1ZmZlclZpZXc7XG4gICAgY29uc3QgZ2x0ZkF0dHJpYnV0ZU1hcCA9IHByaW1pdGl2ZS5leHRlbnNpb25zW3RoaXMubmFtZV0uYXR0cmlidXRlcztcbiAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVUeXBlTWFwID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGdsdGZBdHRyaWJ1dGVNYXApIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhyZWVBdHRyaWJ1dGVNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBwcmltaXRpdmUuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1thdHRyaWJ1dGVOYW1lXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZ2x0ZkF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yRGVmID0ganNvbi5hY2Nlc3NvcnNbcHJpbWl0aXZlLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgICBjb25zdCBjb21wb25lbnRUeXBlID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgICBhdHRyaWJ1dGVUeXBlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBjb21wb25lbnRUeXBlLm5hbWU7XG4gICAgICAgIGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYnVmZmVyVmlld0luZGV4KS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZHJhY29Mb2FkZXIuZGVjb2RlRHJhY29GaWxlKFxuICAgICAgICAgIGJ1ZmZlclZpZXcsXG4gICAgICAgICAgZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZ2VvbWV0cnkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyZWVBdHRyaWJ1dGVNYXAsXG4gICAgICAgICAgYXR0cmlidXRlVHlwZU1hcCxcbiAgICAgICAgICBMaW5lYXJTUkdCQ29sb3JTcGFjZSxcbiAgICAgICAgICByZWplY3RcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNO1xuICB9XG4gIGV4dGVuZFRleHR1cmUodGV4dHVyZSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCh0cmFuc2Zvcm0udGV4Q29vcmQgPT09IHZvaWQgMCB8fCB0cmFuc2Zvcm0udGV4Q29vcmQgPT09IHRleHR1cmUuY2hhbm5lbCkgJiYgdHJhbnNmb3JtLm9mZnNldCA9PT0gdm9pZCAwICYmIHRyYW5zZm9ybS5yb3RhdGlvbiA9PT0gdm9pZCAwICYmIHRyYW5zZm9ybS5zY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gICAgdGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcbiAgICBpZiAodHJhbnNmb3JtLnRleENvb3JkICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUuY2hhbm5lbCA9IHRyYW5zZm9ybS50ZXhDb29yZDtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5vZmZzZXQgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KHRyYW5zZm9ybS5vZmZzZXQpO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0uc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KHRyYW5zZm9ybS5zY2FsZSk7XG4gICAgfVxuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG59XG5jbGFzcyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OO1xuICB9XG59XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuICAgIHN1cGVyKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuICB9XG4gIGNvcHlTYW1wbGVWYWx1ZV8oaW5kZXgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlciwgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsIHZhbHVlU2l6ZSA9IHRoaXMudmFsdWVTaXplLCBvZmZzZXQgPSBpbmRleCAqIHZhbHVlU2l6ZSAqIDMgKyB2YWx1ZVNpemU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHZhbHVlU2l6ZTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSB2YWx1ZXNbb2Zmc2V0ICsgaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcjtcbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcztcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcbiAgICBjb25zdCBzdHJpZGUyID0gc3RyaWRlICogMjtcbiAgICBjb25zdCBzdHJpZGUzID0gc3RyaWRlICogMztcbiAgICBjb25zdCB0ZCA9IHQxIC0gdDA7XG4gICAgY29uc3QgcCA9ICh0IC0gdDApIC8gdGQ7XG4gICAgY29uc3QgcHAgPSBwICogcDtcbiAgICBjb25zdCBwcHAgPSBwcCAqIHA7XG4gICAgY29uc3Qgb2Zmc2V0MSA9IGkxICogc3RyaWRlMztcbiAgICBjb25zdCBvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZTM7XG4gICAgY29uc3QgczIgPSAtMiAqIHBwcCArIDMgKiBwcDtcbiAgICBjb25zdCBzMyA9IHBwcCAtIHBwO1xuICAgIGNvbnN0IHMwID0gMSAtIHMyO1xuICAgIGNvbnN0IHMxID0gczMgLSBwcCArIHA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgaSsrKSB7XG4gICAgICBjb25zdCBwMCA9IHZhbHVlc1tvZmZzZXQwICsgaSArIHN0cmlkZV07XG4gICAgICBjb25zdCBtMCA9IHZhbHVlc1tvZmZzZXQwICsgaSArIHN0cmlkZTJdICogdGQ7XG4gICAgICBjb25zdCBwMSA9IHZhbHVlc1tvZmZzZXQxICsgaSArIHN0cmlkZV07XG4gICAgICBjb25zdCBtMSA9IHZhbHVlc1tvZmZzZXQxICsgaV0gKiB0ZDtcbiAgICAgIHJlc3VsdFtpXSA9IHMwICogcDAgKyBzMSAqIG0wICsgczIgKiBwMSArIHMzICogbTE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNvbnN0IF9xID0gLyogQF9fUFVSRV9fICovIG5ldyBRdWF0ZXJuaW9uKCk7XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgZXh0ZW5kcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCB7XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpO1xuICAgIF9xLmZyb21BcnJheShyZXN1bHQpLm5vcm1hbGl6ZSgpLnRvQXJyYXkocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBXRUJHTF9DT05TVEFOVFMgPSB7XG4gIEZMT0FUOiA1MTI2LFxuICAvL0ZMT0FUX01BVDI6IDM1Njc0LFxuICBGTE9BVF9NQVQzOiAzNTY3NSxcbiAgRkxPQVRfTUFUNDogMzU2NzYsXG4gIEZMT0FUX1ZFQzI6IDM1NjY0LFxuICBGTE9BVF9WRUMzOiAzNTY2NSxcbiAgRkxPQVRfVkVDNDogMzU2NjYsXG4gIExJTkVBUjogOTcyOSxcbiAgUkVQRUFUOiAxMDQ5NyxcbiAgU0FNUExFUl8yRDogMzU2NzgsXG4gIFBPSU5UUzogMCxcbiAgTElORVM6IDEsXG4gIExJTkVfTE9PUDogMixcbiAgTElORV9TVFJJUDogMyxcbiAgVFJJQU5HTEVTOiA0LFxuICBUUklBTkdMRV9TVFJJUDogNSxcbiAgVFJJQU5HTEVfRkFOOiA2LFxuICBVTlNJR05FRF9CWVRFOiA1MTIxLFxuICBVTlNJR05FRF9TSE9SVDogNTEyM1xufTtcbmNvbnN0IFdFQkdMX0NPTVBPTkVOVF9UWVBFUyA9IHtcbiAgNTEyMDogSW50OEFycmF5LFxuICA1MTIxOiBVaW50OEFycmF5LFxuICA1MTIyOiBJbnQxNkFycmF5LFxuICA1MTIzOiBVaW50MTZBcnJheSxcbiAgNTEyNTogVWludDMyQXJyYXksXG4gIDUxMjY6IEZsb2F0MzJBcnJheVxufTtcbmNvbnN0IFdFQkdMX0ZJTFRFUlMgPSB7XG4gIDk3Mjg6IE5lYXJlc3RGaWx0ZXIsXG4gIDk3Mjk6IExpbmVhckZpbHRlcixcbiAgOTk4NDogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODU6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODY6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG4gIDk5ODc6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcbmNvbnN0IFdFQkdMX1dSQVBQSU5HUyA9IHtcbiAgMzMwNzE6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIDMzNjQ4OiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuICAxMDQ5NzogUmVwZWF0V3JhcHBpbmdcbn07XG5jb25zdCBXRUJHTF9UWVBFX1NJWkVTID0ge1xuICBTQ0FMQVI6IDEsXG4gIFZFQzI6IDIsXG4gIFZFQzM6IDMsXG4gIFZFQzQ6IDQsXG4gIE1BVDI6IDQsXG4gIE1BVDM6IDksXG4gIE1BVDQ6IDE2XG59O1xuY29uc3QgQVRUUklCVVRFUyA9IHtcbiAgUE9TSVRJT046IFwicG9zaXRpb25cIixcbiAgTk9STUFMOiBcIm5vcm1hbFwiLFxuICBUQU5HRU5UOiBcInRhbmdlbnRcIixcbiAgLy8gdXYgPT4gdXYxLCA0IHV2IGNoYW5uZWxzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTk0M1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU3ODhcbiAgLi4udmVyc2lvbiA+PSAxNTIgPyB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYxXCIsXG4gICAgVEVYQ09PUkRfMjogXCJ1djJcIixcbiAgICBURVhDT09SRF8zOiBcInV2M1wiXG4gIH0gOiB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYyXCJcbiAgfSxcbiAgQ09MT1JfMDogXCJjb2xvclwiLFxuICBXRUlHSFRTXzA6IFwic2tpbldlaWdodFwiLFxuICBKT0lOVFNfMDogXCJza2luSW5kZXhcIlxufTtcbmNvbnN0IFBBVEhfUFJPUEVSVElFUyA9IHtcbiAgc2NhbGU6IFwic2NhbGVcIixcbiAgdHJhbnNsYXRpb246IFwicG9zaXRpb25cIixcbiAgcm90YXRpb246IFwicXVhdGVybmlvblwiLFxuICB3ZWlnaHRzOiBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiXG59O1xuY29uc3QgSU5URVJQT0xBVElPTiA9IHtcbiAgQ1VCSUNTUExJTkU6IHZvaWQgMCxcbiAgLy8gV2UgdXNlIGEgY3VzdG9tIGludGVycG9sYW50IChHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGF0aW9uKSBmb3IgQ1VCSUNTUExJTkUgdHJhY2tzLiBFYWNoXG4gIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuICBMSU5FQVI6IEludGVycG9sYXRlTGluZWFyLFxuICBTVEVQOiBJbnRlcnBvbGF0ZURpc2NyZXRlXG59O1xuY29uc3QgQUxQSEFfTU9ERVMgPSB7XG4gIE9QQVFVRTogXCJPUEFRVUVcIixcbiAgTUFTSzogXCJNQVNLXCIsXG4gIEJMRU5EOiBcIkJMRU5EXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoY2FjaGUpIHtcbiAgaWYgKGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdID09PSB2b2lkIDApIHtcbiAgICBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICBlbWlzc2l2ZTogMCxcbiAgICAgIG1ldGFsbmVzczogMSxcbiAgICAgIHJvdWdobmVzczogMSxcbiAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogdHJ1ZSxcbiAgICAgIHNpZGU6IEZyb250U2lkZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXTtcbn1cbmZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBvYmplY3REZWYuZXh0ZW5zaW9ucykge1xuICAgIGlmIChrbm93bkV4dGVuc2lvbnNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zW25hbWVdID0gb2JqZWN0RGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG9iamVjdCwgZ2x0ZkRlZikge1xuICBpZiAoZ2x0ZkRlZi5leHRyYXMgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqZWN0LnVzZXJEYXRhLCBnbHRmRGVmLmV4dHJhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IElnbm9yaW5nIHByaW1pdGl2ZSB0eXBlIC5leHRyYXMsIFwiICsgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCB0YXJnZXRzLCBwYXJzZXIpIHtcbiAgbGV0IGhhc01vcnBoUG9zaXRpb24gPSBmYWxzZTtcbiAgbGV0IGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaENvbG9yID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhQb3NpdGlvbiA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5OT1JNQUwgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoTm9ybWFsID0gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0LkNPTE9SXzAgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoQ29sb3IgPSB0cnVlO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uICYmIGhhc01vcnBoTm9ybWFsICYmIGhhc01vcnBoQ29sb3IpXG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIWhhc01vcnBoUG9zaXRpb24gJiYgIWhhc01vcnBoTm9ybWFsICYmICFoYXNNb3JwaENvbG9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2VvbWV0cnkpO1xuICBjb25zdCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ05vcm1hbEFjY2Vzc29ycyA9IFtdO1xuICBjb25zdCBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbikge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5QT1NJVElPTikgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoTm9ybWFsKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5OT1JNQUwpIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5DT0xPUl8wKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIFByb21pc2UuYWxsKHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ05vcm1hbEFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ0NvbG9yQWNjZXNzb3JzKVxuICBdKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29ycykge1xuICAgIGNvbnN0IG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWzBdO1xuICAgIGNvbnN0IG1vcnBoTm9ybWFscyA9IGFjY2Vzc29yc1sxXTtcbiAgICBjb25zdCBtb3JwaENvbG9ycyA9IGFjY2Vzc29yc1syXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbilcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IG1vcnBoUG9zaXRpb25zO1xuICAgIGlmIChoYXNNb3JwaE5vcm1hbClcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBtb3JwaE5vcm1hbHM7XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgPSBtb3JwaENvbG9ycztcbiAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKSB7XG4gIG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG4gIGlmIChtZXNoRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG1lc2hEZWYud2VpZ2h0c1tpXTtcbiAgICB9XG4gIH1cbiAgaWYgKG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkobWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXMpKSB7XG4gICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcztcbiAgICBpZiAobWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID09PSB0YXJnZXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3RhcmdldE5hbWVzW2ldXSA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZURlZikge1xuICBsZXQgZ2VvbWV0cnlLZXk7XG4gIGNvbnN0IGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl07XG4gIGlmIChkcmFjb0V4dGVuc2lvbikge1xuICAgIGdlb21ldHJ5S2V5ID0gXCJkcmFjbzpcIiArIGRyYWNvRXh0ZW5zaW9uLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoZHJhY29FeHRlbnNpb24uYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgZ2VvbWV0cnlLZXkgPSBwcmltaXRpdmVEZWYuaW5kaWNlcyArIFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYuYXR0cmlidXRlcykgKyBcIjpcIiArIHByaW1pdGl2ZURlZi5tb2RlO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlRGVmLnRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgZ2VvbWV0cnlLZXkgKz0gXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KHByaW1pdGl2ZURlZi50YXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5S2V5O1xufVxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlc0tleShhdHRyaWJ1dGVzKSB7XG4gIGxldCBhdHRyaWJ1dGVzS2V5ID0gXCJcIjtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgYXR0cmlidXRlc0tleSArPSBrZXlzW2ldICsgXCI6XCIgKyBhdHRyaWJ1dGVzW2tleXNbaV1dICsgXCI7XCI7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXNLZXk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoY29uc3RydWN0b3IpIHtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAxMjc7XG4gICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAyNTU7XG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAzMjc2NztcbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyA2NTUzNTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgbm9ybWFsaXplZCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlVVJJTWltZVR5cGUodXJpKSB7XG4gIGlmICh1cmkuc2VhcmNoKC9cXC5qcGU/ZygkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC9qcGVnLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2UvanBlZ1wiO1xuICBpZiAodXJpLnNlYXJjaCgvXFwud2VicCgkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC93ZWJwLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2Uvd2VicFwiO1xuICByZXR1cm4gXCJpbWFnZS9wbmdcIjtcbn1cbmNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWF0cml4NCgpO1xuY2xhc3MgR0xURlBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGpzb24gPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgR0xURlJlZ2lzdHJ5KCk7XG4gICAgdGhpcy5hc3NvY2lhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJpbWl0aXZlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm5vZGVDYWNoZSA9IHt9O1xuICAgIHRoaXMubWVzaENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLmNhbWVyYUNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLmxpZ2h0Q2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuc291cmNlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZU5hbWVzVXNlZCA9IHt9O1xuICAgIGxldCBpc1NhZmFyaSA9IGZhbHNlO1xuICAgIGxldCBpc0ZpcmVmb3ggPSBmYWxzZTtcbiAgICBsZXQgZmlyZWZveFZlcnNpb24gPSAtMTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID09PSB0cnVlO1xuICAgICAgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+IC0xO1xuICAgICAgZmlyZWZveFZlcnNpb24gPSBpc0ZpcmVmb3ggPyBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFswLTldKylcXC4vKVsxXSA6IC0xO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSBcInVuZGVmaW5lZFwiIHx8IGlzU2FmYXJpIHx8IGlzRmlyZWZveCAmJiBmaXJlZm94VmVyc2lvbiA8IDk4KSB7XG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBJbWFnZUJpdG1hcExvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZUxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgIHRoaXMudGV4dHVyZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMub3B0aW9ucy5yZXF1ZXN0SGVhZGVyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgdGhpcy5maWxlTG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IFwidXNlLWNyZWRlbnRpYWxzXCIpIHtcbiAgICAgIHRoaXMuZmlsZUxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModHJ1ZSk7XG4gICAgfVxuICB9XG4gIHNldEV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gIH1cbiAgc2V0UGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2lucztcbiAgfVxuICBwYXJzZShvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICB0aGlzLmNhY2hlLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5fbWFya0RlZnMgJiYgZXh0Ll9tYXJrRGVmcygpO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmJlZm9yZVJvb3QgJiYgZXh0LmJlZm9yZVJvb3QoKTtcbiAgICAgIH0pXG4gICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcInNjZW5lXCIpLFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwiYW5pbWF0aW9uXCIpLFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwiY2FtZXJhXCIpXG4gICAgICBdKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzY2VuZTogZGVwZW5kZW5jaWVzWzBdW2pzb24uc2NlbmUgfHwgMF0sXG4gICAgICAgIHNjZW5lczogZGVwZW5kZW5jaWVzWzBdLFxuICAgICAgICBhbmltYXRpb25zOiBkZXBlbmRlbmNpZXNbMV0sXG4gICAgICAgIGNhbWVyYXM6IGRlcGVuZGVuY2llc1syXSxcbiAgICAgICAgYXNzZXQ6IGpzb24uYXNzZXQsXG4gICAgICAgIHBhcnNlcixcbiAgICAgICAgdXNlckRhdGE6IHt9XG4gICAgICB9O1xuICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIHJlc3VsdCwganNvbik7XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHJlc3VsdCwganNvbik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHBhcnNlci5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgIHJldHVybiBleHQuYWZ0ZXJSb290ICYmIGV4dC5hZnRlclJvb3QocmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiByZXN1bHQuc2NlbmVzKSB7XG4gICAgICAgICAgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgfVxuICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKG9uRXJyb3IpO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrcyB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlLlxuICAgKi9cbiAgX21hcmtEZWZzKCkge1xuICAgIGNvbnN0IG5vZGVEZWZzID0gdGhpcy5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHNraW5EZWZzID0gdGhpcy5qc29uLnNraW5zIHx8IFtdO1xuICAgIGNvbnN0IG1lc2hEZWZzID0gdGhpcy5qc29uLm1lc2hlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBza2luSW5kZXggPSAwLCBza2luTGVuZ3RoID0gc2tpbkRlZnMubGVuZ3RoOyBza2luSW5kZXggPCBza2luTGVuZ3RoOyBza2luSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9pbnRzID0gc2tpbkRlZnNbc2tpbkluZGV4XS5qb2ludHM7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBqb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBub2RlRGVmc1tqb2ludHNbaV1dLmlzQm9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLm1lc2ggIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlUmVmKHRoaXMubWVzaENhY2hlLCBub2RlRGVmLm1lc2gpO1xuICAgICAgICBpZiAobm9kZURlZi5za2luICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBtZXNoRGVmc1tub2RlRGVmLm1lc2hdLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZURlZi5jYW1lcmEgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlUmVmKHRoaXMuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvdW50cyByZWZlcmVuY2VzIHRvIHNoYXJlZCBub2RlIC8gT2JqZWN0M0QgcmVzb3VyY2VzLiBUaGVzZSByZXNvdXJjZXNcbiAgICogY2FuIGJlIHJldXNlZCwgb3IgXCJpbnN0YW50aWF0ZWRcIiwgYXQgbXVsdGlwbGUgbm9kZXMgaW4gdGhlIHNjZW5lXG4gICAqIGhpZXJhcmNoeS4gTWVzaCwgQ2FtZXJhLCBhbmQgTGlnaHQgaW5zdGFuY2VzIGFyZSBpbnN0YW50aWF0ZWQgYW5kIG11c3RcbiAgICogYmUgbWFya2VkLiBOb24tc2NlbmVncmFwaCByZXNvdXJjZXMgKGxpa2UgTWF0ZXJpYWxzLCBHZW9tZXRyaWVzLCBhbmRcbiAgICogVGV4dHVyZXMpIGNhbiBiZSByZXVzZWQgZGlyZWN0bHkgYW5kIGFyZSBub3QgbWFya2VkIGhlcmUuXG4gICAqXG4gICAqIEV4YW1wbGU6IENlc2l1bU1pbGtUcnVjayBzYW1wbGUgbW9kZWwgcmV1c2VzIFwiV2hlZWxcIiBtZXNoZXMuXG4gICAqL1xuICBfYWRkTm9kZVJlZihjYWNoZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY2FjaGUucmVmc1tpbmRleF0gPT09IHZvaWQgMCkge1xuICAgICAgY2FjaGUucmVmc1tpbmRleF0gPSBjYWNoZS51c2VzW2luZGV4XSA9IDA7XG4gICAgfVxuICAgIGNhY2hlLnJlZnNbaW5kZXhdKys7XG4gIH1cbiAgLyoqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYSBzaGFyZWQgcmVzb3VyY2UsIGNsb25pbmcgaXQgaWYgbmVjZXNzYXJ5LiAqL1xuICBfZ2V0Tm9kZVJlZihjYWNoZSwgaW5kZXgsIG9iamVjdCkge1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA8PSAxKVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICBjb25zdCByZWYgPSBvYmplY3QuY2xvbmUoKTtcbiAgICBjb25zdCB1cGRhdGVNYXBwaW5ncyA9IChvcmlnaW5hbCwgY2xvbmUpID0+IHtcbiAgICAgIGNvbnN0IG1hcHBpbmdzID0gdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG9yaWdpbmFsKTtcbiAgICAgIGlmIChtYXBwaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnNldChjbG9uZSwgbWFwcGluZ3MpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbaSwgY2hpbGRdIG9mIG9yaWdpbmFsLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICB1cGRhdGVNYXBwaW5ncyhjaGlsZCwgY2xvbmUuY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlTWFwcGluZ3Mob2JqZWN0LCByZWYpO1xuICAgIHJlZi5uYW1lICs9IFwiX2luc3RhbmNlX1wiICsgY2FjaGUudXNlc1tpbmRleF0rKztcbiAgICByZXR1cm4gcmVmO1xuICB9XG4gIF9pbnZva2VPbmUoZnVuYykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7XG4gICAgZXh0ZW5zaW9ucy5wdXNoKHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9pbnZva2VBbGwoZnVuYykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7XG4gICAgZXh0ZW5zaW9ucy51bnNoaWZ0KHRoaXMpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoZXh0ZW5zaW9uc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICBwZW5kaW5nLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSBzcGVjaWZpZWQgZGVwZW5kZW5jeSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRHxNYXRlcmlhbHxUSFJFRS5UZXh0dXJlfEFuaW1hdGlvbkNsaXB8QXJyYXlCdWZmZXJ8T2JqZWN0Pn1cbiAgICovXG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IHR5cGUgKyBcIjpcIiArIGluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzY2VuZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTY2VuZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE5vZGUgJiYgZXh0LmxvYWROb2RlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc2hcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWVzaCAmJiBleHQubG9hZE1lc2goaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWNjZXNzb3JcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQWNjZXNzb3IoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnVmZmVyVmlld1wiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRCdWZmZXJWaWV3ICYmIGV4dC5sb2FkQnVmZmVyVmlldyhpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQnVmZmVyKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hdGVyaWFsXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE1hdGVyaWFsICYmIGV4dC5sb2FkTWF0ZXJpYWwoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dHVyZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRUZXh0dXJlICYmIGV4dC5sb2FkVGV4dHVyZShpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJza2luXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNraW4oaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYW5pbWF0aW9uXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEFuaW1hdGlvbiAmJiBleHQubG9hZEFuaW1hdGlvbihpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYW1lcmFcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQ2FtZXJhKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dCAhPSB0aGlzICYmIGV4dC5nZXREZXBlbmRlbmN5ICYmIGV4dC5nZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgZGVwZW5kZW5jeSk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE9iamVjdD4+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jaWVzKHR5cGUpIHtcbiAgICBsZXQgZGVwZW5kZW5jaWVzID0gdGhpcy5jYWNoZS5nZXQodHlwZSk7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgICBjb25zdCBkZWZzID0gdGhpcy5qc29uW3R5cGUgKyAodHlwZSA9PT0gXCJtZXNoXCIgPyBcImVzXCIgOiBcInNcIildIHx8IFtdO1xuICAgICAgZGVwZW5kZW5jaWVzID0gUHJvbWlzZS5hbGwoXG4gICAgICAgIGRlZnMubWFwKGZ1bmN0aW9uKGRlZiwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHRoaXMuY2FjaGUuYWRkKHR5cGUsIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGxvYWRCdWZmZXIoYnVmZmVySW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJEZWYgPSB0aGlzLmpzb24uYnVmZmVyc1tidWZmZXJJbmRleF07XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5maWxlTG9hZGVyO1xuICAgIGlmIChidWZmZXJEZWYudHlwZSAmJiBidWZmZXJEZWYudHlwZSAhPT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBcIiArIGJ1ZmZlckRlZi50eXBlICsgXCIgYnVmZmVyIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGlmIChidWZmZXJEZWYudXJpID09PSB2b2lkIDAgJiYgYnVmZmVySW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXS5ib2R5KTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBsb2FkZXIubG9hZChMb2FkZXJVdGlscy5yZXNvbHZlVVJMKGJ1ZmZlckRlZi51cmksIG9wdGlvbnMucGF0aCksIHJlc29sdmUsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IEZhaWxlZCB0byBsb2FkIGJ1ZmZlciBcIicgKyBidWZmZXJEZWYudXJpICsgJ1wiLicpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVmlld0luZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlclZpZXcoYnVmZmVyVmlld0luZGV4KSB7XG4gICAgY29uc3QgYnVmZmVyVmlld0RlZiA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1tidWZmZXJWaWV3SW5kZXhdO1xuICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgYnVmZmVyVmlld0RlZi5idWZmZXIpLnRoZW4oZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoID0gYnVmZmVyVmlld0RlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYnVmZmVyVmlld0RlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuICAgKi9cbiAgbG9hZEFjY2Vzc29yKGFjY2Vzc29ySW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzW2FjY2Vzc29ySW5kZXhdO1xuICAgIGlmIChhY2Nlc3NvckRlZi5idWZmZXJWaWV3ID09PSB2b2lkIDAgJiYgYWNjZXNzb3JEZWYuc3BhcnNlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1thY2Nlc3NvckRlZi50eXBlXTtcbiAgICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdCdWZmZXJWaWV3cyA9IFtdO1xuICAgIGlmIChhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuYnVmZmVyVmlldykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaChudWxsKTtcbiAgICB9XG4gICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ1ZmZlclZpZXcpKTtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5idWZmZXJWaWV3KSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nQnVmZmVyVmlld3MpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlld3MpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBidWZmZXJWaWV3c1swXTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1thY2Nlc3NvckRlZi50eXBlXTtcbiAgICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICBjb25zdCBlbGVtZW50Qnl0ZXMgPSBUeXBlZEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgY29uc3QgaXRlbUJ5dGVzID0gZWxlbWVudEJ5dGVzICogaXRlbVNpemU7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYWNjZXNzb3JEZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgY29uc3QgYnl0ZVN0cmlkZSA9IGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCA/IGpzb24uYnVmZmVyVmlld3NbYWNjZXNzb3JEZWYuYnVmZmVyVmlld10uYnl0ZVN0cmlkZSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgbGV0IGFycmF5LCBidWZmZXJBdHRyaWJ1dGU7XG4gICAgICBpZiAoYnl0ZVN0cmlkZSAmJiBieXRlU3RyaWRlICE9PSBpdGVtQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgaWJTbGljZSA9IE1hdGguZmxvb3IoYnl0ZU9mZnNldCAvIGJ5dGVTdHJpZGUpO1xuICAgICAgICBjb25zdCBpYkNhY2hlS2V5ID0gXCJJbnRlcmxlYXZlZEJ1ZmZlcjpcIiArIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgKyBcIjpcIiArIGliU2xpY2UgKyBcIjpcIiArIGFjY2Vzc29yRGVmLmNvdW50O1xuICAgICAgICBsZXQgaWIgPSBwYXJzZXIuY2FjaGUuZ2V0KGliQ2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWliKSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3LCBpYlNsaWNlICogYnl0ZVN0cmlkZSwgYWNjZXNzb3JEZWYuY291bnQgKiBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyk7XG4gICAgICAgICAgcGFyc2VyLmNhY2hlLmFkZChpYkNhY2hlS2V5LCBpYik7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgIGliLFxuICAgICAgICAgIGl0ZW1TaXplLFxuICAgICAgICAgIGJ5dGVPZmZzZXQgJSBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzLFxuICAgICAgICAgIG5vcm1hbGl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChidWZmZXJWaWV3ID09PSBudWxsKSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGJ5dGVPZmZzZXQsIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBpdGVtU2l6ZUluZGljZXMgPSBXRUJHTF9UWVBFX1NJWkVTLlNDQUxBUjtcbiAgICAgICAgY29uc3QgVHlwZWRBcnJheUluZGljZXMgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuY29tcG9uZW50VHlwZV07XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRJbmRpY2VzID0gYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0VmFsdWVzID0gYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IHNwYXJzZUluZGljZXMgPSBuZXcgVHlwZWRBcnJheUluZGljZXMoXG4gICAgICAgICAgYnVmZmVyVmlld3NbMV0sXG4gICAgICAgICAgYnl0ZU9mZnNldEluZGljZXMsXG4gICAgICAgICAgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNwYXJzZVZhbHVlcyA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXdzWzJdLCBieXRlT2Zmc2V0VmFsdWVzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIGlmIChidWZmZXJWaWV3ICE9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5hcnJheS5zbGljZSgpLFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLml0ZW1TaXplLFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHNwYXJzZUluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3BhcnNlSW5kaWNlc1tpXTtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WChpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZV0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSAyKVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFkoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAxXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDMpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WihpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDJdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gNClcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRXKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgM10pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgaXRlbVNpemUgaW4gc3BhcnNlIEJ1ZmZlckF0dHJpYnV0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCN0ZXh0dXJlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gdGV4dHVyZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuVGV4dHVyZXxudWxsPn1cbiAgICovXG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZUluZGV4ID0gdGV4dHVyZURlZi5zb3VyY2U7XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZURlZi51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2VEZWYudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcik7XG4gIH1cbiAgbG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIHNvdXJjZUluZGV4LCBsb2FkZXIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgY2FjaGVLZXkgPSAoc291cmNlRGVmLnVyaSB8fCBzb3VyY2VEZWYuYnVmZmVyVmlldykgKyBcIjpcIiArIHRleHR1cmVEZWYuc2FtcGxlcjtcbiAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5sb2FkSW1hZ2VTb3VyY2Uoc291cmNlSW5kZXgsIGxvYWRlcikudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICB0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICB0ZXh0dXJlLm5hbWUgPSB0ZXh0dXJlRGVmLm5hbWUgfHwgc291cmNlRGVmLm5hbWUgfHwgXCJcIjtcbiAgICAgIGlmICh0ZXh0dXJlLm5hbWUgPT09IFwiXCIgJiYgdHlwZW9mIHNvdXJjZURlZi51cmkgPT09IFwic3RyaW5nXCIgJiYgc291cmNlRGVmLnVyaS5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9cIikgPT09IGZhbHNlKSB7XG4gICAgICAgIHRleHR1cmUubmFtZSA9IHNvdXJjZURlZi51cmk7XG4gICAgICB9XG4gICAgICBjb25zdCBzYW1wbGVycyA9IGpzb24uc2FtcGxlcnMgfHwge307XG4gICAgICBjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbdGV4dHVyZURlZi5zYW1wbGVyXSB8fCB7fTtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gV0VCR0xfRklMVEVSU1tzYW1wbGVyLm1hZ0ZpbHRlcl0gfHwgTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWluRmlsdGVyXSB8fCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLndyYXBTID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFNdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgdGV4dHVyZS53cmFwVCA9IFdFQkdMX1dSQVBQSU5HU1tzYW1wbGVyLndyYXBUXSB8fCBSZXBlYXRXcmFwcGluZztcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KHRleHR1cmUsIHsgdGV4dHVyZXM6IHRleHR1cmVJbmRleCB9KTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBsb2FkSW1hZ2VTb3VyY2Uoc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0udGhlbigodGV4dHVyZSkgPT4gdGV4dHVyZS5jbG9uZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGNvbnN0IFVSTCA9IHNlbGYuVVJMIHx8IHNlbGYud2Via2l0VVJMO1xuICAgIGxldCBzb3VyY2VVUkkgPSBzb3VyY2VEZWYudXJpIHx8IFwiXCI7XG4gICAgbGV0IGlzT2JqZWN0VVJMID0gZmFsc2U7XG4gICAgaWYgKHNvdXJjZURlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgIHNvdXJjZVVSSSA9IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBzb3VyY2VEZWYuYnVmZmVyVmlldykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICAgIGlzT2JqZWN0VVJMID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJWaWV3XSwgeyB0eXBlOiBzb3VyY2VEZWYubWltZVR5cGUgfSk7XG4gICAgICAgIHNvdXJjZVVSSSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiBzb3VyY2VVUkk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZURlZi51cmkgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgXCIgKyBzb3VyY2VJbmRleCArIFwiIGlzIG1pc3NpbmcgVVJJIGFuZCBidWZmZXJWaWV3XCIpO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHNvdXJjZVVSSSkudGhlbihmdW5jdGlvbihzb3VyY2VVUkkyKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBvbkxvYWQgPSByZXNvbHZlO1xuICAgICAgICBpZiAobG9hZGVyLmlzSW1hZ2VCaXRtYXBMb2FkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBvbkxvYWQgPSBmdW5jdGlvbihpbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlQml0bWFwKTtcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0dXJlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoc291cmNlVVJJMiwgb3B0aW9ucy5wYXRoKSwgb25Mb2FkLCB2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIGlmIChpc09iamVjdFVSTCA9PT0gdHJ1ZSkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNvdXJjZVVSSSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHRleHR1cmUsIHNvdXJjZURlZik7XG4gICAgICB0ZXh0dXJlLnVzZXJEYXRhLm1pbWVUeXBlID0gc291cmNlRGVmLm1pbWVUeXBlIHx8IGdldEltYWdlVVJJTWltZVR5cGUoc291cmNlRGVmLnVyaSk7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IENvdWxkbid0IGxvYWQgdGV4dHVyZVwiLCBzb3VyY2VVUkkpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBhc3NpZ25zIGEgdGV4dHVyZSB0byB0aGUgZ2l2ZW4gbWF0ZXJpYWwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsUGFyYW1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEZWZcbiAgICogQHJldHVybiB7UHJvbWlzZTxUZXh0dXJlPn1cbiAgICovXG4gIGFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIG1hcE5hbWUsIG1hcERlZiwgY29sb3JTcGFjZSkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcInRleHR1cmVcIiwgbWFwRGVmLmluZGV4KS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIGlmICghdGV4dHVyZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobWFwRGVmLnRleENvb3JkICE9PSB2b2lkIDAgJiYgbWFwRGVmLnRleENvb3JkID4gMCkge1xuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgICAgICB0ZXh0dXJlLmNoYW5uZWwgPSBtYXBEZWYudGV4Q29vcmQ7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VyLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG1hcERlZi5leHRlbnNpb25zICE9PSB2b2lkIDAgPyBtYXBEZWYuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0gOiB2b2lkIDA7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBnbHRmUmVmZXJlbmNlID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQodGV4dHVyZSk7XG4gICAgICAgICAgdGV4dHVyZSA9IHBhcnNlci5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXS5leHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgZ2x0ZlJlZmVyZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb2xvclNwYWNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvclNwYWNlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgIGNvbG9yU3BhY2UgPSBjb2xvclNwYWNlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgICBpZiAoXCJjb2xvclNwYWNlXCIgaW4gdGV4dHVyZSlcbiAgICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlID8gc1JHQkVuY29kaW5nIDogTGluZWFyRW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFBhcmFtc1ttYXBOYW1lXSA9IHRleHR1cmU7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXNzaWducyBmaW5hbCBtYXRlcmlhbCB0byBhIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS4gVGhlIGluc3RhbmNlXG4gICAqIGFscmVhZHkgaGFzIGEgbWF0ZXJpYWwgKGdlbmVyYXRlZCBmcm9tIHRoZSBnbFRGIG1hdGVyaWFsIG9wdGlvbnMgYWxvbmUpXG4gICAqIGJ1dCByZXVzZSBvZiB0aGUgc2FtZSBnbFRGIG1hdGVyaWFsIG1heSByZXF1aXJlIG11bHRpcGxlIHRocmVlanMgbWF0ZXJpYWxzXG4gICAqIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBwcmltaXRpdmUgdHlwZXMsIGRlZmluZXMsIGV0Yy4gTmV3IG1hdGVyaWFscyB3aWxsXG4gICAqIGJlIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LCBhbmQgcmV1c2VkIGZyb20gYSBjYWNoZS5cbiAgICogQHBhcmFtICB7T2JqZWN0M0R9IG1lc2ggTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLlxuICAgKi9cbiAgYXNzaWduRmluYWxNYXRlcmlhbChtZXNoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuICAgIGxldCBtYXRlcmlhbCA9IG1lc2gubWF0ZXJpYWw7XG4gICAgY29uc3QgdXNlRGVyaXZhdGl2ZVRhbmdlbnRzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ID09PSB2b2lkIDA7XG4gICAgY29uc3QgdXNlVmVydGV4Q29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IHVzZUZsYXRTaGFkaW5nID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwgPT09IHZvaWQgMDtcbiAgICBpZiAobWVzaC5pc1BvaW50cykge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBcIlBvaW50c01hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZDtcbiAgICAgIGxldCBwb2ludHNNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghcG9pbnRzTWF0ZXJpYWwpIHtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoKTtcbiAgICAgICAgTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChwb2ludHNNYXRlcmlhbCwgbWF0ZXJpYWwpO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5jb2xvci5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIHBvaW50c01hdGVyaWFsKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gcG9pbnRzTWF0ZXJpYWw7XG4gICAgfSBlbHNlIGlmIChtZXNoLmlzTGluZSkge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBcIkxpbmVCYXNpY01hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZDtcbiAgICAgIGxldCBsaW5lTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIWxpbmVNYXRlcmlhbCkge1xuICAgICAgICBsaW5lTWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICAgICAgTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChsaW5lTWF0ZXJpYWwsIG1hdGVyaWFsKTtcbiAgICAgICAgbGluZU1hdGVyaWFsLmNvbG9yLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgICAgICBsaW5lTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgbGluZU1hdGVyaWFsKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gbGluZU1hdGVyaWFsO1xuICAgIH1cbiAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzIHx8IHVzZVZlcnRleENvbG9ycyB8fCB1c2VGbGF0U2hhZGluZykge1xuICAgICAgbGV0IGNhY2hlS2V5ID0gXCJDbG9uZWRNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQgKyBcIjpcIjtcbiAgICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwiZGVyaXZhdGl2ZS10YW5nZW50czpcIjtcbiAgICAgIGlmICh1c2VWZXJ0ZXhDb2xvcnMpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwidmVydGV4LWNvbG9yczpcIjtcbiAgICAgIGlmICh1c2VGbGF0U2hhZGluZylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJmbGF0LXNoYWRpbmc6XCI7XG4gICAgICBsZXQgY2FjaGVkTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIWNhY2hlZE1hdGVyaWFsKSB7XG4gICAgICAgIGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgaWYgKHVzZVZlcnRleENvbG9ycylcbiAgICAgICAgICBjYWNoZWRNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuICAgICAgICBpZiAodXNlRmxhdFNoYWRpbmcpXG4gICAgICAgICAgY2FjaGVkTWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzKSB7XG4gICAgICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlKVxuICAgICAgICAgICAgY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUueSAqPSAtMTtcbiAgICAgICAgICBpZiAoY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUpXG4gICAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZS55ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBjYWNoZWRNYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnNldChjYWNoZWRNYXRlcmlhbCwgdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG1hdGVyaWFsKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IGNhY2hlZE1hdGVyaWFsO1xuICAgIH1cbiAgICBtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtYXRlcmlhbHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hdGVyaWFsSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxNYXRlcmlhbD59XG4gICAqL1xuICBsb2FkTWF0ZXJpYWwobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0ganNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgbGV0IG1hdGVyaWFsVHlwZTtcbiAgICBjb25zdCBtYXRlcmlhbFBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG1hdGVyaWFsRXh0ZW5zaW9ucyA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwge307XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGlmIChtYXRlcmlhbEV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUXSkge1xuICAgICAgY29uc3Qga211RXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVRdO1xuICAgICAgbWF0ZXJpYWxUeXBlID0ga211RXh0ZW5zaW9uLmdldE1hdGVyaWFsVHlwZSgpO1xuICAgICAgcGVuZGluZy5wdXNoKGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcyB8fCB7fTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEpO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvci5zZXRSR0IoYXJyYXlbMF0sIGFycmF5WzFdLCBhcnJheVsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbM107XG4gICAgICB9XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsUGFyYW1zLm1ldGFsbmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yICE9PSB2b2lkIDAgPyBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciA6IDE7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5yb3VnaG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA6IDE7XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1ldGFsbmVzc01hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpKTtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInJvdWdobmVzc01hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsVHlwZSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4dC5nZXRNYXRlcmlhbFR5cGUgJiYgZXh0LmdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zICYmIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmRvdWJsZVNpZGVkID09PSB0cnVlKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaWRlID0gRG91YmxlU2lkZTtcbiAgICB9XG4gICAgY29uc3QgYWxwaGFNb2RlID0gbWF0ZXJpYWxEZWYuYWxwaGFNb2RlIHx8IEFMUEhBX01PREVTLk9QQVFVRTtcbiAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5CTEVORCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgaWYgKGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuTUFTSykge1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5hbHBoYVRlc3QgPSBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiAhPT0gdm9pZCAwID8gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgOiAwLjU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm5vcm1hbE1hcFwiLCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlKSk7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGU7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlLnNldChzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJhb01hcFwiLCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlKSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFvTWFwSW50ZW5zaXR5ID0gbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgY29uc3QgZW1pc3NpdmVGYWN0b3IgPSBtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvcjtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlID0gbmV3IENvbG9yKCkuc2V0UkdCKFxuICAgICAgICBlbWlzc2l2ZUZhY3RvclswXSxcbiAgICAgICAgZW1pc3NpdmVGYWN0b3JbMV0sXG4gICAgICAgIGVtaXNzaXZlRmFjdG9yWzJdLFxuICAgICAgICBMaW5lYXJTUkdCQ29sb3JTcGFjZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJlbWlzc2l2ZU1hcFwiLCBtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUsIFNSR0JDb2xvclNwYWNlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgbWF0ZXJpYWxUeXBlKG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5uYW1lKVxuICAgICAgICBtYXRlcmlhbC5uYW1lID0gbWF0ZXJpYWxEZWYubmFtZTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobWF0ZXJpYWwsIG1hdGVyaWFsRGVmKTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG1hdGVyaWFsLCB7IG1hdGVyaWFsczogbWF0ZXJpYWxJbmRleCB9KTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWF0ZXJpYWwsIG1hdGVyaWFsRGVmKTtcbiAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICB9KTtcbiAgfVxuICAvKiogV2hlbiBPYmplY3QzRCBpbnN0YW5jZXMgYXJlIHRhcmdldGVkIGJ5IGFuaW1hdGlvbiwgdGhleSBuZWVkIHVuaXF1ZSBuYW1lcy4gKi9cbiAgY3JlYXRlVW5pcXVlTmFtZShvcmlnaW5hbE5hbWUpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWROYW1lID0gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUob3JpZ2luYWxOYW1lIHx8IFwiXCIpO1xuICAgIGlmIChzYW5pdGl6ZWROYW1lIGluIHRoaXMubm9kZU5hbWVzVXNlZCkge1xuICAgICAgcmV0dXJuIHNhbml0aXplZE5hbWUgKyBcIl9cIiArICsrdGhpcy5ub2RlTmFtZXNVc2VkW3Nhbml0aXplZE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGVOYW1lc1VzZWRbc2FuaXRpemVkTmFtZV0gPSAwO1xuICAgICAgcmV0dXJuIHNhbml0aXplZE5hbWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2dlb21ldHJ5XG4gICAqXG4gICAqIENyZWF0ZXMgQnVmZmVyR2VvbWV0cmllcyBmcm9tIHByaW1pdGl2ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8R0xURi5QcmltaXRpdmU+fSBwcmltaXRpdmVzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8QnVmZmVyR2VvbWV0cnk+Pn1cbiAgICovXG4gIGxvYWRHZW9tZXRyaWVzKHByaW1pdGl2ZXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLnByaW1pdGl2ZUNhY2hlO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURyYWNvUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0uZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKS50aGVuKGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgIHJldHVybiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmUsIHBhcnNlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZSk7XG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChjYWNoZWQucHJvbWlzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZ2VvbWV0cnlQcm9taXNlO1xuICAgICAgICBpZiAocHJpbWl0aXZlLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0pIHtcbiAgICAgICAgICBnZW9tZXRyeVByb21pc2UgPSBjcmVhdGVEcmFjb1ByaW1pdGl2ZShwcmltaXRpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlb21ldHJ5UHJvbWlzZSA9IGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMobmV3IEJ1ZmZlckdlb21ldHJ5KCksIHByaW1pdGl2ZSwgcGFyc2VyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7IHByaW1pdGl2ZSwgcHJvbWlzZTogZ2VvbWV0cnlQcm9taXNlIH07XG4gICAgICAgIHBlbmRpbmcucHVzaChnZW9tZXRyeVByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWVzaGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtZXNoSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxHcm91cHxNZXNofFNraW5uZWRNZXNoPn1cbiAgICovXG4gIGxvYWRNZXNoKG1lc2hJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1ttZXNoSW5kZXhdO1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSBtZXNoRGVmLnByaW1pdGl2ZXM7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBwcmltaXRpdmVzW2ldLm1hdGVyaWFsID09PSB2b2lkIDAgPyBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwodGhpcy5jYWNoZSkgOiB0aGlzLmdldERlcGVuZGVuY3koXCJtYXRlcmlhbFwiLCBwcmltaXRpdmVzW2ldLm1hdGVyaWFsKTtcbiAgICAgIHBlbmRpbmcucHVzaChtYXRlcmlhbCk7XG4gICAgfVxuICAgIHBlbmRpbmcucHVzaChwYXJzZXIubG9hZEdlb21ldHJpZXMocHJpbWl0aXZlcykpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFscyA9IHJlc3VsdHMuc2xpY2UoMCwgcmVzdWx0cy5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBtZXNoZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XG4gICAgICAgIGxldCBtZXNoO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG1hdGVyaWFsc1tpXTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTIHx8IHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgfHwgcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gfHwgcHJpbWl0aXZlLm1vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2ggPSBtZXNoRGVmLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgPyBuZXcgU2tpbm5lZE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKSA6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgaWYgKG1lc2guaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWVzaC5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCkge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUobWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZShtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZUZhbkRyYXdNb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FUykge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX1NUUklQKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX0xPT1ApIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmVMb29wKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5QT0lOVFMpIHtcbiAgICAgICAgICBtZXNoID0gbmV3IFBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFByaW1pdGl2ZSBtb2RlIHVuc3VwcG9ydGVkOiBcIiArIHByaW1pdGl2ZS5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWVzaC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1cGRhdGVNb3JwaFRhcmdldHMobWVzaCwgbWVzaERlZik7XG4gICAgICAgIH1cbiAgICAgICAgbWVzaC5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobWVzaERlZi5uYW1lIHx8IFwibWVzaF9cIiArIG1lc2hJbmRleCk7XG4gICAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobWVzaCwgbWVzaERlZik7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZXh0ZW5zaW9ucylcbiAgICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWVzaCwgcHJpbWl0aXZlKTtcbiAgICAgICAgcGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwobWVzaCk7XG4gICAgICAgIG1lc2hlcy5wdXNoKG1lc2gpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobWVzaGVzW2ldLCB7XG4gICAgICAgICAgbWVzaGVzOiBtZXNoSW5kZXgsXG4gICAgICAgICAgcHJpbWl0aXZlczogaVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChtZXNoRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1lc2hlc1swXSwgbWVzaERlZik7XG4gICAgICAgIHJldHVybiBtZXNoZXNbMF07XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpO1xuICAgICAgaWYgKG1lc2hEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIGdyb3VwLCBtZXNoRGVmKTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KGdyb3VwLCB7IG1lc2hlczogbWVzaEluZGV4IH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAuYWRkKG1lc2hlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNjYW1lcmFzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjYW1lcmFJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkNhbWVyYT59XG4gICAqL1xuICBsb2FkQ2FtZXJhKGNhbWVyYUluZGV4KSB7XG4gICAgbGV0IGNhbWVyYTtcbiAgICBjb25zdCBjYW1lcmFEZWYgPSB0aGlzLmpzb24uY2FtZXJhc1tjYW1lcmFJbmRleF07XG4gICAgY29uc3QgcGFyYW1zID0gY2FtZXJhRGVmW2NhbWVyYURlZi50eXBlXTtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYW1lcmFEZWYudHlwZSA9PT0gXCJwZXJzcGVjdGl2ZVwiKSB7XG4gICAgICBjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoXG4gICAgICAgIE1hdGhVdGlscy5yYWRUb0RlZyhwYXJhbXMueWZvdiksXG4gICAgICAgIHBhcmFtcy5hc3BlY3RSYXRpbyB8fCAxLFxuICAgICAgICBwYXJhbXMuem5lYXIgfHwgMSxcbiAgICAgICAgcGFyYW1zLnpmYXIgfHwgMmU2XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY2FtZXJhRGVmLnR5cGUgPT09IFwib3J0aG9ncmFwaGljXCIpIHtcbiAgICAgIGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLXBhcmFtcy54bWFnLCBwYXJhbXMueG1hZywgcGFyYW1zLnltYWcsIC1wYXJhbXMueW1hZywgcGFyYW1zLnpuZWFyLCBwYXJhbXMuemZhcik7XG4gICAgfVxuICAgIGlmIChjYW1lcmFEZWYubmFtZSlcbiAgICAgIGNhbWVyYS5uYW1lID0gdGhpcy5jcmVhdGVVbmlxdWVOYW1lKGNhbWVyYURlZi5uYW1lKTtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGNhbWVyYSwgY2FtZXJhRGVmKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNza2luc1xuICAgKiBAcGFyYW0ge251bWJlcn0gc2tpbkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8U2tlbGV0b24+fVxuICAgKi9cbiAgbG9hZFNraW4oc2tpbkluZGV4KSB7XG4gICAgY29uc3Qgc2tpbkRlZiA9IHRoaXMuanNvbi5za2luc1tza2luSW5kZXhdO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBza2luRGVmLmpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBwZW5kaW5nLnB1c2godGhpcy5fbG9hZE5vZGVTaGFsbG93KHNraW5EZWYuam9pbnRzW2ldKSk7XG4gICAgfVxuICAgIGlmIChza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nLnB1c2gobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IGludmVyc2VCaW5kTWF0cmljZXMgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgY29uc3Qgam9pbnROb2RlcyA9IHJlc3VsdHM7XG4gICAgICBjb25zdCBib25lcyA9IFtdO1xuICAgICAgY29uc3QgYm9uZUludmVyc2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBqb2ludE5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgam9pbnROb2RlID0gam9pbnROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGpvaW50Tm9kZSkge1xuICAgICAgICAgIGJvbmVzLnB1c2goam9pbnROb2RlKTtcbiAgICAgICAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICAgIGlmIChpbnZlcnNlQmluZE1hdHJpY2VzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXQuZnJvbUFycmF5KGludmVyc2VCaW5kTWF0cmljZXMuYXJyYXksIGkgKiAxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvbmVJbnZlcnNlcy5wdXNoKG1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBKb2ludCBcIiVzXCIgY291bGQgbm90IGJlIGZvdW5kLicsIHNraW5EZWYuam9pbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTa2VsZXRvbihib25lcywgYm9uZUludmVyc2VzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2FuaW1hdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGlvbkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QW5pbWF0aW9uQ2xpcD59XG4gICAqL1xuICBsb2FkQW5pbWF0aW9uKGFuaW1hdGlvbkluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRlZiA9IGpzb24uYW5pbWF0aW9uc1thbmltYXRpb25JbmRleF07XG4gICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbkRlZi5uYW1lID8gYW5pbWF0aW9uRGVmLm5hbWUgOiBcImFuaW1hdGlvbl9cIiArIGFuaW1hdGlvbkluZGV4O1xuICAgIGNvbnN0IHBlbmRpbmdOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdJbnB1dEFjY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nU2FtcGxlcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nVGFyZ2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVscy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzW2ldO1xuICAgICAgY29uc3Qgc2FtcGxlciA9IGFuaW1hdGlvbkRlZi5zYW1wbGVyc1tjaGFubmVsLnNhbXBsZXJdO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2hhbm5lbC50YXJnZXQ7XG4gICAgICBjb25zdCBuYW1lID0gdGFyZ2V0Lm5vZGU7XG4gICAgICBjb25zdCBpbnB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1tzYW1wbGVyLmlucHV0XSA6IHNhbXBsZXIuaW5wdXQ7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdm9pZCAwID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbc2FtcGxlci5vdXRwdXRdIDogc2FtcGxlci5vdXRwdXQ7XG4gICAgICBpZiAodGFyZ2V0Lm5vZGUgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBwZW5kaW5nTm9kZXMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJub2RlXCIsIG5hbWUpKTtcbiAgICAgIHBlbmRpbmdJbnB1dEFjY2Vzc29ycy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGlucHV0KSk7XG4gICAgICBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgb3V0cHV0KSk7XG4gICAgICBwZW5kaW5nU2FtcGxlcnMucHVzaChzYW1wbGVyKTtcbiAgICAgIHBlbmRpbmdUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdOb2RlcyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nSW5wdXRBY2Nlc3NvcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ091dHB1dEFjY2Vzc29ycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nU2FtcGxlcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ1RhcmdldHMpXG4gICAgXSkudGhlbihmdW5jdGlvbihkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gZGVwZW5kZW5jaWVzWzBdO1xuICAgICAgY29uc3QgaW5wdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbMV07XG4gICAgICBjb25zdCBvdXRwdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbMl07XG4gICAgICBjb25zdCBzYW1wbGVycyA9IGRlcGVuZGVuY2llc1szXTtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSBkZXBlbmRlbmNpZXNbNF07XG4gICAgICBjb25zdCB0cmFja3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBjb25zdCBpbnB1dEFjY2Vzc29yID0gaW5wdXRBY2Nlc3NvcnNbaV07XG4gICAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29yID0gb3V0cHV0QWNjZXNzb3JzW2ldO1xuICAgICAgICBjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbaV07XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChub2RlLnVwZGF0ZU1hdHJpeCkge1xuICAgICAgICAgIG5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZFRyYWNrcyA9IHBhcnNlci5fY3JlYXRlQW5pbWF0aW9uVHJhY2tzKG5vZGUsIGlucHV0QWNjZXNzb3IsIG91dHB1dEFjY2Vzc29yLCBzYW1wbGVyLCB0YXJnZXQpO1xuICAgICAgICBpZiAoY3JlYXRlZFRyYWNrcykge1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY3JlYXRlZFRyYWNrcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdHJhY2tzLnB1c2goY3JlYXRlZFRyYWNrc1trXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoYW5pbWF0aW9uTmFtZSwgdm9pZCAwLCB0cmFja3MpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmIChub2RlRGVmLm1lc2ggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm1lc2hcIiwgbm9kZURlZi5tZXNoKS50aGVuKGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBwYXJzZXIuX2dldE5vZGVSZWYocGFyc2VyLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoLCBtZXNoKTtcbiAgICAgIGlmIChub2RlRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoIW8uaXNNZXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICBvLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG5vZGVEZWYud2VpZ2h0c1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNub2Rlcy1hbmQtaGllcmFyY2h5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRD59XG4gICAqL1xuICBsb2FkTm9kZShub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBub2RlUGVuZGluZyA9IHBhcnNlci5fbG9hZE5vZGVTaGFsbG93KG5vZGVJbmRleCk7XG4gICAgY29uc3QgY2hpbGRQZW5kaW5nID0gW107XG4gICAgY29uc3QgY2hpbGRyZW5EZWYgPSBub2RlRGVmLmNoaWxkcmVuIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuRGVmLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNoaWxkUGVuZGluZy5wdXNoKHBhcnNlci5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBjaGlsZHJlbkRlZltpXSkpO1xuICAgIH1cbiAgICBjb25zdCBza2VsZXRvblBlbmRpbmcgPSBub2RlRGVmLnNraW4gPT09IHZvaWQgMCA/IFByb21pc2UucmVzb2x2ZShudWxsKSA6IHBhcnNlci5nZXREZXBlbmRlbmN5KFwic2tpblwiLCBub2RlRGVmLnNraW4pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbbm9kZVBlbmRpbmcsIFByb21pc2UuYWxsKGNoaWxkUGVuZGluZyksIHNrZWxldG9uUGVuZGluZ10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3Qgbm9kZSA9IHJlc3VsdHNbMF07XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHJlc3VsdHNbMV07XG4gICAgICBjb25zdCBza2VsZXRvbiA9IHJlc3VsdHNbMl07XG4gICAgICBpZiAoc2tlbGV0b24gIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihtZXNoKSB7XG4gICAgICAgICAgaWYgKCFtZXNoLmlzU2tpbm5lZE1lc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgbWVzaC5iaW5kKHNrZWxldG9uLCBfaWRlbnRpdHlNYXRyaXgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbm9kZS5hZGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgLy8gLl9sb2FkTm9kZVNoYWxsb3coKSBwYXJzZXMgYSBzaW5nbGUgbm9kZS5cbiAgLy8gc2tpbiBhbmQgY2hpbGQgbm9kZXMgYXJlIGNyZWF0ZWQgYW5kIGFkZGVkIGluIC5sb2FkTm9kZSgpIChubyAnXycgcHJlZml4KS5cbiAgX2xvYWROb2RlU2hhbGxvdyhub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBpZiAodGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGVEZWYubmFtZSA/IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKG5vZGVEZWYubmFtZSkgOiBcIlwiO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBtZXNoUHJvbWlzZSA9IHBhcnNlci5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5jcmVhdGVOb2RlTWVzaCAmJiBleHQuY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KTtcbiAgICB9KTtcbiAgICBpZiAobWVzaFByb21pc2UpIHtcbiAgICAgIHBlbmRpbmcucHVzaChtZXNoUHJvbWlzZSk7XG4gICAgfVxuICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiY2FtZXJhXCIsIG5vZGVEZWYuY2FtZXJhKS50aGVuKGZ1bmN0aW9uKGNhbWVyYSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYocGFyc2VyLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSwgY2FtZXJhKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHBhcnNlci5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudCAmJiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQobm9kZUluZGV4KTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwcm9taXNlKTtcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdID0gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihvYmplY3RzKSB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGlmIChub2RlRGVmLmlzQm9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlID0gbmV3IEJvbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgR3JvdXAoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbm9kZSA9IG9iamVjdHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IE9iamVjdDNEKCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAhPT0gb2JqZWN0c1swXSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBub2RlLmFkZChvYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVEZWYubmFtZSkge1xuICAgICAgICBub2RlLnVzZXJEYXRhLm5hbWUgPSBub2RlRGVmLm5hbWU7XG4gICAgICAgIG5vZGUubmFtZSA9IG5vZGVOYW1lO1xuICAgICAgfVxuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShub2RlLCBub2RlRGVmKTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBub2RlLCBub2RlRGVmKTtcbiAgICAgIGlmIChub2RlRGVmLm1hdHJpeCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIG1hdHJpeC5mcm9tQXJyYXkobm9kZURlZi5tYXRyaXgpO1xuICAgICAgICBub2RlLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGVEZWYudHJhbnNsYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUucG9zaXRpb24uZnJvbUFycmF5KG5vZGVEZWYudHJhbnNsYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLnJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnF1YXRlcm5pb24uZnJvbUFycmF5KG5vZGVEZWYucm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnNjYWxlLmZyb21BcnJheShub2RlRGVmLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwYXJzZXIuYXNzb2NpYXRpb25zLmhhcyhub2RlKSkge1xuICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChub2RlLCB7fSk7XG4gICAgICB9XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChub2RlKS5ub2RlcyA9IG5vZGVJbmRleDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2NlbmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2VuZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXA+fVxuICAgKi9cbiAgbG9hZFNjZW5lKHNjZW5lSW5kZXgpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IHNjZW5lRGVmID0gdGhpcy5qc29uLnNjZW5lc1tzY2VuZUluZGV4XTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IHNjZW5lID0gbmV3IEdyb3VwKCk7XG4gICAgaWYgKHNjZW5lRGVmLm5hbWUpXG4gICAgICBzY2VuZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoc2NlbmVEZWYubmFtZSk7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShzY2VuZSwgc2NlbmVEZWYpO1xuICAgIGlmIChzY2VuZURlZi5leHRlbnNpb25zKVxuICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIHNjZW5lLCBzY2VuZURlZik7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHNjZW5lRGVmLm5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2RlSWRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbm9kZUlkc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihub2Rlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBzY2VuZS5hZGQobm9kZXNbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVkdWNlQXNzb2NpYXRpb25zID0gKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVkdWNlZEFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcnNlci5hc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgTWF0ZXJpYWwgfHwga2V5IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVkdWNlZEFzc29jaWF0aW9ucy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUudHJhdmVyc2UoKG5vZGUyKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChub2RlMik7XG4gICAgICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KG5vZGUyLCBtYXBwaW5ncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRBc3NvY2lhdGlvbnM7XG4gICAgICB9O1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucyA9IHJlZHVjZUFzc29jaWF0aW9ucyhzY2VuZSk7XG4gICAgICByZXR1cm4gc2NlbmU7XG4gICAgfSk7XG4gIH1cbiAgX2NyZWF0ZUFuaW1hdGlvblRyYWNrcyhub2RlLCBpbnB1dEFjY2Vzc29yLCBvdXRwdXRBY2Nlc3Nvciwgc2FtcGxlciwgdGFyZ2V0KSB7XG4gICAgY29uc3QgdHJhY2tzID0gW107XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IG5vZGUubmFtZSA/IG5vZGUubmFtZSA6IG5vZGUudXVpZDtcbiAgICBjb25zdCB0YXJnZXROYW1lcyA9IFtdO1xuICAgIGlmIChQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdID09PSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0cykge1xuICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMpIHtcbiAgICAgICAgICB0YXJnZXROYW1lcy5wdXNoKG9iamVjdC5uYW1lID8gb2JqZWN0Lm5hbWUgOiBvYmplY3QudXVpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXROYW1lcy5wdXNoKHRhcmdldE5hbWUpO1xuICAgIH1cbiAgICBsZXQgVHlwZWRLZXlmcmFtZVRyYWNrO1xuICAgIHN3aXRjaCAoUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSkge1xuICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0czpcbiAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5yb3RhdGlvbjpcbiAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMucG9zaXRpb246XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5zY2FsZTpcbiAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzd2l0Y2ggKG91dHB1dEFjY2Vzc29yLml0ZW1TaXplKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHNhbXBsZXIuaW50ZXJwb2xhdGlvbiAhPT0gdm9pZCAwID8gSU5URVJQT0xBVElPTltzYW1wbGVyLmludGVycG9sYXRpb25dIDogSW50ZXJwb2xhdGVMaW5lYXI7XG4gICAgY29uc3Qgb3V0cHV0QXJyYXkgPSB0aGlzLl9nZXRBcnJheUZyb21BY2Nlc3NvcihvdXRwdXRBY2Nlc3Nvcik7XG4gICAgZm9yIChsZXQgaiA9IDAsIGpsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgY29uc3QgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKFxuICAgICAgICB0YXJnZXROYW1lc1tqXSArIFwiLlwiICsgUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSxcbiAgICAgICAgaW5wdXRBY2Nlc3Nvci5hcnJheSxcbiAgICAgICAgb3V0cHV0QXJyYXksXG4gICAgICAgIGludGVycG9sYXRpb25cbiAgICAgICk7XG4gICAgICBpZiAoc2FtcGxlci5pbnRlcnBvbGF0aW9uID09PSBcIkNVQklDU1BMSU5FXCIpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQ3ViaWNTcGxpbmVUcmFja0ludGVycG9sYW50KHRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYWNrcztcbiAgfVxuICBfZ2V0QXJyYXlGcm9tQWNjZXNzb3IoYWNjZXNzb3IpIHtcbiAgICBsZXQgb3V0cHV0QXJyYXkgPSBhY2Nlc3Nvci5hcnJheTtcbiAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUob3V0cHV0QXJyYXkuY29uc3RydWN0b3IpO1xuICAgICAgY29uc3Qgc2NhbGVkID0gbmV3IEZsb2F0MzJBcnJheShvdXRwdXRBcnJheS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gb3V0cHV0QXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICBzY2FsZWRbal0gPSBvdXRwdXRBcnJheVtqXSAqIHNjYWxlO1xuICAgICAgfVxuICAgICAgb3V0cHV0QXJyYXkgPSBzY2FsZWQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgfVxuICBfY3JlYXRlQ3ViaWNTcGxpbmVUcmFja0ludGVycG9sYW50KHRyYWNrKSB7XG4gICAgdHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSBmdW5jdGlvbiBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUocmVzdWx0KSB7XG4gICAgICBjb25zdCBpbnRlcnBvbGFudFR5cGUgPSB0aGlzIGluc3RhbmNlb2YgUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgOiBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudDtcbiAgICAgIHJldHVybiBuZXcgaW50ZXJwb2xhbnRUeXBlKHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpIC8gMywgcmVzdWx0KTtcbiAgICB9O1xuICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuICBjb25zdCBib3ggPSBuZXcgQm94MygpO1xuICBpZiAoYXR0cmlidXRlcy5QT1NJVElPTiAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbYXR0cmlidXRlcy5QT1NJVElPTl07XG4gICAgY29uc3QgbWluID0gYWNjZXNzb3IubWluO1xuICAgIGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcbiAgICBpZiAobWluICE9PSB2b2lkIDAgJiYgbWF4ICE9PSB2b2lkIDApIHtcbiAgICAgIGJveC5zZXQobmV3IFZlY3RvcjMobWluWzBdLCBtaW5bMV0sIG1pblsyXSksIG5ldyBWZWN0b3IzKG1heFswXSwgbWF4WzFdLCBtYXhbMl0pKTtcbiAgICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGJveFNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXSk7XG4gICAgICAgIGJveC5taW4ubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgICBib3gubWF4Lm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhcmdldHMgPSBwcmltaXRpdmVEZWYudGFyZ2V0cztcbiAgaWYgKHRhcmdldHMgIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IG1heERpc3BsYWNlbWVudCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICBpZiAodGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbdGFyZ2V0LlBPU0lUSU9OXTtcbiAgICAgICAgY29uc3QgbWluID0gYWNjZXNzb3IubWluO1xuICAgICAgICBjb25zdCBtYXggPSBhY2Nlc3Nvci5tYXg7XG4gICAgICAgIGlmIChtaW4gIT09IHZvaWQgMCAmJiBtYXggIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZlY3Rvci5zZXRYKE1hdGgubWF4KE1hdGguYWJzKG1pblswXSksIE1hdGguYWJzKG1heFswXSkpKTtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WShNYXRoLm1heChNYXRoLmFicyhtaW5bMV0pLCBNYXRoLmFicyhtYXhbMV0pKSk7XG4gICAgICAgICAgdmVjdG9yLnNldFooTWF0aC5tYXgoTWF0aC5hYnMobWluWzJdKSwgTWF0aC5hYnMobWF4WzJdKSkpO1xuICAgICAgICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICAgICAgICBjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3IuY29tcG9uZW50VHlwZV0pO1xuICAgICAgICAgICAgdmVjdG9yLm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF4RGlzcGxhY2VtZW50Lm1heCh2ZWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYm94LmV4cGFuZEJ5VmVjdG9yKG1heERpc3BsYWNlbWVudCk7XG4gIH1cbiAgZ2VvbWV0cnkuYm91bmRpbmdCb3ggPSBib3g7XG4gIGNvbnN0IHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcbiAgYm94LmdldENlbnRlcihzcGhlcmUuY2VudGVyKTtcbiAgc3BoZXJlLnJhZGl1cyA9IGJveC5taW4uZGlzdGFuY2VUbyhib3gubWF4KSAvIDI7XG4gIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xufVxuZnVuY3Rpb24gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuICBjb25zdCBwZW5kaW5nID0gW107XG4gIGZ1bmN0aW9uIGFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yKGFjY2Vzc29ySW5kZXgsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBhY2Nlc3NvckluZGV4KS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29yKSB7XG4gICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYWNjZXNzb3IpO1xuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgZ2x0ZkF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbZ2x0ZkF0dHJpYnV0ZU5hbWVdIHx8IGdsdGZBdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRocmVlQXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKVxuICAgICAgY29udGludWU7XG4gICAgcGVuZGluZy5wdXNoKGFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yKGF0dHJpYnV0ZXNbZ2x0ZkF0dHJpYnV0ZU5hbWVdLCB0aHJlZUF0dHJpYnV0ZU5hbWUpKTtcbiAgfVxuICBpZiAocHJpbWl0aXZlRGVmLmluZGljZXMgIT09IHZvaWQgMCAmJiAhZ2VvbWV0cnkuaW5kZXgpIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgcHJpbWl0aXZlRGVmLmluZGljZXMpLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3IyKSB7XG4gICAgICBnZW9tZXRyeS5zZXRJbmRleChhY2Nlc3NvcjIpO1xuICAgIH0pO1xuICAgIHBlbmRpbmcucHVzaChhY2Nlc3Nvcik7XG4gIH1cbiAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShnZW9tZXRyeSwgcHJpbWl0aXZlRGVmKTtcbiAgY29tcHV0ZUJvdW5kcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHZvaWQgMCA/IGFkZE1vcnBoVGFyZ2V0cyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLnRhcmdldHMsIHBhcnNlcikgOiBnZW9tZXRyeTtcbiAgfSk7XG59XG5leHBvcnQge1xuICBHTFRGTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xURkxvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJMb2FkZXIiLCJMb2FkZXJVdGlscyIsIkZpbGVMb2FkZXIiLCJDb2xvciIsIlNwb3RMaWdodCIsIlBvaW50TGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNZXNoUGh5c2ljYWxNYXRlcmlhbCIsIlZlY3RvcjIiLCJNYXRyaXg0IiwiVmVjdG9yMyIsIlF1YXRlcm5pb24iLCJJbnN0YW5jZWRNZXNoIiwiSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIiwiT2JqZWN0M0QiLCJUZXh0dXJlTG9hZGVyIiwiSW1hZ2VCaXRtYXBMb2FkZXIiLCJCdWZmZXJBdHRyaWJ1dGUiLCJJbnRlcmxlYXZlZEJ1ZmZlciIsIkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIiwiTGluZWFyRmlsdGVyIiwiTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyIiwiUmVwZWF0V3JhcHBpbmciLCJQb2ludHNNYXRlcmlhbCIsIk1hdGVyaWFsIiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsIkRvdWJsZVNpZGUiLCJQcm9wZXJ0eUJpbmRpbmciLCJCdWZmZXJHZW9tZXRyeSIsIlNraW5uZWRNZXNoIiwiTWVzaCIsIlRyaWFuZ2xlU3RyaXBEcmF3TW9kZSIsIlRyaWFuZ2xlRmFuRHJhd01vZGUiLCJMaW5lU2VnbWVudHMiLCJMaW5lIiwiTGluZUxvb3AiLCJQb2ludHMiLCJHcm91cCIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiTWF0aFV0aWxzIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiU2tlbGV0b24iLCJBbmltYXRpb25DbGlwIiwiQm9uZSIsIkludGVycG9sYXRlTGluZWFyIiwiTmVhcmVzdEZpbHRlciIsIk5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIiwiTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciIsIk5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIiLCJDbGFtcFRvRWRnZVdyYXBwaW5nIiwiTWlycm9yZWRSZXBlYXRXcmFwcGluZyIsIkludGVycG9sYXRlRGlzY3JldGUiLCJGcm9udFNpZGUiLCJUZXh0dXJlIiwiVmVjdG9yS2V5ZnJhbWVUcmFjayIsIk51bWJlcktleWZyYW1lVHJhY2siLCJRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayIsIkJveDMiLCJTcGhlcmUiLCJJbnRlcnBvbGFudCIsInRvVHJpYW5nbGVzRHJhd01vZGUiLCJ2ZXJzaW9uIiwiZGVjb2RlVGV4dCIsIlNSR0JDb2xvclNwYWNlIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJzUkdCRW5jb2RpbmciLCJMaW5lYXJFbmNvZGluZyIsIkdMVEZMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJkcmFjb0xvYWRlciIsImt0eDJMb2FkZXIiLCJtZXNob3B0RGVjb2RlciIsInBsdWdpbkNhbGxiYWNrcyIsInJlZ2lzdGVyIiwicGFyc2VyIiwiR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNEaXNwZXJzaW9uRXh0ZW5zaW9uIiwiR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24iLCJHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24iLCJHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0J1bXBFeHRlbnNpb24iLCJHTFRGTGlnaHRzRXh0ZW5zaW9uIiwiR0xURk1lc2hvcHRDb21wcmVzc2lvbiIsIkdMVEZNZXNoR3B1SW5zdGFuY2luZyIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsInNjb3BlIiwicmVzb3VyY2VQYXRoIiwicGF0aCIsInJlbGF0aXZlVXJsIiwiZXh0cmFjdFVybEJhc2UiLCJyZXNvbHZlVVJMIiwiaXRlbVN0YXJ0IiwiX29uRXJyb3IiLCJlIiwiY29uc29sZSIsImVycm9yIiwiaXRlbUVycm9yIiwiaXRlbUVuZCIsImxvYWRlciIsInNldFBhdGgiLCJzZXRSZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVxdWVzdEhlYWRlciIsInNldFdpdGhDcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsImRhdGEiLCJwYXJzZSIsImdsdGYiLCJzZXREUkFDT0xvYWRlciIsInNldEREU0xvYWRlciIsIkVycm9yIiwic2V0S1RYMkxvYWRlciIsInNldE1lc2hvcHREZWNvZGVyIiwiY2FsbGJhY2siLCJpbmRleE9mIiwicHVzaCIsInVucmVnaXN0ZXIiLCJzcGxpY2UiLCJqc29uIiwiZXh0ZW5zaW9ucyIsInBsdWdpbnMiLCJKU09OIiwiQXJyYXlCdWZmZXIiLCJtYWdpYyIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIkJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDIiwiRVhURU5TSU9OUyIsIktIUl9CSU5BUllfR0xURiIsIkdMVEZCaW5hcnlFeHRlbnNpb24iLCJjb250ZW50IiwiYXNzZXQiLCJHTFRGUGFyc2VyIiwiY3Jvc3NPcmlnaW4iLCJmaWxlTG9hZGVyIiwiaSIsImxlbmd0aCIsInBsdWdpbiIsIm5hbWUiLCJleHRlbnNpb25zVXNlZCIsImV4dGVuc2lvbk5hbWUiLCJleHRlbnNpb25zUmVxdWlyZWQiLCJLSFJfTUFURVJJQUxTX1VOTElUIiwiR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uIiwiS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04iLCJHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24iLCJLSFJfVEVYVFVSRV9UUkFOU0ZPUk0iLCJHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbiIsIktIUl9NRVNIX1FVQU5USVpBVElPTiIsIkdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uIiwid2FybiIsInNldEV4dGVuc2lvbnMiLCJzZXRQbHVnaW5zIiwicGFyc2VBc3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiR0xURlJlZ2lzdHJ5Iiwib2JqZWN0cyIsImdldCIsImtleSIsImFkZCIsIm9iamVjdCIsInJlbW92ZSIsInJlbW92ZUFsbCIsIktIUl9MSUdIVFNfUFVOQ1RVQUwiLCJLSFJfTUFURVJJQUxTX0NMRUFSQ09BVCIsIktIUl9NQVRFUklBTFNfRElTUEVSU0lPTiIsIktIUl9NQVRFUklBTFNfSU9SIiwiS0hSX01BVEVSSUFMU19TSEVFTiIsIktIUl9NQVRFUklBTFNfU1BFQ1VMQVIiLCJLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTiIsIktIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0UiLCJLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFkiLCJLSFJfTUFURVJJQUxTX1ZPTFVNRSIsIktIUl9URVhUVVJFX0JBU0lTVSIsIktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEgiLCJFWFRfTUFURVJJQUxTX0JVTVAiLCJFWFRfVEVYVFVSRV9XRUJQIiwiRVhUX1RFWFRVUkVfQVZJRiIsIkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OIiwiRVhUX01FU0hfR1BVX0lOU1RBTkNJTkciLCJjYWNoZSIsInJlZnMiLCJ1c2VzIiwiX21hcmtEZWZzIiwibm9kZURlZnMiLCJub2RlcyIsIm5vZGVJbmRleCIsIm5vZGVMZW5ndGgiLCJub2RlRGVmIiwibGlnaHQiLCJfYWRkTm9kZVJlZiIsIl9sb2FkTGlnaHQiLCJsaWdodEluZGV4IiwiY2FjaGVLZXkiLCJkZXBlbmRlbmN5IiwibGlnaHREZWZzIiwibGlnaHRzIiwibGlnaHREZWYiLCJsaWdodE5vZGUiLCJjb2xvciIsInNldFJHQiIsInJhbmdlIiwidHlwZSIsInRhcmdldCIsInBvc2l0aW9uIiwic2V0IiwiZGlzdGFuY2UiLCJzcG90IiwiaW5uZXJDb25lQW5nbGUiLCJvdXRlckNvbmVBbmdsZSIsIk1hdGgiLCJQSSIsImFuZ2xlIiwicGVudW1icmEiLCJkZWNheSIsImFzc2lnbkV4dHJhc1RvVXNlckRhdGEiLCJpbnRlbnNpdHkiLCJjcmVhdGVVbmlxdWVOYW1lIiwiZ2V0RGVwZW5kZW5jeSIsImluZGV4IiwiY3JlYXRlTm9kZUF0dGFjaG1lbnQiLCJzZWxmMiIsInRoZW4iLCJfZ2V0Tm9kZVJlZiIsImdldE1hdGVyaWFsVHlwZSIsImV4dGVuZFBhcmFtcyIsIm1hdGVyaWFsUGFyYW1zIiwibWF0ZXJpYWxEZWYiLCJwZW5kaW5nIiwib3BhY2l0eSIsIm1ldGFsbGljUm91Z2huZXNzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiLCJBcnJheSIsImlzQXJyYXkiLCJiYXNlQ29sb3JGYWN0b3IiLCJhcnJheSIsImJhc2VDb2xvclRleHR1cmUiLCJhc3NpZ25UZXh0dXJlIiwiYWxsIiwiZXh0ZW5kTWF0ZXJpYWxQYXJhbXMiLCJtYXRlcmlhbEluZGV4IiwibWF0ZXJpYWxzIiwiZW1pc3NpdmVTdHJlbmd0aCIsImVtaXNzaXZlSW50ZW5zaXR5IiwiZXh0ZW5zaW9uIiwiY2xlYXJjb2F0RmFjdG9yIiwiY2xlYXJjb2F0IiwiY2xlYXJjb2F0VGV4dHVyZSIsImNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciIsImNsZWFyY29hdFJvdWdobmVzcyIsImNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUiLCJjbGVhcmNvYXROb3JtYWxUZXh0dXJlIiwic2NhbGUiLCJjbGVhcmNvYXROb3JtYWxTY2FsZSIsImRpc3BlcnNpb24iLCJpcmlkZXNjZW5jZUZhY3RvciIsImlyaWRlc2NlbmNlIiwiaXJpZGVzY2VuY2VUZXh0dXJlIiwiaXJpZGVzY2VuY2VJb3IiLCJpcmlkZXNjZW5jZUlPUiIsImlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UiLCJpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0iLCJpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0iLCJpcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUiLCJzaGVlbkNvbG9yIiwic2hlZW5Sb3VnaG5lc3MiLCJzaGVlbiIsInNoZWVuQ29sb3JGYWN0b3IiLCJjb2xvckZhY3RvciIsInNoZWVuUm91Z2huZXNzRmFjdG9yIiwic2hlZW5Db2xvclRleHR1cmUiLCJzaGVlblJvdWdobmVzc1RleHR1cmUiLCJ0cmFuc21pc3Npb25GYWN0b3IiLCJ0cmFuc21pc3Npb24iLCJ0cmFuc21pc3Npb25UZXh0dXJlIiwidGhpY2tuZXNzIiwidGhpY2tuZXNzRmFjdG9yIiwidGhpY2tuZXNzVGV4dHVyZSIsImF0dGVudWF0aW9uRGlzdGFuY2UiLCJJbmZpbml0eSIsImNvbG9yQXJyYXkiLCJhdHRlbnVhdGlvbkNvbG9yIiwiaW9yIiwic3BlY3VsYXJJbnRlbnNpdHkiLCJzcGVjdWxhckZhY3RvciIsInNwZWN1bGFyVGV4dHVyZSIsInNwZWN1bGFyQ29sb3JGYWN0b3IiLCJzcGVjdWxhckNvbG9yIiwic3BlY3VsYXJDb2xvclRleHR1cmUiLCJidW1wU2NhbGUiLCJidW1wRmFjdG9yIiwiYnVtcFRleHR1cmUiLCJhbmlzb3Ryb3B5U3RyZW5ndGgiLCJhbmlzb3Ryb3B5IiwiYW5pc290cm9weVJvdGF0aW9uIiwiYW5pc290cm9weVRleHR1cmUiLCJsb2FkVGV4dHVyZSIsInRleHR1cmVJbmRleCIsInRleHR1cmVEZWYiLCJ0ZXh0dXJlcyIsIm9wdGlvbnMiLCJsb2FkVGV4dHVyZUltYWdlIiwic291cmNlIiwiaXNTdXBwb3J0ZWQiLCJpbWFnZXMiLCJ0ZXh0dXJlTG9hZGVyIiwidXJpIiwiaGFuZGxlciIsImdldEhhbmRsZXIiLCJkZXRlY3RTdXBwb3J0IiwiaW1hZ2UiLCJJbWFnZSIsInNyYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJoZWlnaHQiLCJsb2FkQnVmZmVyVmlldyIsImJ1ZmZlclZpZXciLCJidWZmZXJWaWV3cyIsImV4dGVuc2lvbkRlZiIsImJ1ZmZlciIsImRlY29kZXIiLCJzdXBwb3J0ZWQiLCJyZXMiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImNvdW50Iiwic3RyaWRlIiwiYnl0ZVN0cmlkZSIsImRlY29kZUdsdGZCdWZmZXJBc3luYyIsIm1vZGUiLCJmaWx0ZXIiLCJyZXMyIiwicmVhZHkiLCJyZXN1bHQiLCJkZWNvZGVHbHRmQnVmZmVyIiwiY3JlYXRlTm9kZU1lc2giLCJtZXNoIiwibWVzaERlZiIsIm1lc2hlcyIsInByaW1pdGl2ZSIsInByaW1pdGl2ZXMiLCJXRUJHTF9DT05TVEFOVFMiLCJUUklBTkdMRVMiLCJUUklBTkdMRV9TVFJJUCIsIlRSSUFOR0xFX0ZBTiIsImF0dHJpYnV0ZXNEZWYiLCJhdHRyaWJ1dGVzIiwiYWNjZXNzb3IiLCJyZXN1bHRzIiwibm9kZU9iamVjdCIsInBvcCIsImlzR3JvdXAiLCJjaGlsZHJlbiIsImluc3RhbmNlZE1lc2hlcyIsIm0iLCJwIiwicSIsInMiLCJpbnN0YW5jZWRNZXNoIiwiZ2VvbWV0cnkiLCJtYXRlcmlhbCIsIlRSQU5TTEFUSU9OIiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsIlJPVEFUSU9OIiwiU0NBTEUiLCJzZXRNYXRyaXhBdCIsImNvbXBvc2UiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0ciIsImluc3RhbmNlQ29sb3IiLCJpdGVtU2l6ZSIsIm5vcm1hbGl6ZWQiLCJzZXRBdHRyaWJ1dGUiLCJwcm90b3R5cGUiLCJjb3B5IiwiY2FsbCIsImFzc2lnbkZpbmFsTWF0ZXJpYWwiLCJjbGVhciIsIkJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCIsIkJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMiLCJCSU4iLCJib2R5IiwiaGVhZGVyVmlldyIsIkRhdGFWaWV3IiwiaGVhZGVyIiwiZ2V0VWludDMyIiwiY2h1bmtDb250ZW50c0xlbmd0aCIsImNodW5rVmlldyIsImNodW5rSW5kZXgiLCJjaHVua0xlbmd0aCIsImNodW5rVHlwZSIsImNvbnRlbnRBcnJheSIsInByZWxvYWQiLCJkZWNvZGVQcmltaXRpdmUiLCJidWZmZXJWaWV3SW5kZXgiLCJnbHRmQXR0cmlidXRlTWFwIiwidGhyZWVBdHRyaWJ1dGVNYXAiLCJhdHRyaWJ1dGVOb3JtYWxpemVkTWFwIiwiYXR0cmlidXRlVHlwZU1hcCIsInRocmVlQXR0cmlidXRlTmFtZSIsIkFUVFJJQlVURVMiLCJ0b0xvd2VyQ2FzZSIsImFjY2Vzc29yRGVmIiwiYWNjZXNzb3JzIiwiY29tcG9uZW50VHlwZSIsIldFQkdMX0NPTVBPTkVOVF9UWVBFUyIsImRlY29kZURyYWNvRmlsZSIsImF0dHJpYnV0ZSIsImV4dGVuZFRleHR1cmUiLCJ0ZXh0dXJlIiwidHJhbnNmb3JtIiwidGV4Q29vcmQiLCJjaGFubmVsIiwib2Zmc2V0Iiwicm90YXRpb24iLCJjbG9uZSIsImZyb21BcnJheSIsInJlcGVhdCIsIm5lZWRzVXBkYXRlIiwiR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQiLCJwYXJhbWV0ZXJQb3NpdGlvbnMiLCJzYW1wbGVWYWx1ZXMiLCJzYW1wbGVTaXplIiwicmVzdWx0QnVmZmVyIiwiY29weVNhbXBsZVZhbHVlXyIsInZhbHVlcyIsInZhbHVlU2l6ZSIsImludGVycG9sYXRlXyIsImkxIiwidDAiLCJ0IiwidDEiLCJzdHJpZGUyIiwic3RyaWRlMyIsInRkIiwicHAiLCJwcHAiLCJvZmZzZXQxIiwib2Zmc2V0MCIsInMyIiwiczMiLCJzMCIsInMxIiwicDAiLCJtMCIsInAxIiwibTEiLCJfcSIsIkdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCIsIm5vcm1hbGl6ZSIsInRvQXJyYXkiLCJGTE9BVCIsIkZMT0FUX01BVDMiLCJGTE9BVF9NQVQ0IiwiRkxPQVRfVkVDMiIsIkZMT0FUX1ZFQzMiLCJGTE9BVF9WRUM0IiwiTElORUFSIiwiUkVQRUFUIiwiU0FNUExFUl8yRCIsIlBPSU5UUyIsIkxJTkVTIiwiTElORV9MT09QIiwiTElORV9TVFJJUCIsIlVOU0lHTkVEX0JZVEUiLCJVTlNJR05FRF9TSE9SVCIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiV0VCR0xfRklMVEVSUyIsIldFQkdMX1dSQVBQSU5HUyIsIldFQkdMX1RZUEVfU0laRVMiLCJTQ0FMQVIiLCJWRUMyIiwiVkVDMyIsIlZFQzQiLCJNQVQyIiwiTUFUMyIsIk1BVDQiLCJQT1NJVElPTiIsIk5PUk1BTCIsIlRBTkdFTlQiLCJURVhDT09SRF8wIiwiVEVYQ09PUkRfMSIsIlRFWENPT1JEXzIiLCJURVhDT09SRF8zIiwiQ09MT1JfMCIsIldFSUdIVFNfMCIsIkpPSU5UU18wIiwiUEFUSF9QUk9QRVJUSUVTIiwidHJhbnNsYXRpb24iLCJ3ZWlnaHRzIiwiSU5URVJQT0xBVElPTiIsIkNVQklDU1BMSU5FIiwiU1RFUCIsIkFMUEhBX01PREVTIiwiT1BBUVVFIiwiTUFTSyIsIkJMRU5EIiwiY3JlYXRlRGVmYXVsdE1hdGVyaWFsIiwiZW1pc3NpdmUiLCJtZXRhbG5lc3MiLCJyb3VnaG5lc3MiLCJ0cmFuc3BhcmVudCIsImRlcHRoVGVzdCIsInNpZGUiLCJhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEiLCJrbm93bkV4dGVuc2lvbnMiLCJvYmplY3REZWYiLCJ1c2VyRGF0YSIsImdsdGZFeHRlbnNpb25zIiwiZ2x0ZkRlZiIsImV4dHJhcyIsIk9iamVjdCIsImFzc2lnbiIsImFkZE1vcnBoVGFyZ2V0cyIsInRhcmdldHMiLCJoYXNNb3JwaFBvc2l0aW9uIiwiaGFzTW9ycGhOb3JtYWwiLCJoYXNNb3JwaENvbG9yIiwiaWwiLCJwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMiLCJwZW5kaW5nTm9ybWFsQWNjZXNzb3JzIiwicGVuZGluZ0NvbG9yQWNjZXNzb3JzIiwicGVuZGluZ0FjY2Vzc29yIiwibm9ybWFsIiwibW9ycGhQb3NpdGlvbnMiLCJtb3JwaE5vcm1hbHMiLCJtb3JwaENvbG9ycyIsIm1vcnBoQXR0cmlidXRlcyIsIm1vcnBoVGFyZ2V0c1JlbGF0aXZlIiwidXBkYXRlTW9ycGhUYXJnZXRzIiwibW9ycGhUYXJnZXRJbmZsdWVuY2VzIiwidGFyZ2V0TmFtZXMiLCJtb3JwaFRhcmdldERpY3Rpb25hcnkiLCJjcmVhdGVQcmltaXRpdmVLZXkiLCJwcmltaXRpdmVEZWYiLCJnZW9tZXRyeUtleSIsImRyYWNvRXh0ZW5zaW9uIiwiaW5kaWNlcyIsImNyZWF0ZUF0dHJpYnV0ZXNLZXkiLCJhdHRyaWJ1dGVzS2V5Iiwia2V5cyIsInNvcnQiLCJnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUiLCJnZXRJbWFnZVVSSU1pbWVUeXBlIiwic2VhcmNoIiwiX2lkZW50aXR5TWF0cml4IiwiYXNzb2NpYXRpb25zIiwiTWFwIiwicHJpbWl0aXZlQ2FjaGUiLCJub2RlQ2FjaGUiLCJtZXNoQ2FjaGUiLCJjYW1lcmFDYWNoZSIsImxpZ2h0Q2FjaGUiLCJzb3VyY2VDYWNoZSIsInRleHR1cmVDYWNoZSIsIm5vZGVOYW1lc1VzZWQiLCJpc1NhZmFyaSIsImlzRmlyZWZveCIsImZpcmVmb3hWZXJzaW9uIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidGVzdCIsIm1hdGNoIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJzZXRDcm9zc09yaWdpbiIsIl9pbnZva2VBbGwiLCJleHQiLCJiZWZvcmVSb290IiwiZ2V0RGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwic2NlbmUiLCJzY2VuZXMiLCJhbmltYXRpb25zIiwiY2FtZXJhcyIsImFmdGVyUm9vdCIsInVwZGF0ZU1hdHJpeFdvcmxkIiwiY2F0Y2giLCJza2luRGVmcyIsInNraW5zIiwibWVzaERlZnMiLCJza2luSW5kZXgiLCJza2luTGVuZ3RoIiwiam9pbnRzIiwiaXNCb25lIiwic2tpbiIsImlzU2tpbm5lZE1lc2giLCJjYW1lcmEiLCJyZWYiLCJ1cGRhdGVNYXBwaW5ncyIsIm9yaWdpbmFsIiwibWFwcGluZ3MiLCJjaGlsZCIsImVudHJpZXMiLCJfaW52b2tlT25lIiwiZnVuYyIsInVuc2hpZnQiLCJsb2FkU2NlbmUiLCJsb2FkTm9kZSIsImxvYWRNZXNoIiwibG9hZEFjY2Vzc29yIiwibG9hZEJ1ZmZlciIsImxvYWRNYXRlcmlhbCIsImxvYWRTa2luIiwibG9hZEFuaW1hdGlvbiIsImxvYWRDYW1lcmEiLCJkZWZzIiwibWFwIiwiZGVmIiwiYnVmZmVySW5kZXgiLCJidWZmZXJEZWYiLCJidWZmZXJzIiwiYnVmZmVyVmlld0RlZiIsImFjY2Vzc29ySW5kZXgiLCJzcGFyc2UiLCJUeXBlZEFycmF5IiwicGVuZGluZ0J1ZmZlclZpZXdzIiwiZWxlbWVudEJ5dGVzIiwiQllURVNfUEVSX0VMRU1FTlQiLCJpdGVtQnl0ZXMiLCJidWZmZXJBdHRyaWJ1dGUiLCJpYlNsaWNlIiwiZmxvb3IiLCJpYkNhY2hlS2V5IiwiaWIiLCJpdGVtU2l6ZUluZGljZXMiLCJUeXBlZEFycmF5SW5kaWNlcyIsImJ5dGVPZmZzZXRJbmRpY2VzIiwiYnl0ZU9mZnNldFZhbHVlcyIsInNwYXJzZUluZGljZXMiLCJzcGFyc2VWYWx1ZXMiLCJzZXRYIiwic2V0WSIsInNldFoiLCJzZXRXIiwic291cmNlSW5kZXgiLCJzb3VyY2VEZWYiLCJzYW1wbGVyIiwicHJvbWlzZSIsImxvYWRJbWFnZVNvdXJjZSIsImZsaXBZIiwic3RhcnRzV2l0aCIsInNhbXBsZXJzIiwibWFnRmlsdGVyIiwibWluRmlsdGVyIiwid3JhcFMiLCJ3cmFwVCIsIlVSTCIsInNlbGYiLCJ3ZWJraXRVUkwiLCJzb3VyY2VVUkkiLCJpc09iamVjdFVSTCIsImJsb2IiLCJCbG9iIiwibWltZVR5cGUiLCJjcmVhdGVPYmplY3RVUkwiLCJzb3VyY2VVUkkyIiwiaXNJbWFnZUJpdG1hcExvYWRlciIsImltYWdlQml0bWFwIiwicmV2b2tlT2JqZWN0VVJMIiwibWFwTmFtZSIsIm1hcERlZiIsImNvbG9yU3BhY2UiLCJnbHRmUmVmZXJlbmNlIiwiZW5jb2RpbmciLCJ1c2VEZXJpdmF0aXZlVGFuZ2VudHMiLCJ0YW5nZW50IiwidXNlVmVydGV4Q29sb3JzIiwidXNlRmxhdFNoYWRpbmciLCJpc1BvaW50cyIsInV1aWQiLCJwb2ludHNNYXRlcmlhbCIsInNpemVBdHRlbnVhdGlvbiIsImlzTGluZSIsImxpbmVNYXRlcmlhbCIsImNhY2hlZE1hdGVyaWFsIiwidmVydGV4Q29sb3JzIiwiZmxhdFNoYWRpbmciLCJub3JtYWxTY2FsZSIsInkiLCJtYXRlcmlhbFR5cGUiLCJtYXRlcmlhbEV4dGVuc2lvbnMiLCJrbXVFeHRlbnNpb24iLCJtZXRhbGxpY0ZhY3RvciIsInJvdWdobmVzc0ZhY3RvciIsIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsImRvdWJsZVNpZGVkIiwiYWxwaGFNb2RlIiwiZGVwdGhXcml0ZSIsImFscGhhVGVzdCIsImFscGhhQ3V0b2ZmIiwibm9ybWFsVGV4dHVyZSIsIm9jY2x1c2lvblRleHR1cmUiLCJzdHJlbmd0aCIsImFvTWFwSW50ZW5zaXR5IiwiZW1pc3NpdmVGYWN0b3IiLCJlbWlzc2l2ZVRleHR1cmUiLCJvcmlnaW5hbE5hbWUiLCJzYW5pdGl6ZWROYW1lIiwic2FuaXRpemVOb2RlTmFtZSIsImxvYWRHZW9tZXRyaWVzIiwiY3JlYXRlRHJhY29QcmltaXRpdmUiLCJhZGRQcmltaXRpdmVBdHRyaWJ1dGVzIiwiY2FjaGVkIiwiZ2VvbWV0cnlQcm9taXNlIiwibWVzaEluZGV4IiwiZ2VvbWV0cmllcyIsIm5vcm1hbGl6ZVNraW5XZWlnaHRzIiwiZ3JvdXAiLCJjYW1lcmFJbmRleCIsImNhbWVyYURlZiIsInBhcmFtcyIsInJhZFRvRGVnIiwieWZvdiIsImFzcGVjdFJhdGlvIiwiem5lYXIiLCJ6ZmFyIiwieG1hZyIsInltYWciLCJza2luRGVmIiwiX2xvYWROb2RlU2hhbGxvdyIsImludmVyc2VCaW5kTWF0cmljZXMiLCJqb2ludE5vZGVzIiwiYm9uZXMiLCJib25lSW52ZXJzZXMiLCJqb2ludE5vZGUiLCJtYXQiLCJhbmltYXRpb25JbmRleCIsImFuaW1hdGlvbkRlZiIsImFuaW1hdGlvbk5hbWUiLCJwZW5kaW5nTm9kZXMiLCJwZW5kaW5nSW5wdXRBY2Nlc3NvcnMiLCJwZW5kaW5nT3V0cHV0QWNjZXNzb3JzIiwicGVuZGluZ1NhbXBsZXJzIiwicGVuZGluZ1RhcmdldHMiLCJjaGFubmVscyIsIm5vZGUiLCJpbnB1dCIsInBhcmFtZXRlcnMiLCJvdXRwdXQiLCJpbnB1dEFjY2Vzc29ycyIsIm91dHB1dEFjY2Vzc29ycyIsInRyYWNrcyIsImlucHV0QWNjZXNzb3IiLCJvdXRwdXRBY2Nlc3NvciIsInVwZGF0ZU1hdHJpeCIsImNyZWF0ZWRUcmFja3MiLCJfY3JlYXRlQW5pbWF0aW9uVHJhY2tzIiwiayIsInRyYXZlcnNlIiwibyIsImlzTWVzaCIsIm5vZGVQZW5kaW5nIiwiY2hpbGRQZW5kaW5nIiwiY2hpbGRyZW5EZWYiLCJza2VsZXRvblBlbmRpbmciLCJza2VsZXRvbiIsImJpbmQiLCJub2RlTmFtZSIsIm1lc2hQcm9taXNlIiwiZm9yRWFjaCIsIm1hdHJpeCIsImFwcGx5TWF0cml4NCIsInF1YXRlcm5pb24iLCJoYXMiLCJzY2VuZUluZGV4Iiwic2NlbmVEZWYiLCJub2RlSWRzIiwicmVkdWNlQXNzb2NpYXRpb25zIiwicmVkdWNlZEFzc29jaWF0aW9ucyIsInZhbHVlIiwibm9kZTIiLCJ0YXJnZXROYW1lIiwiVHlwZWRLZXlmcmFtZVRyYWNrIiwiaW50ZXJwb2xhdGlvbiIsIm91dHB1dEFycmF5IiwiX2dldEFycmF5RnJvbUFjY2Vzc29yIiwiaiIsImpsIiwidHJhY2siLCJfY3JlYXRlQ3ViaWNTcGxpbmVUcmFja0ludGVycG9sYW50Iiwic2NhbGVkIiwiY3JlYXRlSW50ZXJwb2xhbnQiLCJJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUiLCJpbnRlcnBvbGFudFR5cGUiLCJ0aW1lcyIsImdldFZhbHVlU2l6ZSIsImlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lIiwiY29tcHV0ZUJvdW5kcyIsImJveCIsIm1pbiIsIm1heCIsImJveFNjYWxlIiwibXVsdGlwbHlTY2FsYXIiLCJtYXhEaXNwbGFjZW1lbnQiLCJ2ZWN0b3IiLCJhYnMiLCJleHBhbmRCeVZlY3RvciIsImJvdW5kaW5nQm94Iiwic3BoZXJlIiwiZ2V0Q2VudGVyIiwiY2VudGVyIiwicmFkaXVzIiwiZGlzdGFuY2VUbyIsImJvdW5kaW5nU3BoZXJlIiwiYXNzaWduQXR0cmlidXRlQWNjZXNzb3IiLCJnbHRmQXR0cmlidXRlTmFtZSIsImFjY2Vzc29yMiIsInNldEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key)=>obj[key];\n //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWEsQ0FBQ0MsS0FBS0MsTUFBUUQsR0FBRyxDQUFDQyxJQUFJO0FBR3ZDLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanM/MmY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBnZXRXaXRoS2V5ID0gKG9iaiwga2V5KSA9PiBvYmpba2V5XTtcbmV4cG9ydCB7XG4gIGdldFdpdGhLZXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdldFdpdGhLZXkiLCJvYmoiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups)=>{\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    let offset = 0;\n    geometries.forEach((geom, i)=>{\n        let attributesCount = 0;\n        if (isIndexed !== (geom.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        for(let name in geom.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === void 0) {\n                attributes[name] = [];\n            }\n            attributes[name].push(geom.attributes[name]);\n            attributesCount++;\n        }\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        if (morphTargetsRelative !== geom.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(let name in geom.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n            morphAttributes[name].push(geom.morphAttributes[name]);\n        }\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geom.userData);\n        if (useGroups) {\n            let count;\n            if (geom.index) {\n                count = geom.index.count;\n            } else if (geom.attributes.position !== void 0) {\n                count = geom.attributes.position.count;\n            } else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    });\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        geometries.forEach((geom)=>{\n            const index = geom.index;\n            for(let j = 0; j < index.count; ++j){\n                mergedIndex.push(index.getX(j) + indexOffset);\n            }\n            indexOffset += geom.attributes.position.count;\n        });\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    for(let name in attributes){\n        const mergedAttribute = mergeBufferAttributes(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    for(let name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j){\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            }\n            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let itemSize = void 0;\n    let normalized = void 0;\n    let arrayLength = 0;\n    attributes.forEach((attr)=>{\n        if (TypedArray === void 0) {\n            TypedArray = attr.array.constructor;\n        }\n        if (TypedArray !== attr.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === void 0) itemSize = attr.itemSize;\n        if (itemSize !== attr.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === void 0) normalized = attr.normalized;\n        if (normalized !== attr.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attr.array.length;\n    });\n    if (TypedArray && itemSize) {\n        const array = new TypedArray(arrayLength);\n        let offset = 0;\n        attributes.forEach((attr)=>{\n            array.set(attr.array, offset);\n            offset += attr.array.length;\n        });\n        return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    }\n};\nconst interleaveAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let arrayLength = 0;\n    let stride = 0;\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        for(let c = 0; c < count; c++){\n            for(let k = 0; k < itemSize; k++){\n                const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n                const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n                set(c, get(c));\n            }\n        }\n    }\n    return res;\n};\nfunction estimateBytesUsed(geometry) {\n    let mem = 0;\n    for(let name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    let nextIndex = 0;\n    const attributeNames = Object.keys(geometry.attributes);\n    const attrArrays = {};\n    const morphAttrsArrays = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        attrArrays[name] = [];\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(()=>[]);\n        }\n    }\n    const decimalShift = Math.log10(1 / tolerance);\n    const shiftMultiplier = Math.pow(10, decimalShift);\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++){\n                hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n            }\n        }\n        if (hash in hashToIndex) {\n            newIndices.push(hashToIndex[hash]);\n        } else {\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = attrArrays[name];\n                const newMorphArrays = morphAttrsArrays[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    newarray.push(attribute[getterFunc](index));\n                    if (morphAttr) {\n                        for(let m = 0, ml = morphAttr.length; m < ml; m++){\n                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n                        }\n                    }\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    const result = geometry.clone();\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const oldAttribute = geometry.getAttribute(name);\n        const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n        const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n        result.setAttribute(name, attribute);\n        if (name in morphAttrsArrays) {\n            for(let j = 0; j < morphAttrsArrays[name].length; j++){\n                const oldMorphAttribute = geometry.morphAttributes[name][j];\n                const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n                result.morphAttributes[name][j] = morphAttribute;\n            }\n        }\n    }\n    result.setIndex(newIndices);\n    return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n        let index = geometry.getIndex();\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== void 0) {\n                for(let i = 0; i < position.count; i++){\n                    indices.push(i);\n                }\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (index) {\n            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n                for(let i = 1; i <= numberOfTriangles; i++){\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                for(let i = 0; i < numberOfTriangles; i++){\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        }\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\nfunction computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n        console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n        return null;\n    }\n    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a2);\n        _vB.fromBufferAttribute(attribute, b2);\n        _vC.fromBufferAttribute(attribute, c2);\n        const morphInfluences = object2.morphTargetInfluences;\n        if (// @ts-ignore\n        material2.morphTargets && morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){\n                const influence = morphInfluences[i2];\n                const morph = morphAttribute[i2];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a2);\n                _tempB.fromBufferAttribute(morph, b2);\n                _tempC.fromBufferAttribute(morph, c2);\n                if (morphTargetsRelative2) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object2.isSkinnedMesh) {\n            object2.boneTransform(a2, _vA);\n            object2.boneTransform(b2, _vB);\n            object2.boneTransform(c2, _vC);\n        }\n        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group, groupMaterial;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else if (positionAttribute !== void 0) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n    return {\n        positionAttribute,\n        normalAttribute,\n        morphedPositionAttribute,\n        morphedNormalAttribute\n    };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 100;\n    const verts = [\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n    ];\n    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) {\n                vertexMap[hash] = [];\n            }\n            vertexMap[hash].push(normal);\n        }\n    }\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) {\n                    tempNorm2.add(otherNorm);\n                }\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n //# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRCxNQUFNVSx3QkFBd0IsQ0FBQ0MsWUFBWUM7SUFDekMsTUFBTUMsWUFBWUYsVUFBVSxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxLQUFLO0lBQzFDLE1BQU1DLGlCQUFpQixJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNQLFVBQVUsQ0FBQyxFQUFFLENBQUNRLFVBQVU7SUFDbkUsTUFBTUMsc0JBQXNCLElBQUlKLElBQUlDLE9BQU9DLElBQUksQ0FBQ1AsVUFBVSxDQUFDLEVBQUUsQ0FBQ1UsZUFBZTtJQUM3RSxNQUFNRixhQUFhLENBQUM7SUFDcEIsTUFBTUUsa0JBQWtCLENBQUM7SUFDekIsTUFBTUMsdUJBQXVCWCxVQUFVLENBQUMsRUFBRSxDQUFDVyxvQkFBb0I7SUFDL0QsTUFBTUMsaUJBQWlCLElBQUl2QixpREFBY0E7SUFDekMsSUFBSXdCLFNBQVM7SUFDYmIsV0FBV2MsT0FBTyxDQUFDLENBQUNDLE1BQU1DO1FBQ3hCLElBQUlDLGtCQUFrQjtRQUN0QixJQUFJZixjQUFlYSxDQUFBQSxLQUFLWixLQUFLLEtBQUssSUFBRyxHQUFJO1lBQ3ZDZSxRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO1lBRTdGLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUksUUFBUUwsS0FBS1AsVUFBVSxDQUFFO1lBQ2hDLElBQUksQ0FBQ0osZUFBZWlCLEdBQUcsQ0FBQ0QsT0FBTztnQkFDN0JGLFFBQVFDLEtBQUssQ0FDWCx1RkFBdUZILElBQUksa0VBQWtFSSxPQUFPO2dCQUV0SyxPQUFPO1lBQ1Q7WUFDQSxJQUFJWixVQUFVLENBQUNZLEtBQUssS0FBSyxLQUFLLEdBQUc7Z0JBQy9CWixVQUFVLENBQUNZLEtBQUssR0FBRyxFQUFFO1lBQ3ZCO1lBQ0FaLFVBQVUsQ0FBQ1ksS0FBSyxD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b2R1bGVzL3RocmVlLXN0ZGxpYi91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzPzEyZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnksIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBUcmlhbmdsZXNEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBWZWN0b3IzLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBnZXRXaXRoS2V5IH0gZnJvbSBcIi4uL3R5cGVzL2hlbHBlcnMuanNcIjtcbmNvbnN0IG1lcmdlQnVmZmVyR2VvbWV0cmllcyA9IChnZW9tZXRyaWVzLCB1c2VHcm91cHMpID0+IHtcbiAgY29uc3QgaXNJbmRleGVkID0gZ2VvbWV0cmllc1swXS5pbmRleCAhPT0gbnVsbDtcbiAgY29uc3QgYXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0uYXR0cmlidXRlcykpO1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLm1vcnBoQXR0cmlidXRlcykpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJpZXNbMF0ubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG1lcmdlZEdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20sIGkpID0+IHtcbiAgICBsZXQgYXR0cmlidXRlc0NvdW50ID0gMDtcbiAgICBpZiAoaXNJbmRleGVkICE9PSAoZ2VvbS5pbmRleCAhPT0gbnVsbCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgaW5kZXggYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArICcuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgIGF0dHJpYnV0ZXNDb3VudCsrO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlc0NvdW50ICE9PSBhdHRyaWJ1dGVzVXNlZC5zaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gTWFrZSBzdXJlIGFsbCBnZW9tZXRyaWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlICE9PSBnZW9tLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gLm1vcnBoVGFyZ2V0c1JlbGF0aXZlIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAobGV0IG5hbWUgaW4gZ2VvbS5tb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghbW9ycGhBdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gIC5tb3JwaEF0dHJpYnV0ZXMgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobW9ycGhBdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApXG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2goZ2VvbS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSA9IG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhIHx8IFtdO1xuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhLnB1c2goZ2VvbS51c2VyRGF0YSk7XG4gICAgaWYgKHVzZUdyb3Vwcykge1xuICAgICAgbGV0IGNvdW50O1xuICAgICAgaWYgKGdlb20uaW5kZXgpIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmluZGV4LmNvdW50O1xuICAgICAgfSBlbHNlIGlmIChnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBjb3VudCA9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIFRoZSBnZW9tZXRyeSBtdXN0IGhhdmUgZWl0aGVyIGFuIGluZGV4IG9yIGEgcG9zaXRpb24gYXR0cmlidXRlXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5hZGRHcm91cChvZmZzZXQsIGNvdW50LCBpKTtcbiAgICAgIG9mZnNldCArPSBjb3VudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoaXNJbmRleGVkKSB7XG4gICAgbGV0IGluZGV4T2Zmc2V0ID0gMDtcbiAgICBjb25zdCBtZXJnZWRJbmRleCA9IFtdO1xuICAgIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBnZW9tLmluZGV4O1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRleC5jb3VudDsgKytqKSB7XG4gICAgICAgIG1lcmdlZEluZGV4LnB1c2goaW5kZXguZ2V0WChqKSArIGluZGV4T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGluZGV4T2Zmc2V0ICs9IGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcbiAgICB9KTtcbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRJbmRleChtZXJnZWRJbmRleCk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgIGlmICghbWVyZ2VkQXR0cmlidXRlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBhdHRyaWJ1dGUuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0QXR0cmlidXRlKG5hbWUsIG1lcmdlZEF0dHJpYnV0ZSk7XG4gIH1cbiAgZm9yIChsZXQgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bMF0ubGVuZ3RoO1xuICAgIGlmIChudW1Nb3JwaFRhcmdldHMgPT09IDApXG4gICAgICBicmVhaztcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgPSBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgfHwge307XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7ICsraSkge1xuICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZS5wdXNoKG1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXVtpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWRNb3JwaEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhtb3JwaEF0dHJpYnV0ZXNUb01lcmdlKTtcbiAgICAgIGlmICghbWVyZ2VkTW9ycGhBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSBcIiArIG5hbWUgKyBcIiBtb3JwaEF0dHJpYnV0ZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKG1lcmdlZE1vcnBoQXR0cmlidXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZEdlb21ldHJ5O1xufTtcbmNvbnN0IG1lcmdlQnVmZmVyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgaXRlbVNpemUgPSB2b2lkIDA7XG4gIGxldCBub3JtYWxpemVkID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKSB7XG4gICAgICBUeXBlZEFycmF5ID0gYXR0ci5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHIuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLmFycmF5IG11c3QgYmUgb2YgY29uc2lzdGVudCBhcnJheSB0eXBlcyBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXRlbVNpemUgPT09IHZvaWQgMClcbiAgICAgIGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcbiAgICBpZiAoaXRlbVNpemUgIT09IGF0dHIuaXRlbVNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLml0ZW1TaXplIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZCA9PT0gdm9pZCAwKVxuICAgICAgbm9ybWFsaXplZCA9IGF0dHIubm9ybWFsaXplZDtcbiAgICBpZiAobm9ybWFsaXplZCAhPT0gYXR0ci5ub3JtYWxpemVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgfSk7XG4gIGlmIChUeXBlZEFycmF5ICYmIGl0ZW1TaXplKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBhcnJheS5zZXQoYXR0ci5hcnJheSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhdHRyLmFycmF5Lmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICB9XG59O1xuY29uc3QgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgbGV0IHN0cmlkZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApXG4gICAgICBUeXBlZEFycmF5ID0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdHRyaWJ1dGVCdWZmZXJzIG9mIGRpZmZlcmVudCB0eXBlcyBjYW5ub3QgYmUgaW50ZXJsZWF2ZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0cmlidXRlLmFycmF5Lmxlbmd0aDtcbiAgICBzdHJpZGUgKz0gYXR0cmlidXRlLml0ZW1TaXplO1xuICB9XG4gIGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKSwgc3RyaWRlKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgY29uc3Qgc2V0dGVycyA9IFtcInNldFhcIiwgXCJzZXRZXCIsIFwic2V0WlwiLCBcInNldFdcIl07XG4gIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgIGNvbnN0IGNvdW50ID0gYXR0cmlidXRlLmNvdW50O1xuICAgIGNvbnN0IGliYSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlcy5wdXNoKGliYSk7XG4gICAgb2Zmc2V0ICs9IGl0ZW1TaXplO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldFdpdGhLZXkoaWJhLCBzZXR0ZXJzW2tdKTtcbiAgICAgICAgY29uc3QgZ2V0ID0gZ2V0V2l0aEtleShhdHRyaWJ1dGUsIGdldHRlcnNba10pO1xuICAgICAgICBzZXQoYywgZ2V0KGMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBlc3RpbWF0ZUJ5dGVzVXNlZChnZW9tZXRyeSkge1xuICBsZXQgbWVtID0gMDtcbiAgZm9yIChsZXQgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0ciA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBtZW0gKz0gYXR0ci5jb3VudCAqIGF0dHIuaXRlbVNpemUgKiBhdHRyLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICB9XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBtZW0gKz0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgKiBpbmRpY2VzLml0ZW1TaXplICogaW5kaWNlcy5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IDA7XG4gIHJldHVybiBtZW07XG59XG5mdW5jdGlvbiBtZXJnZVZlcnRpY2VzKGdlb21ldHJ5LCB0b2xlcmFuY2UgPSAxZS00KSB7XG4gIHRvbGVyYW5jZSA9IE1hdGgubWF4KHRvbGVyYW5jZSwgTnVtYmVyLkVQU0lMT04pO1xuICBjb25zdCBoYXNoVG9JbmRleCA9IHt9O1xuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gIGNvbnN0IHZlcnRleENvdW50ID0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgOiBwb3NpdGlvbnMuY291bnQ7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGdlb21ldHJ5LmF0dHJpYnV0ZXMpO1xuICBjb25zdCBhdHRyQXJyYXlzID0ge307XG4gIGNvbnN0IG1vcnBoQXR0cnNBcnJheXMgPSB7fTtcbiAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICBjb25zdCBnZXR0ZXJzID0gW1wiZ2V0WFwiLCBcImdldFlcIiwgXCJnZXRaXCIsIFwiZ2V0V1wiXTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgYXR0ckFycmF5c1tuYW1lXSA9IFtdO1xuICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICBtb3JwaEF0dHJzQXJyYXlzW25hbWVdID0gbmV3IEFycmF5KG1vcnBoQXR0ci5sZW5ndGgpLmZpbGwoMCkubWFwKCgpID0+IFtdKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFNoaWZ0ID0gTWF0aC5sb2cxMCgxIC8gdG9sZXJhbmNlKTtcbiAgY29uc3Qgc2hpZnRNdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIGRlY2ltYWxTaGlmdCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgIGNvbnN0IGluZGV4ID0gaW5kaWNlcyA/IGluZGljZXMuZ2V0WChpKSA6IGk7XG4gICAgbGV0IGhhc2ggPSBcIlwiO1xuICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBoYXNoICs9IGAke35+KGF0dHJpYnV0ZVtnZXR0ZXJzW2tdXShpbmRleCkgKiBzaGlmdE11bHRpcGxpZXIpfSxgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzaCBpbiBoYXNoVG9JbmRleCkge1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKGhhc2hUb0luZGV4W2hhc2hdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICAgIGNvbnN0IG5ld2FycmF5ID0gYXR0ckFycmF5c1tuYW1lXTtcbiAgICAgICAgY29uc3QgbmV3TW9ycGhBcnJheXMgPSBtb3JwaEF0dHJzQXJyYXlzW25hbWVdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBnZXR0ZXJGdW5jID0gZ2V0dGVyc1trXTtcbiAgICAgICAgICBuZXdhcnJheS5wdXNoKGF0dHJpYnV0ZVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0ci5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG4gICAgICAgICAgICAgIG5ld01vcnBoQXJyYXlzW21dLnB1c2gobW9ycGhBdHRyW21dW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYXNoVG9JbmRleFtoYXNoXSA9IG5leHRJbmRleDtcbiAgICAgIG5ld0luZGljZXMucHVzaChuZXh0SW5kZXgpO1xuICAgICAgbmV4dEluZGV4Kys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGdlb21ldHJ5LmNsb25lKCk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgb2xkQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKGF0dHJBcnJheXNbbmFtZV0pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyLCBvbGRBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXN1bHQuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZSk7XG4gICAgaWYgKG5hbWUgaW4gbW9ycGhBdHRyc0FycmF5cykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJzQXJyYXlzW25hbWVdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG9sZE1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdO1xuICAgICAgICBjb25zdCBidWZmZXIyID0gbmV3IG9sZE1vcnBoQXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKG1vcnBoQXR0cnNBcnJheXNbbmFtZV1bal0pO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyMiwgb2xkTW9ycGhBdHRyaWJ1dGUuaXRlbVNpemUsIG9sZE1vcnBoQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgICAgICByZXN1bHQubW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdID0gbW9ycGhBdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc3VsdC5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvVHJpYW5nbGVzRHJhd01vZGUoZ2VvbWV0cnksIGRyYXdNb2RlKSB7XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVzRHJhd01vZGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogR2VvbWV0cnkgYWxyZWFkeSBkZWZpbmVkIGFzIHRyaWFuZ2xlcy5cIik7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSB8fCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVTdHJpcERyYXdNb2RlKSB7XG4gICAgbGV0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7XG4gICAgICBpZiAocG9zaXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmNvdW50OyBpKyspIHtcbiAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoaW5kaWNlcyk7XG4gICAgICAgIGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBudW1iZXJPZlRyaWFuZ2xlcyA9IGluZGV4LmNvdW50IC0gMjtcbiAgICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKDApKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDIpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdJbmRpY2VzLmxlbmd0aCAvIDMgIT09IG51bWJlck9mVHJpYW5nbGVzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdHZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgbmV3R2VvbWV0cnkuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gICAgbmV3R2VvbWV0cnkuY2xlYXJHcm91cHMoKTtcbiAgICByZXR1cm4gbmV3R2VvbWV0cnk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmtub3duIGRyYXcgbW9kZTpcIiwgZHJhd01vZGUpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzKG9iamVjdCkge1xuICBpZiAob2JqZWN0Lmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgIT09IHRydWUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgQnVmZmVyR2VvbWV0cnkuXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IF92QSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF92QyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF90ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQyA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShvYmplY3QyLCBtYXRlcmlhbDIsIGF0dHJpYnV0ZSwgbW9ycGhBdHRyaWJ1dGUsIG1vcnBoVGFyZ2V0c1JlbGF0aXZlMiwgYTIsIGIyLCBjMiwgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheSkge1xuICAgIF92QS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYTIpO1xuICAgIF92Qi5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYjIpO1xuICAgIF92Qy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgYzIpO1xuICAgIGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG9iamVjdDIubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuICAgIGlmIChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG1hdGVyaWFsMi5tb3JwaFRhcmdldHMgJiYgbW9ycGhBdHRyaWJ1dGUgJiYgbW9ycGhJbmZsdWVuY2VzXG4gICAgKSB7XG4gICAgICBfbW9ycGhBLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEIuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQy5zZXQoMCwgMCwgMCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGlsMiA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaTIgPCBpbDI7IGkyKyspIHtcbiAgICAgICAgY29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzW2kyXTtcbiAgICAgICAgY29uc3QgbW9ycGggPSBtb3JwaEF0dHJpYnV0ZVtpMl07XG4gICAgICAgIGlmIChpbmZsdWVuY2UgPT09IDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIF90ZW1wQS5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBhMik7XG4gICAgICAgIF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBiMik7XG4gICAgICAgIF90ZW1wQy5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoLCBjMik7XG4gICAgICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZTIpIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQywgaW5mbHVlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEuc3ViKF92QSksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLnN1YihfdkIpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQy5zdWIoX3ZDKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3ZBLmFkZChfbW9ycGhBKTtcbiAgICAgIF92Qi5hZGQoX21vcnBoQik7XG4gICAgICBfdkMuYWRkKF9tb3JwaEMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0Mi5pc1NraW5uZWRNZXNoKSB7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYTIsIF92QSk7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYjIsIF92Qik7XG4gICAgICBvYmplY3QyLmJvbmVUcmFuc2Zvcm0oYzIsIF92Qyk7XG4gICAgfVxuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMF0gPSBfdkEueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDFdID0gX3ZBLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAyXSA9IF92QS56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMF0gPSBfdkIueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDFdID0gX3ZCLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAyXSA9IF92Qi56O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMF0gPSBfdkMueDtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDFdID0gX3ZDLnk7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAyXSA9IF92Qy56O1xuICB9XG4gIGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuICBjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcbiAgbGV0IGEsIGIsIGM7XG4gIGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3Qgbm9ybWFsQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gIGNvbnN0IG1vcnBoTm9ybWFsID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gIGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcbiAgbGV0IGksIGosIGlsLCBqbDtcbiAgbGV0IGdyb3VwLCBncm91cE1hdGVyaWFsO1xuICBsZXQgc3RhcnQsIGVuZDtcbiAgY29uc3QgbW9kaWZpZWRQb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiBwb3NpdGlvbkF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGNvbnN0IG1vZGlmaWVkTm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxBdHRyaWJ1dGUuY291bnQgKiBub3JtYWxBdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBpbmRleC5nZXRYKGopO1xuICAgICAgICAgIGIgPSBpbmRleC5nZXRYKGogKyAxKTtcbiAgICAgICAgICBjID0gaW5kZXguZ2V0WChqICsgMik7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4oaW5kZXguY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpbmRleC5nZXRYKGkpO1xuICAgICAgICBiID0gaW5kZXguZ2V0WChpICsgMSk7XG4gICAgICAgIGMgPSBpbmRleC5nZXRYKGkgKyAyKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocG9zaXRpb25BdHRyaWJ1dGUgIT09IHZvaWQgMCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGo7XG4gICAgICAgICAgYiA9IGogKyAxO1xuICAgICAgICAgIGMgPSBqICsgMjtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGk7XG4gICAgICAgIGIgPSBpICsgMTtcbiAgICAgICAgYyA9IGkgKyAyO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZFBvc2l0aW9uLCAzKTtcbiAgY29uc3QgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkTm9ybWFsLCAzKTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG1vcnBoZWROb3JtYWxBdHRyaWJ1dGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ3JlYXNlZE5vcm1hbHMoZ2VvbWV0cnksIGNyZWFzZUFuZ2xlID0gTWF0aC5QSSAvIDMpIHtcbiAgY29uc3QgY3JlYXNlRG90ID0gTWF0aC5jb3MoY3JlYXNlQW5nbGUpO1xuICBjb25zdCBoYXNoTXVsdGlwbGllciA9ICgxICsgMWUtMTApICogMTAwO1xuICBjb25zdCB2ZXJ0cyA9IFtuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpXTtcbiAgY29uc3QgdGVtcFZlYzEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wVmVjMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0yID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gaGFzaFZlcnRleCh2KSB7XG4gICAgY29uc3QgeCA9IH5+KHYueCAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB5ID0gfn4odi55ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHogPSB+fih2LnogKiBoYXNoTXVsdGlwbGllcik7XG4gICAgcmV0dXJuIGAke3h9LCR7eX0sJHt6fWA7XG4gIH1cbiAgY29uc3QgcmVzdWx0R2VvbWV0cnkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpIDogZ2VvbWV0cnk7XG4gIGNvbnN0IHBvc0F0dHIgPSByZXN1bHRHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb3NBdHRyLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGkzID0gMyAqIGk7XG4gICAgY29uc3QgYSA9IHZlcnRzWzBdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAwKTtcbiAgICBjb25zdCBiID0gdmVydHNbMV0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDEpO1xuICAgIGNvbnN0IGMgPSB2ZXJ0c1syXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMik7XG4gICAgdGVtcFZlYzEuc3ViVmVjdG9ycyhjLCBiKTtcbiAgICB0ZW1wVmVjMi5zdWJWZWN0b3JzKGEsIGIpO1xuICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgaWYgKCEoaGFzaCBpbiB2ZXJ0ZXhNYXApKSB7XG4gICAgICAgIHZlcnRleE1hcFtoYXNoXSA9IFtdO1xuICAgICAgfVxuICAgICAgdmVydGV4TWFwW2hhc2hdLnB1c2gobm9ybWFsKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9ybWFsQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBvc0F0dHIuY291bnQgKiAzKTtcbiAgY29uc3Qgbm9ybUF0dHIgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5vcm1hbEFycmF5LCAzLCBmYWxzZSk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICB0ZW1wTm9ybS5jcm9zc1ZlY3RvcnModGVtcFZlYzEsIHRlbXBWZWMyKS5ub3JtYWxpemUoKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDM7IG4rKykge1xuICAgICAgY29uc3QgdmVydCA9IHZlcnRzW25dO1xuICAgICAgY29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgodmVydCk7XG4gICAgICBjb25zdCBvdGhlck5vcm1hbHMgPSB2ZXJ0ZXhNYXBbaGFzaF07XG4gICAgICB0ZW1wTm9ybTIuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgayA9IDAsIGxrID0gb3RoZXJOb3JtYWxzLmxlbmd0aDsgayA8IGxrOyBrKyspIHtcbiAgICAgICAgY29uc3Qgb3RoZXJOb3JtID0gb3RoZXJOb3JtYWxzW2tdO1xuICAgICAgICBpZiAodGVtcE5vcm0uZG90KG90aGVyTm9ybSkgPiBjcmVhc2VEb3QpIHtcbiAgICAgICAgICB0ZW1wTm9ybTIuYWRkKG90aGVyTm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBOb3JtMi5ub3JtYWxpemUoKTtcbiAgICAgIG5vcm1BdHRyLnNldFhZWihpMyArIG4sIHRlbXBOb3JtMi54LCB0ZW1wTm9ybTIueSwgdGVtcE5vcm0yLnopO1xuICAgIH1cbiAgfVxuICByZXN1bHRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJub3JtYWxcIiwgbm9ybUF0dHIpO1xuICByZXR1cm4gcmVzdWx0R2VvbWV0cnk7XG59XG5leHBvcnQge1xuICBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMsXG4gIGVzdGltYXRlQnl0ZXNVc2VkLFxuICBpbnRlcmxlYXZlQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzLFxuICBtZXJnZUJ1ZmZlckdlb21ldHJpZXMsXG4gIG1lcmdlVmVydGljZXMsXG4gIHRvQ3JlYXNlZE5vcm1hbHMsXG4gIHRvVHJpYW5nbGVzRHJhd01vZGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJHZW9tZXRyeVV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkJ1ZmZlckdlb21ldHJ5IiwiQnVmZmVyQXR0cmlidXRlIiwiSW50ZXJsZWF2ZWRCdWZmZXIiLCJJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSIsIlRyaWFuZ2xlc0RyYXdNb2RlIiwiVHJpYW5nbGVGYW5EcmF3TW9kZSIsIlRyaWFuZ2xlU3RyaXBEcmF3TW9kZSIsIlZlY3RvcjMiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwiZ2V0V2l0aEtleSIsIm1lcmdlQnVmZmVyR2VvbWV0cmllcyIsImdlb21ldHJpZXMiLCJ1c2VHcm91cHMiLCJpc0luZGV4ZWQiLCJpbmRleCIsImF0dHJpYnV0ZXNVc2VkIiwiU2V0IiwiT2JqZWN0Iiwia2V5cyIsImF0dHJpYnV0ZXMiLCJtb3JwaEF0dHJpYnV0ZXNVc2VkIiwibW9ycGhBdHRyaWJ1dGVzIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUiLCJtZXJnZWRHZW9tZXRyeSIsIm9mZnNldCIsImZvckVhY2giLCJnZW9tIiwiaSIsImF0dHJpYnV0ZXNDb3VudCIsImNvbnNvbGUiLCJlcnJvciIsIm5hbWUiLCJoYXMiLCJwdXNoIiwic2l6ZSIsInVzZXJEYXRhIiwibWVyZ2VkVXNlckRhdGEiLCJjb3VudCIsInBvc2l0aW9uIiwiYWRkR3JvdXAiLCJpbmRleE9mZnNldCIsIm1lcmdlZEluZGV4IiwiaiIsImdldFgiLCJzZXRJbmRleCIsIm1lcmdlZEF0dHJpYnV0ZSIsIm1lcmdlQnVmZmVyQXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsIm51bU1vcnBoVGFyZ2V0cyIsImxlbmd0aCIsIm1vcnBoQXR0cmlidXRlc1RvTWVyZ2UiLCJtZXJnZWRNb3JwaEF0dHJpYnV0ZSIsIlR5cGVkQXJyYXkiLCJpdGVtU2l6ZSIsIm5vcm1hbGl6ZWQiLCJhcnJheUxlbmd0aCIsImF0dHIiLCJhcnJheSIsImNvbnN0cnVjdG9yIiwic2V0IiwiaW50ZXJsZWF2ZUF0dHJpYnV0ZXMiLCJzdHJpZGUiLCJsIiwiYXR0cmlidXRlIiwiaW50ZXJsZWF2ZWRCdWZmZXIiLCJyZXMiLCJnZXR0ZXJzIiwic2V0dGVycyIsImliYSIsImMiLCJrIiwiZ2V0IiwiZXN0aW1hdGVCeXRlc1VzZWQiLCJnZW9tZXRyeSIsIm1lbSIsImdldEF0dHJpYnV0ZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiaW5kaWNlcyIsImdldEluZGV4IiwibWVyZ2VWZXJ0aWNlcyIsInRvbGVyYW5jZSIsIk1hdGgiLCJtYXgiLCJOdW1iZXIiLCJFUFNJTE9OIiwiaGFzaFRvSW5kZXgiLCJwb3NpdGlvbnMiLCJ2ZXJ0ZXhDb3VudCIsIm5leHRJbmRleCIsImF0dHJpYnV0ZU5hbWVzIiwiYXR0ckFycmF5cyIsIm1vcnBoQXR0cnNBcnJheXMiLCJuZXdJbmRpY2VzIiwibW9ycGhBdHRyIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiZGVjaW1hbFNoaWZ0IiwibG9nMTAiLCJzaGlmdE11bHRpcGxpZXIiLCJwb3ciLCJoYXNoIiwibmV3YXJyYXkiLCJuZXdNb3JwaEFycmF5cyIsImdldHRlckZ1bmMiLCJtIiwibWwiLCJyZXN1bHQiLCJjbG9uZSIsIm9sZEF0dHJpYnV0ZSIsImJ1ZmZlciIsIm9sZE1vcnBoQXR0cmlidXRlIiwiYnVmZmVyMiIsIm1vcnBoQXR0cmlidXRlIiwidG9UcmlhbmdsZXNEcmF3TW9kZSIsImRyYXdNb2RlIiwid2FybiIsIm51bWJlck9mVHJpYW5nbGVzIiwibmV3R2VvbWV0cnkiLCJjbGVhckdyb3VwcyIsImNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyIsIm9iamVjdCIsImlzQnVmZmVyR2VvbWV0cnkiLCJfdkEiLCJfdkIiLCJfdkMiLCJfdGVtcEEiLCJfdGVtcEIiLCJfdGVtcEMiLCJfbW9ycGhBIiwiX21vcnBoQiIsIl9tb3JwaEMiLCJfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEiLCJvYmplY3QyIiwibWF0ZXJpYWwyIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUyIiwiYTIiLCJiMiIsImMyIiwibW9kaWZpZWRBdHRyaWJ1dGVBcnJheSIsImZyb21CdWZmZXJBdHRyaWJ1dGUiLCJtb3JwaEluZmx1ZW5jZXMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJtb3JwaFRhcmdldHMiLCJpMiIsImlsMiIsImluZmx1ZW5jZSIsIm1vcnBoIiwiYWRkU2NhbGVkVmVjdG9yIiwic3ViIiwiYWRkIiwiaXNTa2lubmVkTWVzaCIsImJvbmVUcmFuc2Zvcm0iLCJ4IiwieSIsInoiLCJtYXRlcmlhbCIsImEiLCJiIiwicG9zaXRpb25BdHRyaWJ1dGUiLCJtb3JwaFBvc2l0aW9uIiwibm9ybWFsQXR0cmlidXRlIiwibm9ybWFsIiwibW9ycGhOb3JtYWwiLCJncm91cHMiLCJkcmF3UmFuZ2UiLCJpbCIsImpsIiwiZ3JvdXAiLCJncm91cE1hdGVyaWFsIiwic3RhcnQiLCJlbmQiLCJtb2RpZmllZFBvc2l0aW9uIiwiRmxvYXQzMkFycmF5IiwibW9kaWZpZWROb3JtYWwiLCJpc0FycmF5IiwibWF0ZXJpYWxJbmRleCIsIm1pbiIsIm1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSIsIm1vcnBoZWROb3JtYWxBdHRyaWJ1dGUiLCJ0b0NyZWFzZWROb3JtYWxzIiwiY3JlYXNlQW5nbGUiLCJQSSIsImNyZWFzZURvdCIsImNvcyIsImhhc2hNdWx0aXBsaWVyIiwidmVydHMiLCJ0ZW1wVmVjMSIsInRlbXBWZWMyIiwidGVtcE5vcm0iLCJ0ZW1wTm9ybTIiLCJoYXNoVmVydGV4IiwidiIsInJlc3VsdEdlb21ldHJ5IiwidG9Ob25JbmRleGVkIiwicG9zQXR0ciIsInZlcnRleE1hcCIsImkzIiwic3ViVmVjdG9ycyIsImNyb3NzVmVjdG9ycyIsIm5vcm1hbGl6ZSIsIm4iLCJ2ZXJ0Iiwibm9ybWFsQXJyYXkiLCJub3JtQXR0ciIsIm90aGVyTm9ybWFscyIsImxrIiwib3RoZXJOb3JtIiwiZG90Iiwic2V0WFlaIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/utils/SkeletonUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SkeletonUtils: () => (/* binding */ SkeletonUtils)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nfunction retarget(target, source, options = {}) {\n    const pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), bindBoneMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), relativeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), globalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n    options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n    options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n    options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n    options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n    options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n    options.names = options.names || {};\n    const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n    let bindBones, bone, name, boneTo, bonesPosition;\n    if (target.isObject3D) {\n        target.skeleton.pose();\n    } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n    }\n    if (options.preservePosition) {\n        bonesPosition = [];\n        for(let i = 0; i < bones.length; i++){\n            bonesPosition.push(bones[i].position.clone());\n        }\n    }\n    if (options.preserveMatrix) {\n        target.updateMatrixWorld();\n        target.matrixWorld.identity();\n        for(let i = 0; i < target.children.length; ++i){\n            target.children[i].updateMatrixWorld(true);\n        }\n    }\n    if (options.offsets) {\n        bindBones = [];\n        for(let i = 0; i < bones.length; ++i){\n            bone = bones[i];\n            name = options.names[bone.name] || bone.name;\n            if (options.offsets[name]) {\n                bone.matrix.multiply(options.offsets[name]);\n                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n                bone.updateMatrixWorld();\n            }\n            bindBones.push(bone.matrixWorld.clone());\n        }\n    }\n    for(let i = 0; i < bones.length; ++i){\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n        if (boneTo) {\n            boneTo.updateMatrixWorld();\n            if (options.useTargetMatrix) {\n                relativeMatrix.copy(boneTo.matrixWorld);\n            } else {\n                relativeMatrix.copy(target.matrixWorld).invert();\n                relativeMatrix.multiply(boneTo.matrixWorld);\n            }\n            scale.setFromMatrixScale(relativeMatrix);\n            relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n            globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n            if (target.isObject3D) {\n                const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n                globalMatrix.multiply(wBindMatrix);\n            }\n            globalMatrix.copyPosition(relativeMatrix);\n        }\n        if (bone.parent && bone.parent.isBone) {\n            bone.matrix.copy(bone.parent.matrixWorld).invert();\n            bone.matrix.multiply(globalMatrix);\n        } else {\n            bone.matrix.copy(globalMatrix);\n        }\n        if (options.preserveHipPosition && name === options.hip) {\n            bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n    }\n    if (options.preservePosition) {\n        for(let i = 0; i < bones.length; ++i){\n            bone = bones[i];\n            name = options.names[bone.name] || bone.name;\n            if (name !== options.hip) {\n                bone.position.copy(bonesPosition[i]);\n            }\n        }\n    }\n    if (options.preserveMatrix) {\n        target.updateMatrixWorld(true);\n    }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n    options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== void 0 ? options.fps : 30;\n    options.names = options.names || [];\n    if (!source.isObject3D) {\n        source = getHelperFromSkeleton(source);\n    }\n    const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(source), bones = getBones(target.skeleton), boneDatas = [];\n    let positionOffset, bone, boneTo, boneData, name;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n    for(let i = 0; i < numFrames; ++i){\n        const time = i * delta;\n        retarget(target, source, options);\n        for(let j = 0; j < bones.length; ++j){\n            name = options.names[bones[j].name] || bones[j].name;\n            boneTo = getBoneByName(name, source.skeleton);\n            if (boneTo) {\n                bone = bones[j];\n                boneData = boneDatas[j] = boneDatas[j] || {\n                    bone\n                };\n                if (options.hip === name) {\n                    if (!boneData.pos) {\n                        boneData.pos = {\n                            times: new Float32Array(numFrames),\n                            values: new Float32Array(numFrames * 3)\n                        };\n                    }\n                    if (options.useFirstFramePosition) {\n                        if (i === 0) {\n                            positionOffset = bone.position.clone();\n                        }\n                        bone.position.sub(positionOffset);\n                    }\n                    boneData.pos.times[i] = time;\n                    bone.position.toArray(boneData.pos.values, i * 3);\n                }\n                if (!boneData.quat) {\n                    boneData.quat = {\n                        times: new Float32Array(numFrames),\n                        values: new Float32Array(numFrames * 4)\n                    };\n                }\n                boneData.quat.times[i] = time;\n                bone.quaternion.toArray(boneData.quat.values, i * 4);\n            }\n        }\n        mixer.update(delta);\n        source.updateMatrixWorld();\n    }\n    for(let i = 0; i < boneDatas.length; ++i){\n        boneData = boneDatas[i];\n        if (boneData) {\n            if (boneData.pos) {\n                convertedTracks.push(new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n            }\n            convertedTracks.push(new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n        }\n    }\n    mixer.uncacheAction(clip);\n    return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n    const sourceLookup = /* @__PURE__ */ new Map();\n    const cloneLookup = /* @__PURE__ */ new Map();\n    const clone2 = source.clone();\n    parallelTraverse(source, clone2, function(sourceNode, clonedNode) {\n        sourceLookup.set(clonedNode, sourceNode);\n        cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone2.traverse(function(node) {\n        if (!node.isSkinnedMesh) return;\n        const clonedMesh = node;\n        const sourceMesh = sourceLookup.get(node);\n        const sourceBones = sourceMesh.skeleton.bones;\n        clonedMesh.skeleton = sourceMesh.skeleton.clone();\n        clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n        clonedMesh.skeleton.bones = sourceBones.map(function(bone) {\n            return cloneLookup.get(bone);\n        });\n        clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n    for(let i = 0, bones = getBones(skeleton); i < bones.length; i++){\n        if (name === bones[i].name) return bones[i];\n    }\n}\nfunction getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n    const source = new three__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n}\nfunction parallelTraverse(a, b, callback) {\n    callback(a, b);\n    for(let i = 0; i < a.children.length; i++){\n        parallelTraverse(a.children[i], b.children[i], callback);\n    }\n}\nconst SkeletonUtils = {\n    retarget,\n    retargetClip,\n    clone\n};\n //# sourceMappingURL=SkeletonUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0o7QUFDbEosU0FBU1EsU0FBU0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLE1BQU1DLE1BQU0sSUFBSVosMENBQU9BLElBQUlhLE9BQU8sSUFBSVosNkNBQVVBLElBQUlhLFFBQVEsSUFBSWQsMENBQU9BLElBQUllLGlCQUFpQixJQUFJYiwwQ0FBT0EsSUFBSWMsaUJBQWlCLElBQUlkLDBDQUFPQSxJQUFJZSxlQUFlLElBQUlmLDBDQUFPQTtJQUNyS1MsUUFBUU8sY0FBYyxHQUFHUCxRQUFRTyxjQUFjLEtBQUssS0FBSyxJQUFJUCxRQUFRTyxjQUFjLEdBQUc7SUFDdEZQLFFBQVFRLGdCQUFnQixHQUFHUixRQUFRUSxnQkFBZ0IsS0FBSyxLQUFLLElBQUlSLFFBQVFRLGdCQUFnQixHQUFHO0lBQzVGUixRQUFRUyxtQkFBbUIsR0FBR1QsUUFBUVMsbUJBQW1CLEtBQUssS0FBSyxJQUFJVCxRQUFRUyxtQkFBbUIsR0FBRztJQUNyR1QsUUFBUVUsZUFBZSxHQUFHVixRQUFRVSxlQUFlLEtBQUssS0FBSyxJQUFJVixRQUFRVSxlQUFlLEdBQUc7SUFDekZWLFFBQVFXLEdBQUcsR0FBR1gsUUFBUVcsR0FBRyxLQUFLLEtBQUssSUFBSVgsUUFBUVcsR0FBRyxHQUFHO0lBQ3JEWCxRQUFRWSxLQUFLLEdBQUdaLFFBQVFZLEtBQUssSUFBSSxDQUFDO0lBQ2xDLE1BQU1DLGNBQWNkLE9BQU9lLFVBQVUsR0FBR2YsT0FBT2dCLFFBQVEsQ0FBQ0MsS0FBSyxHQUFHQyxTQUFTbEIsU0FBU2lCLFFBQVFsQixPQUFPZ0IsVUFBVSxHQUFHaEIsT0FBT2lCLFFBQVEsQ0FBQ0MsS0FBSyxHQUFHQyxTQUFTbkI7SUFDL0ksSUFBSW9CLFdBQVdDLE1BQU1DLE1BQU1DLFFBQVFDO0lBQ25DLElBQUl4QixPQUFPZ0Is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RSxFQUFFNkUsRUFBRXJFLFFBQVEsQ0FBQ1IsRUFBRSxFQUFFOEU7SUFDakQ7QUFDRjtBQUNBLE1BQU1DLGdCQUFnQjtJQUFFMUc7SUFBVTJEO0lBQWM1QjtBQUFNO0FBR3BELENBQ0YseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanM/Yjk2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IzLCBRdWF0ZXJuaW9uLCBNYXRyaXg0LCBBbmltYXRpb25NaXhlciwgVmVjdG9yS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIEFuaW1hdGlvbkNsaXAsIFNrZWxldG9uSGVscGVyIH0gZnJvbSBcInRocmVlXCI7XG5mdW5jdGlvbiByZXRhcmdldCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBvcyA9IG5ldyBWZWN0b3IzKCksIHF1YXQgPSBuZXcgUXVhdGVybmlvbigpLCBzY2FsZSA9IG5ldyBWZWN0b3IzKCksIGJpbmRCb25lTWF0cml4ID0gbmV3IE1hdHJpeDQoKSwgcmVsYXRpdmVNYXRyaXggPSBuZXcgTWF0cml4NCgpLCBnbG9iYWxNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICBvcHRpb25zLnByZXNlcnZlTWF0cml4ID0gb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCAhPT0gdm9pZCAwID8gb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCA6IHRydWU7XG4gIG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbiA9IG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbiAhPT0gdm9pZCAwID8gb3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uIDogdHJ1ZTtcbiAgb3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uID0gb3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uICE9PSB2b2lkIDAgPyBvcHRpb25zLnByZXNlcnZlSGlwUG9zaXRpb24gOiBmYWxzZTtcbiAgb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggPSBvcHRpb25zLnVzZVRhcmdldE1hdHJpeCAhPT0gdm9pZCAwID8gb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggOiBmYWxzZTtcbiAgb3B0aW9ucy5oaXAgPSBvcHRpb25zLmhpcCAhPT0gdm9pZCAwID8gb3B0aW9ucy5oaXAgOiBcImhpcFwiO1xuICBvcHRpb25zLm5hbWVzID0gb3B0aW9ucy5uYW1lcyB8fCB7fTtcbiAgY29uc3Qgc291cmNlQm9uZXMgPSBzb3VyY2UuaXNPYmplY3QzRCA/IHNvdXJjZS5za2VsZXRvbi5ib25lcyA6IGdldEJvbmVzKHNvdXJjZSksIGJvbmVzID0gdGFyZ2V0LmlzT2JqZWN0M0QgPyB0YXJnZXQuc2tlbGV0b24uYm9uZXMgOiBnZXRCb25lcyh0YXJnZXQpO1xuICBsZXQgYmluZEJvbmVzLCBib25lLCBuYW1lLCBib25lVG8sIGJvbmVzUG9zaXRpb247XG4gIGlmICh0YXJnZXQuaXNPYmplY3QzRCkge1xuICAgIHRhcmdldC5za2VsZXRvbi5wb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggPSB0cnVlO1xuICAgIG9wdGlvbnMucHJlc2VydmVNYXRyaXggPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uKSB7XG4gICAgYm9uZXNQb3NpdGlvbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJvbmVzUG9zaXRpb24ucHVzaChib25lc1tpXS5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlc2VydmVNYXRyaXgpIHtcbiAgICB0YXJnZXQudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICB0YXJnZXQubWF0cml4V29ybGQuaWRlbnRpdHkoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgdGFyZ2V0LmNoaWxkcmVuW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5vZmZzZXRzKSB7XG4gICAgYmluZEJvbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7ICsraSkge1xuICAgICAgYm9uZSA9IGJvbmVzW2ldO1xuICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZXNbYm9uZS5uYW1lXSB8fCBib25lLm5hbWU7XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXRzW25hbWVdKSB7XG4gICAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KG9wdGlvbnMub2Zmc2V0c1tuYW1lXSk7XG4gICAgICAgIGJvbmUubWF0cml4LmRlY29tcG9zZShib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUpO1xuICAgICAgICBib25lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICB9XG4gICAgICBiaW5kQm9uZXMucHVzaChib25lLm1hdHJpeFdvcmxkLmNsb25lKCkpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgYm9uZSA9IGJvbmVzW2ldO1xuICAgIG5hbWUgPSBvcHRpb25zLm5hbWVzW2JvbmUubmFtZV0gfHwgYm9uZS5uYW1lO1xuICAgIGJvbmVUbyA9IGdldEJvbmVCeU5hbWUobmFtZSwgc291cmNlQm9uZXMpO1xuICAgIGdsb2JhbE1hdHJpeC5jb3B5KGJvbmUubWF0cml4V29ybGQpO1xuICAgIGlmIChib25lVG8pIHtcbiAgICAgIGJvbmVUby51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgaWYgKG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4KSB7XG4gICAgICAgIHJlbGF0aXZlTWF0cml4LmNvcHkoYm9uZVRvLm1hdHJpeFdvcmxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbGF0aXZlTWF0cml4LmNvcHkodGFyZ2V0Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgICAgcmVsYXRpdmVNYXRyaXgubXVsdGlwbHkoYm9uZVRvLm1hdHJpeFdvcmxkKTtcbiAgICAgIH1cbiAgICAgIHNjYWxlLnNldEZyb21NYXRyaXhTY2FsZShyZWxhdGl2ZU1hdHJpeCk7XG4gICAgICByZWxhdGl2ZU1hdHJpeC5zY2FsZShzY2FsZS5zZXQoMSAvIHNjYWxlLngsIDEgLyBzY2FsZS55LCAxIC8gc2NhbGUueikpO1xuICAgICAgZ2xvYmFsTWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHF1YXQuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHJlbGF0aXZlTWF0cml4KSk7XG4gICAgICBpZiAodGFyZ2V0LmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY29uc3QgYm9uZUluZGV4ID0gYm9uZXMuaW5kZXhPZihib25lKSwgd0JpbmRNYXRyaXggPSBiaW5kQm9uZXMgPyBiaW5kQm9uZXNbYm9uZUluZGV4XSA6IGJpbmRCb25lTWF0cml4LmNvcHkodGFyZ2V0LnNrZWxldG9uLmJvbmVJbnZlcnNlc1tib25lSW5kZXhdKS5pbnZlcnQoKTtcbiAgICAgICAgZ2xvYmFsTWF0cml4Lm11bHRpcGx5KHdCaW5kTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGdsb2JhbE1hdHJpeC5jb3B5UG9zaXRpb24ocmVsYXRpdmVNYXRyaXgpO1xuICAgIH1cbiAgICBpZiAoYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lKSB7XG4gICAgICBib25lLm1hdHJpeC5jb3B5KGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgIGJvbmUubWF0cml4Lm11bHRpcGx5KGdsb2JhbE1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvbmUubWF0cml4LmNvcHkoZ2xvYmFsTWF0cml4KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJlc2VydmVIaXBQb3NpdGlvbiAmJiBuYW1lID09PSBvcHRpb25zLmhpcCkge1xuICAgICAgYm9uZS5tYXRyaXguc2V0UG9zaXRpb24ocG9zLnNldCgwLCBib25lLnBvc2l0aW9uLnksIDApKTtcbiAgICB9XG4gICAgYm9uZS5tYXRyaXguZGVjb21wb3NlKGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSk7XG4gICAgYm9uZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlUG9zaXRpb24pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBib25lID0gYm9uZXNbaV07XG4gICAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lLm5hbWVdIHx8IGJvbmUubmFtZTtcbiAgICAgIGlmIChuYW1lICE9PSBvcHRpb25zLmhpcCkge1xuICAgICAgICBib25lLnBvc2l0aW9uLmNvcHkoYm9uZXNQb3NpdGlvbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlTWF0cml4KSB7XG4gICAgdGFyZ2V0LnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiByZXRhcmdldENsaXAodGFyZ2V0LCBzb3VyY2UsIGNsaXAsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbiA9IG9wdGlvbnMudXNlRmlyc3RGcmFtZVBvc2l0aW9uICE9PSB2b2lkIDAgPyBvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbiA6IGZhbHNlO1xuICBvcHRpb25zLmZwcyA9IG9wdGlvbnMuZnBzICE9PSB2b2lkIDAgPyBvcHRpb25zLmZwcyA6IDMwO1xuICBvcHRpb25zLm5hbWVzID0gb3B0aW9ucy5uYW1lcyB8fCBbXTtcbiAgaWYgKCFzb3VyY2UuaXNPYmplY3QzRCkge1xuICAgIHNvdXJjZSA9IGdldEhlbHBlckZyb21Ta2VsZXRvbihzb3VyY2UpO1xuICB9XG4gIGNvbnN0IG51bUZyYW1lcyA9IE1hdGgucm91bmQoY2xpcC5kdXJhdGlvbiAqIChvcHRpb25zLmZwcyAvIDFlMykgKiAxZTMpLCBkZWx0YSA9IDEgLyBvcHRpb25zLmZwcywgY29udmVydGVkVHJhY2tzID0gW10sIG1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHNvdXJjZSksIGJvbmVzID0gZ2V0Qm9uZXModGFyZ2V0LnNrZWxldG9uKSwgYm9uZURhdGFzID0gW107XG4gIGxldCBwb3NpdGlvbk9mZnNldCwgYm9uZSwgYm9uZVRvLCBib25lRGF0YSwgbmFtZTtcbiAgbWl4ZXIuY2xpcEFjdGlvbihjbGlwKS5wbGF5KCk7XG4gIG1peGVyLnVwZGF0ZSgwKTtcbiAgc291cmNlLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRnJhbWVzOyArK2kpIHtcbiAgICBjb25zdCB0aW1lID0gaSAqIGRlbHRhO1xuICAgIHJldGFyZ2V0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJvbmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lc1tqXS5uYW1lXSB8fCBib25lc1tqXS5uYW1lO1xuICAgICAgYm9uZVRvID0gZ2V0Qm9uZUJ5TmFtZShuYW1lLCBzb3VyY2Uuc2tlbGV0b24pO1xuICAgICAgaWYgKGJvbmVUbykge1xuICAgICAgICBib25lID0gYm9uZXNbal07XG4gICAgICAgIGJvbmVEYXRhID0gYm9uZURhdGFzW2pdID0gYm9uZURhdGFzW2pdIHx8IHsgYm9uZSB9O1xuICAgICAgICBpZiAob3B0aW9ucy5oaXAgPT09IG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWJvbmVEYXRhLnBvcykge1xuICAgICAgICAgICAgYm9uZURhdGEucG9zID0ge1xuICAgICAgICAgICAgICB0aW1lczogbmV3IEZsb2F0MzJBcnJheShudW1GcmFtZXMpLFxuICAgICAgICAgICAgICB2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzICogMylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25PZmZzZXQgPSBib25lLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib25lLnBvc2l0aW9uLnN1Yihwb3NpdGlvbk9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvbmVEYXRhLnBvcy50aW1lc1tpXSA9IHRpbWU7XG4gICAgICAgICAgYm9uZS5wb3NpdGlvbi50b0FycmF5KGJvbmVEYXRhLnBvcy52YWx1ZXMsIGkgKiAzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvbmVEYXRhLnF1YXQpIHtcbiAgICAgICAgICBib25lRGF0YS5xdWF0ID0ge1xuICAgICAgICAgICAgdGltZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzKSxcbiAgICAgICAgICAgIHZhbHVlczogbmV3IEZsb2F0MzJBcnJheShudW1GcmFtZXMgKiA0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYm9uZURhdGEucXVhdC50aW1lc1tpXSA9IHRpbWU7XG4gICAgICAgIGJvbmUucXVhdGVybmlvbi50b0FycmF5KGJvbmVEYXRhLnF1YXQudmFsdWVzLCBpICogNCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1peGVyLnVwZGF0ZShkZWx0YSk7XG4gICAgc291cmNlLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lRGF0YXMubGVuZ3RoOyArK2kpIHtcbiAgICBib25lRGF0YSA9IGJvbmVEYXRhc1tpXTtcbiAgICBpZiAoYm9uZURhdGEpIHtcbiAgICAgIGlmIChib25lRGF0YS5wb3MpIHtcbiAgICAgICAgY29udmVydGVkVHJhY2tzLnB1c2goXG4gICAgICAgICAgbmV3IFZlY3RvcktleWZyYW1lVHJhY2soXG4gICAgICAgICAgICBcIi5ib25lc1tcIiArIGJvbmVEYXRhLmJvbmUubmFtZSArIFwiXS5wb3NpdGlvblwiLFxuICAgICAgICAgICAgYm9uZURhdGEucG9zLnRpbWVzLFxuICAgICAgICAgICAgYm9uZURhdGEucG9zLnZhbHVlc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnZlcnRlZFRyYWNrcy5wdXNoKFxuICAgICAgICBuZXcgUXVhdGVybmlvbktleWZyYW1lVHJhY2soXG4gICAgICAgICAgXCIuYm9uZXNbXCIgKyBib25lRGF0YS5ib25lLm5hbWUgKyBcIl0ucXVhdGVybmlvblwiLFxuICAgICAgICAgIGJvbmVEYXRhLnF1YXQudGltZXMsXG4gICAgICAgICAgYm9uZURhdGEucXVhdC52YWx1ZXNcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbWl4ZXIudW5jYWNoZUFjdGlvbihjbGlwKTtcbiAgcmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKGNsaXAubmFtZSwgLTEsIGNvbnZlcnRlZFRyYWNrcyk7XG59XG5mdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgY29uc3Qgc291cmNlTG9va3VwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY2xvbmVMb29rdXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjbG9uZTIgPSBzb3VyY2UuY2xvbmUoKTtcbiAgcGFyYWxsZWxUcmF2ZXJzZShzb3VyY2UsIGNsb25lMiwgZnVuY3Rpb24oc291cmNlTm9kZSwgY2xvbmVkTm9kZSkge1xuICAgIHNvdXJjZUxvb2t1cC5zZXQoY2xvbmVkTm9kZSwgc291cmNlTm9kZSk7XG4gICAgY2xvbmVMb29rdXAuc2V0KHNvdXJjZU5vZGUsIGNsb25lZE5vZGUpO1xuICB9KTtcbiAgY2xvbmUyLnRyYXZlcnNlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNTa2lubmVkTWVzaClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjbG9uZWRNZXNoID0gbm9kZTtcbiAgICBjb25zdCBzb3VyY2VNZXNoID0gc291cmNlTG9va3VwLmdldChub2RlKTtcbiAgICBjb25zdCBzb3VyY2VCb25lcyA9IHNvdXJjZU1lc2guc2tlbGV0b24uYm9uZXM7XG4gICAgY2xvbmVkTWVzaC5za2VsZXRvbiA9IHNvdXJjZU1lc2guc2tlbGV0b24uY2xvbmUoKTtcbiAgICBjbG9uZWRNZXNoLmJpbmRNYXRyaXguY29weShzb3VyY2VNZXNoLmJpbmRNYXRyaXgpO1xuICAgIGNsb25lZE1lc2guc2tlbGV0b24uYm9uZXMgPSBzb3VyY2VCb25lcy5tYXAoZnVuY3Rpb24oYm9uZSkge1xuICAgICAgcmV0dXJuIGNsb25lTG9va3VwLmdldChib25lKTtcbiAgICB9KTtcbiAgICBjbG9uZWRNZXNoLmJpbmQoY2xvbmVkTWVzaC5za2VsZXRvbiwgY2xvbmVkTWVzaC5iaW5kTWF0cml4KTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTI7XG59XG5mdW5jdGlvbiBnZXRCb25lQnlOYW1lKG5hbWUsIHNrZWxldG9uKSB7XG4gIGZvciAobGV0IGkgPSAwLCBib25lcyA9IGdldEJvbmVzKHNrZWxldG9uKTsgaSA8IGJvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IGJvbmVzW2ldLm5hbWUpXG4gICAgICByZXR1cm4gYm9uZXNbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEJvbmVzKHNrZWxldG9uKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHNrZWxldG9uKSA/IHNrZWxldG9uIDogc2tlbGV0b24uYm9uZXM7XG59XG5mdW5jdGlvbiBnZXRIZWxwZXJGcm9tU2tlbGV0b24oc2tlbGV0b24pIHtcbiAgY29uc3Qgc291cmNlID0gbmV3IFNrZWxldG9uSGVscGVyKHNrZWxldG9uLmJvbmVzWzBdKTtcbiAgc291cmNlLnNrZWxldG9uID0gc2tlbGV0b247XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBwYXJhbGxlbFRyYXZlcnNlKGEsIGIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKGEsIGIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJhbGxlbFRyYXZlcnNlKGEuY2hpbGRyZW5baV0sIGIuY2hpbGRyZW5baV0sIGNhbGxiYWNrKTtcbiAgfVxufVxuY29uc3QgU2tlbGV0b25VdGlscyA9IHsgcmV0YXJnZXQsIHJldGFyZ2V0Q2xpcCwgY2xvbmUgfTtcbmV4cG9ydCB7XG4gIFNrZWxldG9uVXRpbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ta2VsZXRvblV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiTWF0cml4NCIsIkFuaW1hdGlvbk1peGVyIiwiVmVjdG9yS2V5ZnJhbWVUcmFjayIsIlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIiwiQW5pbWF0aW9uQ2xpcCIsIlNrZWxldG9uSGVscGVyIiwicmV0YXJnZXQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJvcHRpb25zIiwicG9zIiwicXVhdCIsInNjYWxlIiwiYmluZEJvbmVNYXRyaXgiLCJyZWxhdGl2ZU1hdHJpeCIsImdsb2JhbE1hdHJpeCIsInByZXNlcnZlTWF0cml4IiwicHJlc2VydmVQb3NpdGlvbiIsInByZXNlcnZlSGlwUG9zaXRpb24iLCJ1c2VUYXJnZXRNYXRyaXgiLCJoaXAiLCJuYW1lcyIsInNvdXJjZUJvbmVzIiwiaXNPYmplY3QzRCIsInNrZWxldG9uIiwiYm9uZXMiLCJnZXRCb25lcyIsImJpbmRCb25lcyIsImJvbmUiLCJuYW1lIiwiYm9uZVRvIiwiYm9uZXNQb3NpdGlvbiIsInBvc2UiLCJpIiwibGVuZ3RoIiwicHVzaCIsInBvc2l0aW9uIiwiY2xvbmUiLCJ1cGRhdGVNYXRyaXhXb3JsZCIsIm1hdHJpeFdvcmxkIiwiaWRlbnRpdHkiLCJjaGlsZHJlbiIsIm9mZnNldHMiLCJtYXRyaXgiLCJtdWx0aXBseSIsImRlY29tcG9zZSIsInF1YXRlcm5pb24iLCJnZXRCb25lQnlOYW1lIiwiY29weSIsImludmVydCIsInNldEZyb21NYXRyaXhTY2FsZSIsInNldCIsIngiLCJ5IiwieiIsIm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4IiwiYm9uZUluZGV4IiwiaW5kZXhPZiIsIndCaW5kTWF0cml4IiwiYm9uZUludmVyc2VzIiwiY29weVBvc2l0aW9uIiwicGFyZW50IiwiaXNCb25lIiwic2V0UG9zaXRpb24iLCJyZXRhcmdldENsaXAiLCJjbGlwIiwidXNlRmlyc3RGcmFtZVBvc2l0aW9uIiwiZnBzIiwiZ2V0SGVscGVyRnJvbVNrZWxldG9uIiwibnVtRnJhbWVzIiwiTWF0aCIsInJvdW5kIiwiZHVyYXRpb24iLCJkZWx0YSIsImNvbnZlcnRlZFRyYWNrcyIsIm1peGVyIiwiYm9uZURhdGFzIiwicG9zaXRpb25PZmZzZXQiLCJib25lRGF0YSIsImNsaXBBY3Rpb24iLCJwbGF5IiwidXBkYXRlIiwidGltZSIsImoiLCJ0aW1lcyIsIkZsb2F0MzJBcnJheSIsInZhbHVlcyIsInN1YiIsInRvQXJyYXkiLCJ1bmNhY2hlQWN0aW9uIiwic291cmNlTG9va3VwIiwiTWFwIiwiY2xvbmVMb29rdXAiLCJjbG9uZTIiLCJwYXJhbGxlbFRyYXZlcnNlIiwic291cmNlTm9kZSIsImNsb25lZE5vZGUiLCJ0cmF2ZXJzZSIsIm5vZGUiLCJpc1NraW5uZWRNZXNoIiwiY2xvbmVkTWVzaCIsInNvdXJjZU1lc2giLCJnZXQiLCJiaW5kTWF0cml4IiwibWFwIiwiYmluZCIsIkFycmF5IiwiaXNBcnJheSIsImEiLCJiIiwiY2FsbGJhY2siLCJTa2VsZXRvblV0aWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\n");

/***/ })

};
;